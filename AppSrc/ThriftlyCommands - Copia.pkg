#Replace HANDLE$MESSAGE$2 THRIFTLY$MESSAGE
#Replace DF$OBJECT THRIFTLY$OBJECT

#IF (!@ >= 171)
//=========================================================================================================================================================================================================
//*********************************************************************************************************************************************************************************************************
// This is the custom Object command for VDF 17.1 and greater
//*********************************************************************************************************************************************************************************************************
//=========================================================================================================================================================================================================

#COMMAND THRIFTLY$OBJECT R "IS" "A""AN" RVD#I


  #IF (!b & 2) // if within a class
    #IF ( (!b & 4)=0 ) // should be within a method
      #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT Objects in classes should be within a method
    #ENDIF
  #ENDIF

  // if we are within a method we will keep track of the number of
  // nested objects. When the method ends we will verify that this is 0.
  // This lets us warn about mismathed object/end-object commands
  #IF ( !b & 4)   // if object within method
    #SET ZM$ !ZM  // increment
  #ENDIF


  #DATA                   // start up the data stream
  #PUSH !Zj               // save the unique object label
  #PUSH !b                // save current definition state

  #IF (!b > 0)            // if not global..we make no guesses about
                          // dependent numbers. Let the runtime assign
                          // dependent order.
  //#IF (!b = 4)          // if in procedure and not class
    #SET ZJ$ 0            // do not inc z
  #ELSE
    #SET ZJ$ !ZB          // assign the next object id
  #ENDIF
  #PUSH !Zb               // save this level on stack
  #IFDEF !4.AGG           // was this a class with sub objects?
    #SET ZB$ !4.AGG       // sub objects will begin at the
  #ELSE                   // next object after superclass
    #SET ZB$ 0            // base classes start at 0
  #ENDIF
  #SET ZI$ !ZI            // count this object at the current level
  #PUSH !Zi               // and push the level
  #IF (!b > 0)            // if (in_object | in_class)
    #IF (!b & 2)          // obj_flag == in_class?
      #IF (!b & 1)        // obj_flag == in_Object?
      #ELSE               // No Name for Subobject in constructor
        // don't define this anymore...
        //#REPLACE !$.!1.OBJ |CI-!Zj  // object_name = -current_object
      #ENDIF
    #ENDIF
    // (LS) removed setting of ZJ; it is NOT being used.
    // (Removed when max lines increased > 32k)
    //      #SET ZJ$ (32766-!a)           // a very unique label for this object
    
    // 17.1. push the case sensitive name of the object instead of the uppercased string
    //       this way object_label is saved case sensitive. Needed for WebApp
    
    // it is possible that the case preserved name from the source line may not exist or
    // not be valid. This happens when the Object command is used in a macro expansion. In
    // such a case we must revert to using the !1 passed object name, which is uppercased.
    // To test for this, we check that the value in !$ uppercased is the same as !1. If so
    // we can use !$, else we must use !1. Testing this is a little tricky because !$ can be
    // empty. We test this using TEST$SAME$STRING passing a mangled versions of !$ and !1. 
    // They are mangled so they will not be blank. The macro substution will upper case !$
    // so it should be the same as !1. TEST$SAME$STRING will set !Zg to 0 or 1. Therefore
    // we must #PUSH and #POP !Zg
    
    #SPUSH      // push current compiler string
    #SET $$     // clear compiler string
    #CNAME 1
    #PUSH !Zg   // TEXT$SAME$STRING will set this, so push it and pop it when done
    TEST$SAME$STRING _!$_ _!1_  // tests if case preserved name (!$) and name (!1) are equal. Names are mangled in case they are blank
    #IF (!Zg=0)
      #DPUSH |CS".!1"           // !$ not valid, must use uppercased param
    #ELSE
      #DPUSH |CS".!$"           // !$ valid use this.
    #ENDIF
    #POP ZG$     
    #SPOP       // pop compiler string

//    #DPUSH |CS".!1"           // make name from parent and child
  #ELSE               // global object name
    // 17.1. push the case sensitive name of the object. Same logic as above
    #SPUSH      // push current compiler string
    #SET $$     // clear compiler string
    #CNAME 1
    #PUSH !Zg   // TEXT$SAME$STRING will set this, so push it and pop it when done
    TEST$SAME$STRING _!$_ _!1_  // tests if case preserved name (!$) and name (!1) are equal.  Names are mangled in case they are blank
    #IF (!Zg=0)
      #DPUSH |CS".!1"           // !$ not valid, must use uppercased param
    #ELSE
      #DPUSH |CS".!$"           // !$ valid use this.
    #ENDIF
    #POP ZG$     
    #SPOP       // pop compiler string

//    #DPUSH |CS"!1"            // assign an absolute name to object
  #ENDIF
  #CHECK U_!4 _U          // does class exist?
  #DPUSH U_!4             // define then class the class id
  GET$OBJ$IMAGE !5            // define the objects image
  #IF ((!b & 3) = 2)          // if in_class & !in_object
    // don't assign dep nums anymore
    //#DPUSH !$.!1.OBJ          // pick the assigned dependant number
    // New code just sets 0
    #DPUSH |CI0           // pick the next dependant number
  #ELSE               //
    #IF (!b = 0)          // A global object must assign #
      #IFDEF !1.OBJ           // Is the symbol defined, name_object?
        #DPUSH |CI0           // pick the next dependant number
      #ELSE
        #DPUSH |CI!Zj         // force the dependant number
//        #SET ZJ$ ($1000+!Zj)       // mark as global object
        #SET ZJ$ ($10000000+!Zj)   // using 32-bit ids now
        // as of 8.3 we no longer use dependent lists so we cannot create the ObjName.obj symbol anymore. This method of ussage has
        // been deprecated since early framework days and it is now no longer suppoted. The only way you can use the .obj method is to
        // use name_object, which moves this into a global integer variable. Developers are advised to change the ObjName.obj to
        // (ObjName(desktop)).
        // Also I don't think the above Zj is even needed, but for now they remain.
        //#REPLACE !1.OBJ |CI!Zj        // Assign an ID to this object
      #ENDIF
    #ELSE
      #DPUSH |CI0         // pick the next dependant number
    #ENDIF
  #ENDIF
  Register_Object !1
  #DPUSH GET_!1
  #SET B$ (!b | 1)            // we are in a object definition
  !A [] OBJ$CREATE |VL        // create the object now

  #IFDEF !1.OBJ
    #IFCLASS !1.OBJ V$        // does this object have a global?
      Move CURRENT_OBJECT to !1.OBJ   // Move the object id to its global
    #ENDIF
  #ENDIF

  #SPUSH   //save the old class name
  #SET $$ !4
  #IFSUB '!$$SC' // if flex-defined class
    #IFSUB '!$$SM' // if begin-instance macro exists
      #IFDEF IS$WINDOWS
        // in windows we know that an image is always passed (object creates one if needed)
        // and that images are never used. Therefore replace image argument with 0.
        !$$SM !$ 0 !6 !7 !8 !9
      #ELSE
        // character might be passing an image and it might not. We must pass the value
        !$$SM !$ !5 !6 !7 !8 !9
      #ENDIF
    #ELSE
      FORWARD_BEGIN_CONSTRUCT !$ !5 !6 !7 !8 !9
    #ENDIF
  #ELSE
    ADD$IMAGE$ARGS MSG_CONSTRUCT_OBJECT !5 !6 !7 !8 !9  //else use default
  #ENDIF

  // If Secured is True, make sure we set it to true
  #IFMATTR Secured True
     Set pbDefaultSecured to True
  #ELSE
    // If we get in here, either the developer didn't set it (and we default to True)
    // or they set it to False intentionally
    #IFMATTR Secured False
      set pbDefaultSecured False
    #ENDIF
  #ENDIF

#ENDCOMMAND

#ELSE
  #IF (!@ > 120)
//=========================================================================================================================================================================================================
//*********************************************************************************************************************************************************************************************************
// This is the custom Object command for VDF 12-17.0 and greater
//*********************************************************************************************************************************************************************************************************
//=========================================================================================================================================================================================================
#COMMAND THRIFTLY$OBJECT R "IS" "A""AN" RVD#I

  #IF (!b & 2) // if within a class
    #IF ( (!b & 4)=0 ) // should be within a method
      #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT Objects in classes should be within a method
    #ENDIF
  #ENDIF

  // if we are within a method we will keep track of the number of
  // nested objects. When the method ends we will verify that this is 0.
  // This lets us warn about mismathed object/end-object commands
  #IF ( !b & 4)   // if object within method
    #SET ZM$ !ZM  // increment
  #ENDIF


  #DATA                   // start up the data stream
  #PUSH !Zj               // save the unique object label
  #PUSH !b                // save current definition state

  #IF (!b > 0)            // if not global..we make no guesses about
                          // dependent numbers. Let the runtime assign
                          // dependent order.
  //#IF (!b = 4)          // if in procedure and not class
    #SET ZJ$ 0            // do not inc z
  #ELSE
    #SET ZJ$ !ZB          // assign the next object id
  #ENDIF
  #PUSH !Zb               // save this level on stack
  #IFDEF !4.AGG           // was this a class with sub objects?
    #SET ZB$ !4.AGG       // sub objects will begin at the
  #ELSE                   // next object after superclass
    #SET ZB$ 0            // base classes start at 0
  #ENDIF
  #SET ZI$ !ZI            // count this object at the current level
  #PUSH !Zi               // and push the level
  #IF (!b > 0)            // if (in_object | in_class)
    #IF (!b & 2)          // obj_flag == in_class?
      #IF (!b & 1)        // obj_flag == in_Object?
      #ELSE               // No Name for Subobject in constructor
        // don't define this anymore...
        //#REPLACE !$.!1.OBJ |CI-!Zj  // object_name = -current_object
      #ENDIF
    #ENDIF
    // (LS) removed setting of ZJ; it is NOT being used.
    // (Removed when max lines increased > 32k)
    //      #SET ZJ$ (32766-!a)           // a very unique label for this object
    #DPUSH |CS".!1"           // make name from parent and child
  #ELSE               // global object name
    #DPUSH |CS"!1"            // assign an absolute name to object
  #ENDIF
  #CHECK U_!4 _U          // does class exist?
  #DPUSH U_!4             // define then class the class id
  GET$OBJ$IMAGE !5            // define the objects image
  #IF ((!b & 3) = 2)          // if in_class & !in_object
    // don't assign dep nums anymore
    //#DPUSH !$.!1.OBJ          // pick the assigned dependant number
    // New code just sets 0
    #DPUSH |CI0           // pick the next dependant number
  #ELSE               //
    #IF (!b = 0)          // A global object must assign #
      #IFDEF !1.OBJ           // Is the symbol defined, name_object?
        #DPUSH |CI0           // pick the next dependant number
      #ELSE
        #DPUSH |CI!Zj         // force the dependant number
//        #SET ZJ$ ($1000+!Zj)       // mark as global object
        #SET ZJ$ ($10000000+!Zj)   // using 32-bit ids now
        // as of 8.3 we no longer use dependent lists so we cannot create the ObjName.obj symbol anymore. This method of ussage has
        // been deprecated since early framework days and it is now no longer suppoted. The only way you can use the .obj method is to
        // use name_object, which moves this into a global integer variable. Developers are advised to change the ObjName.obj to
        // (ObjName(desktop)).
        // Also I don't think the above Zj is even needed, but for now they remain.
        //#REPLACE !1.OBJ |CI!Zj        // Assign an ID to this object
      #ENDIF
    #ELSE
      #DPUSH |CI0         // pick the next dependant number
    #ENDIF
  #ENDIF
  REGISTER_OBJECT !1
  #DPUSH GET_!1
  #SET B$ (!b | 1)            // we are in a object definition
  !A [] OBJ$CREATE |VL        // create the object now

  #IFDEF !1.OBJ
    #IFCLASS !1.OBJ V$        // does this object have a global?
      MOVE CURRENT_OBJECT TO !1.OBJ   // Move the object id to its global
    #ENDIF
  #ENDIF

  #SPUSH   //save the old class name
  #SET $$ !4
  #IFSUB '!$$SC' // if flex-defined class
    #IFSUB '!$$SM' // if begin-instance macro exists
      #IFDEF IS$WINDOWS
        // in windows we know that an image is always passed (object creates one if needed)
        // and that images are never used. Therefore replace image argument with 0.
        !$$SM !$ 0 !6 !7 !8 !9
      #ELSE
        // character might be passing an image and it might not. We must pass the value
        !$$SM !$ !5 !6 !7 !8 !9
      #ENDIF
    #ELSE
      FORWARD_BEGIN_CONSTRUCT !$ !5 !6 !7 !8 !9
    #ENDIF
  #ELSE
    ADD$IMAGE$ARGS MSG_CONSTRUCT_OBJECT !5 !6 !7 !8 !9  //else use default
  #ENDIF

  // If Secured is True, make sure we set it to true
  #IFMATTR Secured True
     Set pbDefaultSecured to True
  #ELSE
    // If we get in here, either the developer didn't set it (and we default to True)
    // or they set it to False intentionally
    #IFMATTR Secured False
      set pbDefaultSecured False
    #ENDIF
  #ENDIF
#ENDCOMMAND

  #ELSE
      #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT "Thriftly will only work with Dataflex 12.0 and newer"
  #ENDIF
#ENDIF

#IF (!@ >= 150)
//=========================================================================================================================================================================================================
//*********************************************************************************************************************************************************************************************************
// This is the custom message command for VDF 15-19
//*********************************************************************************************************************************************************************************************************
//=========================================================================================================================================================================================================

#COMMAND THRIFTLY$MESSAGE RGOBL#

  #IFDEF UI.EXISTS
  #ELSE
    Use UI
  #ENDIF

  // if the publish meta-attribute is set, we want to generate the RegisterInterface command before we do anything in this new method.
  // we will also check as many things as possible to make sure this is a valid place for this. We expect this:
  // 1. to appear in classes and not objects
  // 2. cannot be global, FOR, or desktop
  // 3. cannnot be override

  // If the meta attribute Published is true, we handle special case for webapps.
  // note I am not checking for the Mangle_names ifdef - I just assume it's true (hasn't been unset for many versions).
  #IFMATTR Published True  // This is true if the Published attribute is active and its value is true
    // method must be an object method and not For, global or overloaded
    #IFMATTR AuthMethod True
      #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT "The AuthMethod cannot also be a Published method"
    #ENDIF

    #IFSAME !3 Global for Overloaded // any of these are not allowed. Note that DESKTOP is already converted to For cDesktop at this point
      #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT "The Publish meta tag cannot be used with GLOBAL, DESKTOP, FOR, or OVERLOADED methods."
    #ELSE
      #IF (!b = 1)   // the only valid place for this is within a method within an object.
        #IFMATTR Secured True
            MESSAGE$ADDRESS !1_!2  // create id symbol for this message. We do this to avoid fowward reference error in registerInterface
            #SPUSH
            #PUBLISH  //  This creates the Send RegisterInterface line and puts the result in !$, based on the original source line which is expected to be something like Function Foo Integer iArg...
            !$ OLEEVO_METHOD_DEFAULT      //  This would then actually call Send RegisterInterface
            #REM !$
            #SPOP
        #ELSE
          #IFMATTR Secured False
            MESSAGE$ADDRESS !1_!2  // create id symbol for this message. We do this to avoid fowward reference error in registerInterface
            #SPUSH
            #PUBLISH  //  This creates the Send RegisterInterface line and puts the result in !$, based on the original source line which is expected to be something like Function Foo Integer iArg...
            !$ OLEEVO_METHOD_UNSECURED      //  This would then actually call Send RegisterInterface
            #REM !$
            #SPOP
          #ELSE
            #IFMATTR LoginMethod True
              MESSAGE$ADDRESS !1_!2  // create id symbol for this message. We do this to avoid fowward reference error in registerInterface
              #SPUSH
              #PUBLISH  //  This creates the Send RegisterInterface line and puts the result in !$, based on the original source line which is expected to be something like Function Foo Integer iArg...
              !$ OLEEVO_METHOD_LOGIN      //  This would then actually call Send RegisterInterface
              #REM !$
              #SPOP
            #ELSE
              MESSAGE$ADDRESS !1_!2  // create id symbol for this message. We do this to avoid fowward reference error in registerInterface
              #SPUSH
              #PUBLISH  //  This creates the Send RegisterInterface line and puts the result in !$, based on the original source line which is expected to be something like Function Foo Integer iArg...
              !$ (IF(pbDefaultSecured(Self), OLEEVO_METHOD_DEFAULT, OLEEVO_METHOD_UNSECURED))      //  This would then actually call Send RegisterInterface
              #REM !$
              #SPOP
            #ENDIF
          #ENDIF
        #ENDIF
      #ELSE
        #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT "The Publish meta tag can only be used within methods defined directly inside of objects."
      #ENDIF
    #ENDIF
  #ENDIF

  #IFMATTR LoginMethod True  // This is true if the AuthMethod attribute is active and its value is true
    #IFMATTR AuthMethod True
      #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT "The Login method cannot also be an Auth method"
    #ENDIF
    #IFMATTR Published True
    #ELSE
      // method must be an object method and not For, global or overloaded
      #IFSAME !3 Global for Overloaded // any of these are not allowed. Note that DESKTOP is already converted to For cDesktop at this point
        #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT "The LoginMethod meta tag cannot be used with GLOBAL, DESKTOP, FOR, or OVERLOADED methods."
      #ELSE
        #IF (!b = 1)   // the only valid place for this is within a method within an object.
          MESSAGE$ADDRESS !1_!2  // create id symbol for this message. We do this to avoid fowward reference error in registerInterface
          #SPUSH
          #PUBLISH  //  This creates the Send RegisterInterface line and puts the result in !$, based on the original source line which is expected to be something like Function Foo Integer iArg...
          !$ OLEEVO_METHOD_LOGIN //  This would then actually call Send RegisterInterface
          #REM !$
          #SPOP
        #ELSE
          #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT "The LoginMethod meta tag can only be used on methods defined directly inside of objects."
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF

  #IFMATTR AuthMethod True  // This is true if the AuthMethod attribute is active and its value is true
    #IFMATTR Published True
      #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT "The Auth method cannot also be a Published method"
    #ENDIF
    #IFMATTR LoginMethod True
      #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT "The Auth method cannot also be a Login method"
    #ENDIF

    // method must be an object method and not For, global or overloaded
    #IFSAME !3 Global for Overloaded // any of these are not allowed. Note that DESKTOP is already converted to For cDesktop at this point
      #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT "The AuthMethod meta tag cannot be used with GLOBAL, DESKTOP, FOR, or OVERLOADED methods."
    #ELSE
      #IF (!b = 1)   // the only valid place for this is within a method within an object.
        MESSAGE$ADDRESS !1_!2  // create id symbol for this message. We do this to avoid fowward reference error in registerInterface
        #SPUSH
        #PUBLISH  //  This creates the Send RegisterInterface line and puts the result in !$, based on the original source line which is expected to be something like Function Foo Integer iArg...
        !$ OLEEVO_METHOD_AUTH //  This would then actually call Send RegisterInterface
        #REM !$
        #SPOP
      #ELSE
        #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT "The AuthMethod meta tag can only be used on methods defined directly inside of objects."
      #ENDIF
    #ENDIF
  #ENDIF



  // procedure construct_object only allowed in class
  #IF (!b & 1) // if in object
    #IFDEF MANGLE_NAMES
      #IFSAME !1 MSG
        #IFSAME !2 CONSTRUCT_OBJECT
          #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT Construct_object .not. allowed in objects
        #ENDIF
      #ENDIF
    #ELSE
      #IFSAME !1 MSG_CONSTRUCT_OBJECT
        #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT Construct_object .not. allowed in objects
      #ENDIF
    #ENDIF
  #ENDIF

  // not allowed to nest methods
  // Check flag to determine whether we are already in a method.
  #IF (!b & 4)
    #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT Procedures and Functions may .not. be nested.
  #ELSE
    // non global methods are not allowed class child-objects

    #IFNDEF MANGLE_NAMES

      #IFSAME !2 Global
      #ELSE
        #IF ((!b & 3)=3) // if in class object
          #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT Methods .not. allowed in Class child-objects
        #ENDIF
      #ENDIF

    #ELSE

      #IFSAME !3 Global
      #ELSE
        #IF ((!b & 3)=3) // if in class object
          #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT Methods .not. allowed in Class child-objects
        #ENDIF
      #ENDIF

    #ENDIF
  #ENDIF

  // Give error if the stack symbol NUM_ARGUMENTS is defined.
  #CHECK NUM_ARGUMENTS _T

  //
  #SET ZN$ !n     // static nesting level
  #SET ZM$ 0      // # objects in method
  #PUSH !Zg
  #PUSH !Za
  #SET ZA$ !a
  #PUSH !Zu
  #DATA
  #STKSYM                      // forget all old stack symbols
  #SET B$ (!b | 4)             // set flag to in_procedure

  // This was changed to allow us to prohibit arguments with num_arguments inside the scope of a function.
  #Replace NUM_ARGUMENTS |SI0  // define the arg count

  #IFDEF MANGLE_NAMES
    #SREP __@INSIDE_FUNCTION@__   |CI1   // lets other commands check that they are inside a function scope.
  #ENDIF

  #IFNDEF MANGLE_NAMES


  #ELSE

  //  This is the mangling code.

    #IFSAME !3 Global
      #DPUSH |CI0         // No message
      #DPUSH |CI0         // for no class
      // Check if overloaded symbol is already defined.
      #IFSAME Overloaded !4 !5 !6 !7 !8 !9
        #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION Global functions/procedures cannot be Overloaded
      #ELSE
        #IFDEF !1_!2_OVERLOADED
          #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION This Method Was Previously Defined as Overloaded
        #ELSE
          #IFDEF !1_!2
            #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION Global method !1 !2 Already Defined
          #ELSE
            #SET ZG$ (0-!a-2)   // make it negative to distuinguish it
            #Replace !1_!2 |CI!Zg
          #ENDIF
        #ENDIF
      #ENDIF
      CHECK$METHOD$ARGUMENT$LIST !4 !5 !6 !7 !8 !9
      #IF (!0>1)          // do we have arguments?
        #SET ZG$ 1        // starting argument number
        DEFINE_ARGUMENTS !4 !5 !6 !7 !8 !9
      #ENDIF

      HANDLE$MESSAGE$HELP !1 !1_!2 !3 !4 !5 !6 !7 !8 !9

    #ELSE  // not global functions

      // make sure message is not already defined as a global
      #IFDEF !1_!2
        #IF (!1_!2<0)  // if defined as a global already, we have an error
          #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION !1 !2 already defined as a Global method
        #ENDIF
      #ENDIF

      // Mangling case & Using FOR
      #IFSAME !3 for          // are we explicit about the class?

        #IFSAME Overloaded !5 !6 !7 !8 !9
          #IFDEF !1_!2
            #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION This Method Was Previously Defined as non-Overloaded
          #ELSE
            // we don't support Byref with overloading
            #IFSAME ByRef !5 !6 !7 !8 !9
              #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION "BYREF not allowed in overloaded methods"
            #ENDIF
            // Mangle name of method.
            #MARG !1_!2 !5 !6 !7 !8 !9
            // Also lock name without parameters and sugar.
            #IFNDEF !1_!2_OVERLOADED
              #Replace !1_!2_OVERLOADED  |CI1
            #ENDIF
            MESSAGE$ADDRESS !?         // create id symbol for this message
            #DPUSH !?
          #ENDIF
        #ELSE   // FOR class, but not an overloaded function.

          #IFDEF !1_!2_OVERLOADED
            #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION This Method Was Previously Defined as Overloaded
          #ELSE
            MESSAGE$ADDRESS  !1_!2  // create id symbol for this message
            #DPUSH !1_!2
          #ENDIF

        #ENDIF

        #IFDEF !4
          #IFSAME !4 DESKTOP
            #IFDEF IS$WINDOWS
              #DPUSH U_cObject  // Message for the desktop class
            #ELSE
              #DPUSH U_DESKTOP  // Message for the desktop class
            #ENDIF
          #ELSE
            #DPUSH !4         // Message for the named class
          #ENDIF
        #ELSE
          #CHECK U_!4 _RSDNU   // Check the class to see if it exists.
          #DPUSH U_!4         // Message for the named class
        #ENDIF

        CHECK$METHOD$ARGUMENT$LIST !5 !6 !7 !8 !9

        #IF (!0>3)
          #SET ZG$ 1                  // starting argument number
          DEFINE_ARGUMENTS !5 !6 !7 !8 !9
        #ENDIF

        #IFSAME Overloaded !4 !5 !6 !7 !8 !9              // Non global
          HANDLE$MESSAGE$HELP !1 !? !5 !6 !7 !8 !9
        #ELSE
          HANDLE$MESSAGE$HELP !1 !1_!2 !5 !6 !7 !8 !9
        #ENDIF

      #ELSE // Method is declared in a class or in an object
        #IF (!b & 2)              // obj_flag == in_class?
        #ELSE
          #IF (!b & 1)            // in_object, instance method
            !A [] CLONE$CLASS     // if in object, clone the class
          #ENDIF
        #ENDIF

        #IFSAME Overloaded !3 !4 !5 !6 !7 !8 !9
          #IFDEF !1_!2
            #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION This Method Was Previously Defined as non-Overloaded
          #ELSE
            // we don't support Byref with overloading
            #IFSAME ByRef !3 !4 !5 !6 !7 !8 !9
              #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION "BYREF not allowed in overloaded methods"
            #ENDIF
            #MARG !1_!2 !3 !4 !5 !6 !7 !8 !9
            MESSAGE$ADDRESS !?
            #IFNDEF !1_!2_OVERLOADED
              #Replace !1_!2_OVERLOADED  |CI1
            #ENDIF
            #DPUSH !?               // the message
          #ENDIF
        #ELSE
          // a non-overlaoded message
          #IFDEF !1_!2_OVERLOADED
            #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION This Method Was Previously Defined as Overloaded
          #ELSE
            MESSAGE$ADDRESS  !1_!2  // create id symbol for this message
            #DPUSH !1_!2
          #ENDIF
        #ENDIF

        // push the proper destination for the message
        #IF (!b & 2)             // obj_flag == in_class?
          #DPUSH U_!$            // handle msg for "current class"
        #ELSE
          #IF (!b & 1)           // in_object, instance method
            #DPUSH |CI0          // handle for objects class
          #ELSE                  // Message is out on desktop and not identfied w/ FOR Xxxxx
            #IFDEF IS$WINDOWS      // 8.3: if windows we are going to place this on the cDesktop object
                                   // which will allow all objects to delegate to it, which is probably
                                   // what people expect. Prior to 8.3, it create a "for desktop" so all classes/objects
                                   // immediately understood this. This represents a change in behavior.
              #REM Ambiguous methods on .DESKTOP. are .not. recommended (Obsolete technique)
              // this is not a real error but we can use this to look at ambiguous desktop methods to make make sure
              // that they are being used in the proper 8.3 style. This warning is controlled by the method
              // Compiler_desktop_method_warnings ON|OFF (OFF is default)
              #IF (!Zl & 4)
                 #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION Ambiguous method on .Desktop. Should be "Desktop" or "Global" or moved.
              #ENDIF
              #DPUSH U_cObject     // Message for the desktop (UI_OBJECT) class. Not advised for VDF after 8.2
            #ELSE
              #DPUSH U_DESKTOP     // Message for the desktop (UI_OBJECT) class. Not advised for VDF after 8.2
            #ENDIF
          #ENDIF   // stand alone message that gets defined as U_DESKTOP
        #ENDIF     // end of else of object method
        CHECK$METHOD$ARGUMENT$LIST !3 !4 !5 !6 !7 !8 !9
        #IF (!0>1)                // do we have arguments?
          #SET ZG$ 1                  // starting argument number
          DEFINE_ARGUMENTS !3 !4 !5 !6 !7 !8 !9
        #ENDIF

        #IFSAME Overloaded !3 !4 !5 !6 !7 !8 !9
          HANDLE$MESSAGE$HELP !1 !? !3 !4 !5 !6 !7 !8 !9
        #ELSE
          HANDLE$MESSAGE$HELP !1 !1_!2 !3 !4 !5 !6 !7 !8 !9
        #ENDIF

      #ENDIF       // class method
    #ENDIF
  #ENDIF  // mangling case

//  !A [] HANDLE$FOR |CI0 |VL     // handle the message
  !A [] $0454 |CI0 |VL
  #FREF OBJ$!Za$ENDPROC !a      // fref the end procedure line

  #IFDEF MANGLE_NAMES
    // MG added code here to check the parameter count.
    #IFDEF !1_!2_OVERLOADED
       // Check parameter count
      #DATA
      #DPUSH NUM_ARGUMENTS
      #DPUSH |CI!Zg
      #DPUSH !?

      #IFSAME !1 Get
        #DPUSH |CI1
      #ELSE
        #IFSAME !1 MSG
          #DPUSH |CI2
        #ELSE
          #IFSAME !1 Set
            #DPUSH |CI3
          #ENDIF
        #ENDIF
      #ENDIF
      !A [] $0467 |CI0 |VL
      #FORBID  NUM_ARGUMENTS  300 "NUM_ARGUMENTS was used in an overloaded method"
    #ENDIF
  #ENDIF
  #SET ZG$ 0                    // starting argument number for locals

  // JJT - changed in 9.1. This used to occur when the first local was created. Since this is executed at runtime
  // this created a situation where the first local might be in a block that is not executed. When moved to here
  // the local init command is always executed. We still strongly discourage the declartion of variables anywhere
  // accept the top of a method block. This simply fixes and unintended side-effect of our implementation.
  //!A [] LOCAL$ARGUMENT |CI0  // Create the command to save the local count,
  !A [] $0456 |CI0
  #FREF OBJ$!Za$LNUM !a       // and tell flex to update it later.

#ENDCOMMAND

#ELSE
  #IF (!@ >= 120)

//=========================================================================================================================================================================================================
//*********************************************************************************************************************************************************************************************************
// This is the custom message command for VDF 12-14
//*********************************************************************************************************************************************************************************************************
//=========================================================================================================================================================================================================

#COMMAND THRIFTLY$MESSAGE RGOBL#

  #IFDEF UI.EXISTS
  #ELSE
    USE UI
  #ENDIF

  // If the meta attribute Published is true, we handle special case for webapps.
  // note I am not checking for the Mangle_names ifdef - I just assume it's true (hasn't been unset for many versions).
  #IFMATTR Published True  // This is true if the Published attribute is active and its value is true
    // method must be an object method and not For, global or overloaded
    #IFMATTR AuthMethod True
      #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT "The AuthMethod cannot also be a Published method"
    #ENDIF

    #IFSAME !3 Global for Overloaded // any of these are not allowed. Note that DESKTOP is already converted to For cDesktop at this point
      #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT "The Publish meta tag cannot be used with GLOBAL, DESKTOP, FOR, or OVERLOADED methods."
    #ELSE
      #IF (!b = 1)   // the only valid place for this is within a method within an object.
        #IFMATTR Secured True
            MESSAGE$ADDRESS !1_!2  // create id symbol for this message. We do this to avoid fowward reference error in registerInterface
            #SPUSH
            #PUBLISH  //  This creates the Send RegisterInterface line and puts the result in !$, based on the original source line which is expected to be something like Function Foo Integer iArg...
            !$ OLEEVO_METHOD_DEFAULT      //  This would then actually call Send RegisterInterface
            #REM !$
            #SPOP
        #ELSE
          #IFMATTR Secured False
            MESSAGE$ADDRESS !1_!2  // create id symbol for this message. We do this to avoid fowward reference error in registerInterface
            #SPUSH
            #PUBLISH  //  This creates the Send RegisterInterface line and puts the result in !$, based on the original source line which is expected to be something like Function Foo Integer iArg...
            !$ OLEEVO_METHOD_UNSECURED      //  This would then actually call Send RegisterInterface
            #REM !$
            #SPOP
          #ELSE
            #IFMATTR LoginMethod True
              MESSAGE$ADDRESS !1_!2  // create id symbol for this message. We do this to avoid fowward reference error in registerInterface
              #SPUSH
              #PUBLISH  //  This creates the Send RegisterInterface line and puts the result in !$, based on the original source line which is expected to be something like Function Foo Integer iArg...
              !$ OLEEVO_METHOD_LOGIN      //  This would then actually call Send RegisterInterface
              #REM !$
              #SPOP
            #ELSE
              MESSAGE$ADDRESS !1_!2  // create id symbol for this message. We do this to avoid fowward reference error in registerInterface
              #SPUSH
              #PUBLISH  //  This creates the Send RegisterInterface line and puts the result in !$, based on the original source line which is expected to be something like Function Foo Integer iArg...
              !$ (IF(pbDefaultSecured(Self), OLEEVO_METHOD_DEFAULT, OLEEVO_METHOD_UNSECURED))      //  This would then actually call Send RegisterInterface
              #REM !$
              #SPOP
            #ENDIF
          #ENDIF
        #ENDIF
      #ELSE
        #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT "The Publish meta tag can only be used within methods defined directly inside of objects."
      #ENDIF
    #ENDIF
  #ENDIF

  #IFMATTR LoginMethod True  // This is true if the AuthMethod attribute is active and its value is true
    #IFMATTR AuthMethod True
      #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT "The Login method cannot also be an Auth method"
    #ENDIF
    #IFMATTR Published True
    #ELSE
      // method must be an object method and not For, global or overloaded
      #IFSAME !3 Global for Overloaded // any of these are not allowed. Note that DESKTOP is already converted to For cDesktop at this point
        #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT "The LoginMethod meta tag cannot be used with GLOBAL, DESKTOP, FOR, or OVERLOADED methods."
      #ELSE
        #IF (!b = 1)   // the only valid place for this is within a method within an object.
          MESSAGE$ADDRESS !1_!2  // create id symbol for this message. We do this to avoid fowward reference error in registerInterface
          #SPUSH
          #PUBLISH  //  This creates the Send RegisterInterface line and puts the result in !$, based on the original source line which is expected to be something like Function Foo Integer iArg...
          !$ OLEEVO_METHOD_LOGIN //  This would then actually call Send RegisterInterface
          #REM !$
          #SPOP
        #ELSE
          #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT "The LoginMethod meta tag can only be used on methods defined directly inside of objects."
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF

  #IFMATTR AuthMethod True  // This is true if the AuthMethod attribute is active and its value is true
    #IFMATTR Published True
      #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT "The Auth method cannot also be a Published method"
    #ENDIF
    #IFMATTR LoginMethod True
      #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT "The Auth method cannot also be a Login method"
    #ENDIF

    // method must be an object method and not For, global or overloaded
    #IFSAME !3 Global for Overloaded // any of these are not allowed. Note that DESKTOP is already converted to For cDesktop at this point
      #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT "The AuthMethod meta tag cannot be used with GLOBAL, DESKTOP, FOR, or OVERLOADED methods."
    #ELSE
      #IF (!b = 1)   // the only valid place for this is within a method within an object.
        MESSAGE$ADDRESS !1_!2  // create id symbol for this message. We do this to avoid fowward reference error in registerInterface
        #SPUSH
        #PUBLISH  //  This creates the Send RegisterInterface line and puts the result in !$, based on the original source line which is expected to be something like Function Foo Integer iArg...
        !$ OLEEVO_METHOD_AUTH //  This would then actually call Send RegisterInterface
        #REM !$
        #SPOP
      #ELSE
        #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT "The AuthMethod meta tag can only be used on methods defined directly inside of objects."
      #ENDIF
    #ENDIF
  #ENDIF


  // procedure construct_object only allowed in class
  #IF (!b & 1) // if in object
    #IFDEF MANGLE_NAMES
      #IFSAME !1 MSG
        #IFSAME !2 CONSTRUCT_OBJECT
          #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT Construct_object .not. allowed in objects
        #ENDIF
      #ENDIF
    #ELSE
      #IFSAME !1 MSG_CONSTRUCT_OBJECT
        #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT Construct_object .not. allowed in objects
      #ENDIF
    #ENDIF
  #ENDIF

  // not allowed to nest methods
  // Check flag to determine whether we are already in a method.
  #IF (!b & 4)
    #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT Procedures and Functions may .not. be nested.
  #ELSE
    // non global methods are not allowed class child-objects

    #IFNDEF MANGLE_NAMES

      #IFSAME !2 GLOBAL
      #ELSE
        #IF ((!b & 3)=3) // if in class object
          #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT Methods .not. allowed in class child-objects
        #ENDIF
      #ENDIF

    #ELSE

      #IFSAME !3 GLOBAL
      #ELSE
        #IF ((!b & 3)=3) // if in class object
          #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT Methods .not. allowed in class child-objects
        #ENDIF
      #ENDIF

    #ENDIF
  #ENDIF

  // Give error if the stack symbol NUM_ARGUMENTS is defined.
  #CHECK NUM_ARGUMENTS _T

  //
  #SET ZN$ !n     // static nesting level
  #SET ZM$ 0      // # objects in method
  #PUSH !Zg
  #PUSH !Za
  #SET ZA$ !a
  #PUSH !Zu
  #DATA
  #STKSYM                      // forget all old stack symbols
  #SET B$ (!b | 4)             // set flag to in_procedure

  // This was changed to allow us to prohibit arguments with num_arguments inside the scope of a function.
  #REPLACE NUM_ARGUMENTS |SI0  // define the arg count

  #IFDEF MANGLE_NAMES
    #SREP __@INSIDE_FUNCTION@__   |CI1   // lets other commands check that they are inside a function scope.
  #ENDIF

  #IFNDEF MANGLE_NAMES


  #ELSE

  //  This is the mangling code.

    #IFSAME !3 GLOBAL
      #DPUSH |CI0         // No message
      #DPUSH |CI0         // for no class
      // Check if overloaded symbol is already defined.
      #IFSC OVERLOADED !4 !5 !6 !7 !8 !9
        #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION Global functions/procedures cannot be overloaded
      #ELSE
        #IFDEF !1_!2_OVERLOADED
          #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION This Method Was Previously Defined As Overloaded
        #ELSE
          #IFDEF !1_!2
            #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION Global method !1 !2 Already Defined
          #ELSE
            #SET ZG$ (0-!a-2)   // make it negative to distuinguish it
            #REPLACE !1_!2 |CI!Zg
          #ENDIF
        #ENDIF
      #ENDIF
      CHECK$METHOD$ARGUMENT$LIST !4 !5 !6 !7 !8 !9
      #IF (!0>1)          // do we have arguments?
        #SET ZG$ 1        // starting argument number
        DEFINE_ARGUMENTS !4 !5 !6 !7 !8 !9
      #ENDIF

      HANDLE$MESSAGE$HELP !1 !1_!2 !3 !4 !5 !6 !7 !8 !9

    #ELSE  // not global functions

      // make sure message is not already defined as a global
      #IFDEF !1_!2
        #IF (!1_!2<0)  // if defined as a global already, we have an error
          #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION !1 !2 already defined as a Global method
        #ENDIF
      #ENDIF

      // Mangling case & Using FOR
      #IFSAME !3 FOR          // are we explicit about the class?

        #IFSC OVERLOADED !5 !6 !7 !8 !9
          #IFDEF !1_!2
            #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION This Method Was Previously Defined As non-overloaded
          #ELSE
            // Mangle name of method.
            #MARG !1_!2 !5 !6 !7 !8 !9
            // Also lock name without parameters and sugar.
            #IFNDEF !1_!2_OVERLOADED
              #REPLACE !1_!2_OVERLOADED  |CI1
            #ENDIF
            MESSAGE$ADDRESS !?         // create id symbol for this message
            #DPUSH !?
          #ENDIF
        #ELSE   // FOR class, but not an overloaded function.

          #IFDEF !1_!2_OVERLOADED
            #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION This Method Was Previously Defined As Overloaded
          #ELSE
            MESSAGE$ADDRESS  !1_!2  // create id symbol for this message
            #DPUSH !1_!2
          #ENDIF

        #ENDIF

        #IFDEF !4
          #IFSAME !4 DESKTOP
            #IFDEF IS$WINDOWS
              #DPUSH U_cObject  // Message for the desktop class
            #ELSE
              #DPUSH U_DESKTOP  // Message for the desktop class
            #ENDIF
          #ELSE
            #DPUSH !4         // Message for the named class
          #ENDIF
        #ELSE
          #CHECK U_!4 _RSDNU   // Check the class to see if it exists.
          #DPUSH U_!4         // Message for the named class
        #ENDIF

        CHECK$METHOD$ARGUMENT$LIST !5 !6 !7 !8 !9

        #IF (!0>3)
          #SET ZG$ 1                  // starting argument number
          DEFINE_ARGUMENTS !5 !6 !7 !8 !9
        #ENDIF

        #IFSC OVERLOADED !4 !5 !6 !7 !8 !9              // Non global
          HANDLE$MESSAGE$HELP !1 !? !5 !6 !7 !8 !9
        #ELSE
          HANDLE$MESSAGE$HELP !1 !1_!2 !5 !6 !7 !8 !9
        #ENDIF

      #ELSE // Method is declared in a class or in an object
        #IF (!b & 2)              // obj_flag == in_class?
        #ELSE
          #IF (!b & 1)            // in_object, instance method
            !A [] CLONE$CLASS     // if in object, clone the class
          #ENDIF
        #ENDIF

        #IFSC OVERLOADED !3 !4 !5 !6 !7 !8 !9
          #IFDEF !1_!2
            #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION This Method Was Previously Defined As non-overloaded
          #ELSE
            #MARG !1_!2 !3 !4 !5 !6 !7 !8 !9
            MESSAGE$ADDRESS !?
            #IFNDEF !1_!2_OVERLOADED
              #REPLACE !1_!2_OVERLOADED  |CI1
            #ENDIF
            #DPUSH !?               // the message
          #ENDIF
        #ELSE
          // a non-overlaoded message
          #IFDEF !1_!2_OVERLOADED
            #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION This Method Was Previously Defined As Overloaded
          #ELSE
            MESSAGE$ADDRESS  !1_!2  // create id symbol for this message
            #DPUSH !1_!2
          #ENDIF
        #ENDIF

        // push the proper destination for the message
        #IF (!b & 2)             // obj_flag == in_class?
          #DPUSH U_!$            // handle msg for "current class"
        #ELSE
          #IF (!b & 1)           // in_object, instance method
            #DPUSH |CI0          // handle for objects class
          #ELSE                  // Message is out on desktop and not identfied w/ FOR Xxxxx
            #IFDEF IS$WINDOWS      // 8.3: if windows we are going to place this on the cDesktop object
                                   // which will allow all objects to delegate to it, which is probably
                                   // what people expect. Prior to 8.3, it create a "for desktop" so all classes/objects
                                   // immediately understood this. This represents a change in behavior.
              #REM Ambiguous methods on .DESKTOP. are .not. recommended (Obsolete technique)
              // this is not a real error but we can use this to look at ambiguous desktop methods to make make sure
              // that they are being used in the proper 8.3 style. This warning is controlled by the method
              // Compiler_desktop_method_warnings ON|OFF (OFF is default)
              #IF (!Zl & 4)
                 #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION Ambiguous method on .Desktop. Should be "Desktop" or "Global" or moved.
              #ENDIF
              #DPUSH U_cObject     // Message for the desktop (UI_OBJECT) class. Not advised for VDF after 8.2
            #ELSE
              #DPUSH U_DESKTOP     // Message for the desktop (UI_OBJECT) class. Not advised for VDF after 8.2
            #ENDIF
          #ENDIF   // stand alone message that gets defined as U_DESKTOP
        #ENDIF     // end of else of object method
        CHECK$METHOD$ARGUMENT$LIST !3 !4 !5 !6 !7 !8 !9
        #IF (!0>1)                // do we have arguments?
          #SET ZG$ 1                  // starting argument number
          DEFINE_ARGUMENTS !3 !4 !5 !6 !7 !8 !9
        #ENDIF

        #IFSC OVERLOADED !3 !4 !5 !6 !7 !8 !9
          HANDLE$MESSAGE$HELP !1 !? !3 !4 !5 !6 !7 !8 !9
        #ELSE
          HANDLE$MESSAGE$HELP !1 !1_!2 !3 !4 !5 !6 !7 !8 !9
        #ENDIF

      #ENDIF       // class method
    #ENDIF
  #ENDIF  // mangling case

//  !A [] HANDLE$FOR |CI0 |VL     // handle the message
  !A [] $0454 |CI0 |VL
  #FREF OBJ$!Za$ENDPROC !a      // fref the end procedure line

  #IFDEF MANGLE_NAMES
    // MG added code here to check the parameter count.
    #IFDEF !1_!2_OVERLOADED
       // Check parameter count
      #DATA
      #DPUSH NUM_ARGUMENTS
      #DPUSH |CI!Zg
      #DPUSH !?

      #IFSAME !1 GET
        #DPUSH |CI1
      #ELSE
        #IFSAME !1 MSG
          #DPUSH |CI2
        #ELSE
          #IFSAME !1 SET
            #DPUSH |CI3
          #ENDIF
        #ENDIF
      #ENDIF
      !A [] $0467 |CI0 |VL
      #FORBID  NUM_ARGUMENTS  300 "NUM_ARGUMENTS was used in an overloaded method"
    #ENDIF
  #ENDIF
  #SET ZG$ 0                    // starting argument number for locals

  // JJT - changed in 9.1. This used to occur when the first local was created. Since this is executed at runtime
  // this created a situation where the first local might be in a block that is not executed. When moved to here
  // the local init command is always executed. We still strongly discourage the declartion of variables anywhere
  // accept the top of a method block. This simply fixes and unintended side-effect of our implementation.
  //!A [] LOCAL$ARGUMENT |CI0  // Create the command to save the local count,
  !A [] $0456 |CI0
  #FREF OBJ$!Za$LNUM !a       // and tell flex to update it later.

#ENDCOMMAND

  #ELSE 
      #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT "Thriftly will only work with Dataflex 12.0 and newer"
  #ENDIF
#ENDIF