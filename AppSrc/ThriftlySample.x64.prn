Compiling Program: C:\Users\marce\OneDrive\Documentos\Thriftly Developer\Dataflex\Library_x64\AppSrc\ThriftlySample.src
Memory Available: 36811694080
1>Use Windows.pkg
Using pre-compiled package WINDOWS.PKG
Including file: windows.x64.pkd    (C:\Program Files\DataFlex 26.0\Pkg\windows.x64.pkd)
8304>Use cApplication.pkg
Including file: cApplication.pkg    (C:\Program Files\DataFlex 26.0\Pkg\cApplication.pkg)
8304>>>Use Windows.pkg
8304>>>
8304>>>Use LanguageText.pkg
8304>>>Use WinUser.pkg
8304>>>Use WinShell.pkg
8304>>>Use cWorkspace.pkg
Including file: cWorkspace.pkg    (C:\Program Files\DataFlex 26.0\Pkg\cWorkspace.pkg)
8304>>>>>Use VdfBase.pkg
8304>>>>>Use tWinStructs.pkg
8304>>>>>Use LanguageText.pkg
8304>>>>>Use WinShell.pkg // Shell API functions
8304>>>>>Use seq_chnl.pkg
Including file: seq_chnl.pkg    (C:\Program Files\DataFlex 26.0\Pkg\seq_chnl.pkg)
8304>>>>>>>Use LanguageText.pkg
8304>>>>>>>Use VDFBase.pkg
Including file: errornum.inc    (C:\Program Files\DataFlex 26.0\Pkg\errornum.inc)
8304>>>>>>>>    
8304>>>>>>>>
8304>>>>>>>>
8304>>>>>>>
8304>>>>>>>Define DF_SEQ_CHANNEL_NOT_AVAILABLE for -2
8304>>>>>>>Define DF_SEQ_CHANNEL_ERROR         for -1
8304>>>>>>>Define DF_SEQ_CHANNEL_MIN           for 0
8304>>>>>>>Define DF_SEQ_CHANNEL_MAX           for 9
8304>>>>>>>Define DF_SEQ_START_CHANNEL         for 2 // leave 0 and 1 til last
8304>>>>>>>// so that programs that use direct_input/output
8304>>>>>>>// w/o specifying a channel will work.
8304>>>>>>>Enum_List
8304>>>>>>>    Define DF_SEQ_CHANNEL_MODE_CLOSED
8304>>>>>>>    Define DF_SEQ_CHANNEL_MODE_OPEN
8304>>>>>>>    Define DF_SEQ_CHANNEL_MODE_OUTPUT
8304>>>>>>>    Define DF_SEQ_CHANNEL_MODE_INPUT
8304>>>>>>>End_Enum_List
8304>>>>>>>
8304>>>>>>>Enum_List
8304>>>>>>>    Define DF_SEQ_CHANNEL_ERROR_MODE_NONE
8304>>>>>>>    Define DF_SEQ_CHANNEL_ERROR_MODE_ALL
8304>>>>>>>End_Enum_List
8304>>>>>>>
8304>>>>>>>Global_Variable Integer Seq$Channel$Error$Mode
8304>>>>>>>
8304>>>>>>>Procedure Set Seq_Channel_Error_Mode Global Integer iMode
8306>>>>>>>    Move iMode to Seq$Channel$Error$Mode
8307>>>>>>>End_Procedure
8308>>>>>>>
8308>>>>>>>Function Seq_Channel_Error_Mode Global Returns Integer
8310>>>>>>>    Function_Return Seq$Channel$Error$Mode
8311>>>>>>>End_Function
8312>>>>>>>
8312>>>>>>>Global_Variable Integer[DF_SEQ_CHANNEL_MAX] giSeqChannelList
8312>>>>>>>// initialize array
8312>>>>>>>For WindowIndex from 0 to (DF_SEQ_CHANNEL_MAX-1)
8318>>>>>>>>
8318>>>>>>>    Move 0 to giSeqChannelList[WindowIndex]
8319>>>>>>>Loop
8320>>>>>>>>
8320>>>>>>>
8320>>>>>>>Set Seq_Channel_Error_Mode to DF_SEQ_CHANNEL_ERROR_MODE_ALL
8321>>>>>>>
8321>>>>>>>Function Seq_Channel_Mode Global Integer iChannel Returns Integer
8323>>>>>>>    Function_Return giSeqChannelList[iChannel]
8324>>>>>>>End_Function
8325>>>>>>>
8325>>>>>>>Procedure Set Seq_Channel_Mode Global Integer iChannel Integer iMode
8327>>>>>>>    Move iMode to giSeqChannelList[iChannel]
8328>>>>>>>End_Procedure
8329>>>>>>>
8329>>>>>>>Function Seq_New_Channel Global Returns Integer
8331>>>>>>>    Integer iObject iChannel
8331>>>>>>>    
8331>>>>>>>    Move DF_SEQ_START_CHANNEL to iChannel
8332>>>>>>>    
8332>>>>>>>    While (iChannel < DF_SEQ_CHANNEL_MAX)
8336>>>>>>>        If (Seq_Channel_Mode(iChannel) = DF_SEQ_CHANNEL_MODE_CLOSED) Begin
8338>>>>>>>            Set Seq_Channel_Mode iChannel to DF_SEQ_CHANNEL_MODE_OPEN
8339>>>>>>>            Function_Return iChannel
8340>>>>>>>        End
8340>>>>>>>>
8340>>>>>>>        
8340>>>>>>>        Increment iChannel
8341>>>>>>>    Loop
8342>>>>>>>>
8342>>>>>>>    
8342>>>>>>>    // wrap back to beginning
8342>>>>>>>    Move 0 to iChannel
8343>>>>>>>    
8343>>>>>>>    While (iChannel < DF_SEQ_START_CHANNEL)
8347>>>>>>>        If (Seq_Channel_Mode(iChannel) = DF_SEQ_CHANNEL_MODE_CLOSED) Begin
8349>>>>>>>            Set Seq_Channel_Mode iChannel to DF_SEQ_CHANNEL_MODE_OPEN
8350>>>>>>>            Function_Return iChannel
8351>>>>>>>        End
8351>>>>>>>>
8351>>>>>>>        
8351>>>>>>>        Increment iChannel
8352>>>>>>>    Loop
8353>>>>>>>>
8353>>>>>>>    
8353>>>>>>>    Function_Return DF_SEQ_CHANNEL_NOT_AVAILABLE
8354>>>>>>>End_Function
8355>>>>>>>
8355>>>>>>>Procedure Seq_Release_Channel Global Integer iChannel
8357>>>>>>>    If ((iChannel >= DF_SEQ_CHANNEL_MIN) and (iChannel <= DF_SEQ_CHANNEL_MAX)) Begin
8359>>>>>>>        Set Seq_Channel_Mode iChannel to DF_SEQ_CHANNEL_MODE_CLOSED
8360>>>>>>>    End
8360>>>>>>>>
8360>>>>>>>End_Procedure
8361>>>>>>>
8361>>>>>>>Function Seq_Open_Input_Channel Global String sChannel Returns Integer
8363>>>>>>>    Integer iChannel
8363>>>>>>>    
8363>>>>>>>    Move (Seq_New_Channel()) to iChannel
8364>>>>>>>    
8364>>>>>>>    If (iChannel <= DF_SEQ_CHANNEL_ERROR) Begin
8366>>>>>>>        If (Seq_Channel_Error_Mode() = DF_SEQ_CHANNEL_ERROR_MODE_ALL) Begin
8368>>>>>>>            Error DFERR_CANT_OPEN_INPUT_FILE (sChannel + ":" *C_$NoOpenChannels)
8369>>>>>>>>
8369>>>>>>>        End
8369>>>>>>>>
8369>>>>>>>        Function_Return iChannel
8370>>>>>>>    End
8370>>>>>>>>
8370>>>>>>>    
8370>>>>>>>    Move False to Err
8371>>>>>>>    Direct_Input channel iChannel sChannel
8373>>>>>>>    
8373>>>>>>>    If (Err) Begin
8375>>>>>>>        Send Seq_Release_Channel iChannel
8376>>>>>>>        Function_Return DF_SEQ_CHANNEL_ERROR
8377>>>>>>>    End
8377>>>>>>>>
8377>>>>>>>    
8377>>>>>>>    Set Seq_Channel_Mode iChannel to DF_SEQ_CHANNEL_MODE_INPUT
8378>>>>>>>    
8378>>>>>>>    Function_Return iChannel
8379>>>>>>>End_Function
8380>>>>>>>
8380>>>>>>>Function Seq_Open_Output_Channel Global String sChannel Returns Integer
8382>>>>>>>    Integer iChannel
8382>>>>>>>    
8382>>>>>>>    Move (Seq_New_Channel()) to iChannel
8383>>>>>>>    
8383>>>>>>>    If (iChannel <= DF_SEQ_CHANNEL_ERROR) Begin
8385>>>>>>>        If (Seq_Channel_Error_Mode() = DF_SEQ_CHANNEL_ERROR_MODE_ALL) Begin
8387>>>>>>>            Error DFERR_CANT_OPEN_OUTPUT_FILE (sChannel + ":" *C_$ChannelNotAvailable)
8388>>>>>>>>
8388>>>>>>>            Move DF_SEQ_CHANNEL_ERROR to iChannel
8389>>>>>>>        End
8389>>>>>>>>
8389>>>>>>>        
8389>>>>>>>        Function_Return iChannel
8390>>>>>>>    End
8390>>>>>>>>
8390>>>>>>>    
8390>>>>>>>    Move False to Err
8391>>>>>>>    Direct_Output channel iChannel sChannel
8393>>>>>>>    
8393>>>>>>>    If (Err) Begin
8395>>>>>>>        Send Seq_Release_Channel iChannel
8396>>>>>>>        Function_Return DF_SEQ_CHANNEL_ERROR
8397>>>>>>>    End
8397>>>>>>>>
8397>>>>>>>    
8397>>>>>>>    Set Seq_Channel_Mode iChannel to DF_SEQ_CHANNEL_MODE_OUTPUT
8398>>>>>>>    
8398>>>>>>>    Function_Return iChannel
8399>>>>>>>End_Function
8400>>>>>>>
8400>>>>>>>Function Seq_Append_Output_Channel Global String sChannel Returns Integer
8402>>>>>>>    Integer iChannel
8402>>>>>>>    
8402>>>>>>>    Move (Seq_New_Channel()) to iChannel
8403>>>>>>>    
8403>>>>>>>    If (iChannel <= DF_SEQ_CHANNEL_ERROR) Begin
8405>>>>>>>        If (Seq_Channel_Error_Mode() = DF_SEQ_CHANNEL_ERROR_MODE_ALL) Begin
8407>>>>>>>            Error DFERR_CANT_OPEN_OUTPUT_FILE (sChannel + ":" *C_$ChannelNotAvailable)
8408>>>>>>>>
8408>>>>>>>            Move DF_SEQ_CHANNEL_ERROR to iChannel
8409>>>>>>>        End
8409>>>>>>>>
8409>>>>>>>        
8409>>>>>>>        Function_Return iChannel
8410>>>>>>>    End
8410>>>>>>>>
8410>>>>>>>    
8410>>>>>>>    Move False to Err
8411>>>>>>>    Append_Output channel iChannel sChannel
8413>>>>>>>    
8413>>>>>>>    If (Err) Begin
8415>>>>>>>        Send Seq_Release_Channel iChannel
8416>>>>>>>        Function_Return DF_SEQ_CHANNEL_ERROR
8417>>>>>>>    End
8417>>>>>>>>
8417>>>>>>>    
8417>>>>>>>    Set Seq_Channel_Mode iChannel to DF_SEQ_CHANNEL_MODE_OUTPUT
8418>>>>>>>    
8418>>>>>>>    Function_Return iChannel
8419>>>>>>>End_Function
8420>>>>>>>
8420>>>>>>>Procedure Seq_Close_Channel Global Integer iChannel
8422>>>>>>>    Integer iMode
8422>>>>>>>    
8422>>>>>>>    If ((iChannel >= DF_SEQ_CHANNEL_MIN) and (iChannel <= DF_SEQ_CHANNEL_MAX)) Begin
8424>>>>>>>        Move (Seq_Channel_Mode(iChannel)) to iMode
8425>>>>>>>        
8425>>>>>>>        If (iMode = DF_SEQ_CHANNEL_MODE_OUTPUT) Begin
8427>>>>>>>            Close_Output channel iChannel
8429>>>>>>>        End
8429>>>>>>>>
8429>>>>>>>        Else If (iMode = DF_SEQ_CHANNEL_MODE_INPUT) Begin
8432>>>>>>>            Close_Input channel iChannel
8434>>>>>>>        End
8434>>>>>>>>
8434>>>>>>>        // If channel not open, release it! No (fatal) Error.
8434>>>>>>>        Send Seq_Release_Channel iChannel
8435>>>>>>>    End
8435>>>>>>>>
8435>>>>>>>End_Procedure
8436>>>>>Use GlobalFunctionsProcedures.pkg
8436>>>>>
8436>>>>>Register_Function IsRegistered String sWorkspace Returns Boolean
8436>>>>>Register_Function VdfSystemDfPath   Returns String
8436>>>>>Register_Function VdfSystemMakePath Returns String
8436>>>>>
8436>>>>>Enum_List
8436>>>>>    Define wsWorkspaceOpened       // WS opened ok
8436>>>>>    Define wsWorkspaceNotFound     // the named WS was not found in the global list
8436>>>>>    Define wsWorkspaceFileNotFound // the WS file was not found
8436>>>>>    Define wsDataPathEmpty         // the DataPath entry was empty
8436>>>>>    Define wsFileListEmpty         // The FileList entry was empty
8436>>>>>    Define wsFileListNotExist      // The FileList.cfg file could not be found
8436>>>>>End_Enum_List
8436>>>>>
8436>>>>>
8436>>>>>Define INVALID_HANDLE_VALUE for -1
8436>>>>>Define MAX_PATH for 260   // Symbol for maximum length of a path
8436>>>>>
8436>>>>>
8436>>>>>// Wide version
8436>>>>>External_Function winFindFirstFileW "FindFirstFileW" Kernel32.dll ;    WString wFileSpec ;    Pointer lpsWin32FindData ;    Returns Handle
8437>>>>>
8437>>>>>// Wrapper Function winFindFirstFile
8437>>>>>Function winFindFirstFile Global ;    String  sFileSpec ;    Pointer lpsWin32FindData ;    Returns Handle
8439>>>>>    
8439>>>>>    Handle  hResult
8439>>>>>    Integer iVoid iFilenameSize iAltFilenameSize
8439>>>>>    Integer iSizeOfStructWithoutStrings
8439>>>>>    String  sFileName sAlternateFileName
8439>>>>>    WString wFileName wAlternateFileName
8439>>>>>    Pointer pWFD
8439>>>>>    tWin32FindDataW tWFD
8439>>>>>    tWin32FindDataW tWFD
8439>>>>>    
8439>>>>>    // lpsWin32FindData is a pointer to a WIN32_FIND_DATAW struct, which contains pointers to UTF-8 strings.
8439>>>>>    // These string must be converted to UTF-16 and afterwards back to UTF-8.
8439>>>>>
8439>>>>>    Move (SizeOfType(tWin32FindData) - MAX_PATH - MAX_ALTPATH) to iSizeOfStructWithoutStrings
8440>>>>>    Move (AddressOf(tWFD)) to pWFD
8441>>>>>    
8441>>>>>    // Call the function
8441>>>>>    Move (winFindFirstFileW (sFileSpec, pWFD)) to hResult
8442>>>>>
8442>>>>>    // Copy the struct contents back to the incoming one.
8442>>>>>    Move (CopyMemory(lpsWin32FindData, pWFD, iSizeOfStructWithoutStrings)) to iVoid
8443>>>>>    
8443>>>>>    // But do the strings separately and convert them to UTF8
8443>>>>>    Move (PointerToWString(pWFD + iSizeOfStructWithoutStrings)) to sFileName
8444>>>>>    Move (PointerToWString(pWFD + iSizeOfStructWithoutStrings + (MAX_PATH*2))) to sAlternateFileName
8445>>>>>    
8445>>>>>    // Extend string with 0 to the maximum number of characters
8445>>>>>    If (SizeOfString(sFileName)<MAX_PATH) ;        Append sFileName (Repeat(Character(0), MAX_PATH - SizeOfString(sFileName)))
8448>>>>>    If (SizeOfString(sAlternateFileName)<MAX_ALTPATH) ;        Append sAlternateFileName (Repeat(Character(0), MAX_ALTPATH - SizeOfString(sAlternateFileName)))
8451>>>>>        
8451>>>>>    Move (MemCopy(lpsWin32FindData + iSizeOfStructWithoutStrings, AddressOf(sFileName), MAX_PATH)) to iVoid
8452>>>>>    Move (MemCopy(lpsWin32FindData + iSizeOfStructWithoutStrings + MAX_PATH, AddressOf(sAlternateFileName), MAX_ALTPATH)) to iVoid
8453>>>>>    
8453>>>>>    Function_Return hResult
8454>>>>>End_Function
8455>>>>>
8455>>>>>// When used directly, be sure to use WString types (UTF16).
8455>>>>>External_Function winFindNextFileW "FindNextFileW" Kernel32.dll ;    Handle  hFindFile ;    Pointer lpsWin32FindData ;    Returns Integer
8456>>>>>
8456>>>>>// Wrapper Function winFindNextFile
8456>>>>>Function winFindNextFile Global ;    Handle  hFindFile ;    Pointer lpsWin32FindData ;    Returns Integer
8458>>>>>    
8458>>>>>    Integer iResult iVoid iFilenameSize iAltFilenameSize
8458>>>>>    Integer iSizeOfStructWithoutStrings
8458>>>>>    String  sFileName sAlternateFileName
8458>>>>>    WString wFileName wAlternateFileName
8458>>>>>    Pointer pWFD
8458>>>>>    tWin32FindDataW tWFD
8458>>>>>    tWin32FindDataW tWFD
8458>>>>>
8458>>>>>    // lpsWin32FindData is a pointer to a WIN32_FIND_DATAW struct, which contains pointers to UTF-8 strings.
8458>>>>>    // These string must be converted to UTF-16 and afterwards back to UTF-8.
8458>>>>>
8458>>>>>    // Copy the struct to a local struct that can be modified to UTF-16.
8458>>>>>    Move (SizeOfType(tWin32FindData) - MAX_PATH - MAX_ALTPATH) to iSizeOfStructWithoutStrings
8459>>>>>    Move (AddressOf(tWFD)) to pWFD
8460>>>>>    Move (MemCopy(pWFD, lpsWin32FindData, iSizeOfStructWithoutStrings)) to iVoid
8461>>>>>    // But do the strings separately and convert them to wide strings (UTF16).
8461>>>>>    Move (PointerToString(lpsWin32FindData + iSizeOfStructWithoutStrings)) to wFileName
8462>>>>>    Move (PointerToString(lpsWin32FindData + iSizeOfStructWithoutStrings + MAX_PATH)) to wAlternateFileName
8463>>>>>    Move (MemCopy(pWFD + iSizeOfStructWithoutStrings, AddressOf(wFileName), SizeOfString(wFileName)*2)) to iVoid
8464>>>>>    Move (MemCopy(pWFD + iSizeOfStructWithoutStrings + (MAX_PATH*2), AddressOf(wAlternateFileName), SizeOfString(wAlternateFileName)*2)) to iVoid
8465>>>>>    
8465>>>>>    // Call the function
8465>>>>>    Move (winFindNextFileW (hFindFile, pWFD)) to iResult  
8466>>>>>
8466>>>>>    // Copy the struct contents back to the incoming one.
8466>>>>>    Move (CopyMemory(lpsWin32FindData, pWFD, iSizeOfStructWithoutStrings)) to iVoid
8467>>>>>    
8467>>>>>    // But do the strings separately and convert them to UTF8
8467>>>>>    Move (PointerToWString(pWFD + iSizeOfStructWithoutStrings)) to sFileName
8468>>>>>    Move (PointerToWString(pWFD + iSizeOfStructWithoutStrings + (MAX_PATH*2))) to sAlternateFileName
8469>>>>>    
8469>>>>>    // Extend string with 0 to the maximum number of characters
8469>>>>>    If (SizeOfString(sFileName)<MAX_PATH) ;        Append sFileName (Repeat(Character(0), MAX_PATH - SizeOfString(sFileName)))
8472>>>>>    If (SizeOfString(sAlternateFileName)<MAX_ALTPATH) ;        Append sAlternateFileName (Repeat(Character(0), MAX_ALTPATH - SizeOfString(sAlternateFileName)))
8475>>>>>        
8475>>>>>    Move (MemCopy(lpsWin32FindData + iSizeOfStructWithoutStrings, AddressOf(sFileName), MAX_PATH)) to iVoid
8476>>>>>    Move (MemCopy(lpsWin32FindData + iSizeOfStructWithoutStrings + MAX_PATH, AddressOf(sAlternateFileName), MAX_ALTPATH)) to iVoid
8477>>>>>    
8477>>>>>    Function_Return iResult
8478>>>>>End_Function
8479>>>>>
8479>>>>>
8479>>>>>External_Function winFindClose "FindClose" Kernel32.dll ;    Handle hOpenFile Returns Integer
8480>>>>>
8480>>>>>Function DoesFileExist Global String sFilename Returns Boolean
8482>>>>>    tWin32FindDataW Win32FindData
8482>>>>>    tWin32FindDataW Win32FindData
8482>>>>>    String sMask
8482>>>>>    Integer iVoid
8482>>>>>    Handle hFileFind
8482>>>>>    
8482>>>>>    Move (winFindFirstFileW(sFilename, AddressOf(Win32FindData))) to hFileFind
8483>>>>>    If (hFileFind <> INVALID_HANDLE_VALUE) Begin
8485>>>>>        Move (winFindClose(hFileFind)) to iVoid
8486>>>>>    End
8486>>>>>>
8486>>>>>    
8486>>>>>    Function_Return (hFileFind <> INVALID_HANDLE_VALUE)
8487>>>>>End_Function
8488>>>>>
8488>>>>>
8488>>>>>Use cIniFile.pkg
Including file: cIniFile.pkg    (C:\Program Files\DataFlex 26.0\Pkg\cIniFile.pkg)
8488>>>>>>>Use Dll.pkg
8488>>>>>>>Use errornum.inc
8488>>>>>>>Use LanguageText.pkg
8488>>>>>>>Use GlobalFunctionsProcedures.pkg
8488>>>>>>>Use seq_chnl.pkg
8488>>>>>>>Use CharTranslate.pkg
8488>>>>>>>Use cCharTranslate.pkg
Including file: cCharTranslate.pkg    (C:\Program Files\DataFlex 26.0\Pkg\cCharTranslate.pkg)
8488>>>>>>>>>Use Variant.pkg
Including file: Variant.pkg    (C:\Program Files\DataFlex 26.0\Pkg\Variant.pkg)
8488>>>>>>>>>>>Use ui
8488>>>>>>>>>>>Use errornum.inc
8488>>>>>>>>>>>
8488>>>>>>>>>>>// OLE VARENUM usage keys (from wtypes.h)
8488>>>>>>>>>>>
8488>>>>>>>>>>>
8488>>>>>>>>>>>External_Function SysAllocString "SysAllocString" oleaut32.dll Pointer pStr Returns Pointer
8489>>>>>>>>>>>External_Function SysStringLen "SysStringLen" oleaut32.dll Pointer vStr Returns Integer
8490>>>>>>>>>>>
8490>>>>>>>>>>>//  Returns the variant type
8490>>>>>>>>>>>Function VariantType Global Variant vVal Returns Integer
8492>>>>>>>>>>>    Function_Return (DeRefW(AddressOf(vVal),0))
8493>>>>>>>>>>>End_Function
8494>>>>>>>>>>>
8494>>>>>>>>>>>
8494>>>>>>>>>>>// Returns the character length of the variant string. 
8494>>>>>>>>>>>Function VariantStringLength Global Variant bStr Returns Integer
8496>>>>>>>>>>>    Integer iLen iType
8496>>>>>>>>>>>
8496>>>>>>>>>>>    Move (VariantType(bStr)) to iType
8497>>>>>>>>>>>    If (iType=OLE_VT_Empty) Begin
8499>>>>>>>>>>>        Function_Return 0
8500>>>>>>>>>>>    End
8500>>>>>>>>>>>>
8500>>>>>>>>>>>    If (iType<>OLE_VT_Bstr) Begin
8502>>>>>>>>>>>        Error DFERR_BAD_TYPE_EXPRESSION "In variable is not a variant bstr"
8503>>>>>>>>>>>>
8503>>>>>>>>>>>        Function_Return 0
8504>>>>>>>>>>>    End
8504>>>>>>>>>>>>
8504>>>>>>>>>>>    Move (SysStringLen(DeRefPtr(AddressOf(bStr),8))) to iLen
8505>>>>>>>>>>>    Function_Return iLen
8506>>>>>>>>>>>End_Function
8507>>>>>>>>>>>
8507>>>>>>>>>>>
8507>>>>>>>>>>>// returns true if char string in the buffer can fit into a string.
8507>>>>>>>>>>>// Changed this to always return True, because the Max_Argument_Size limitation has been removed.
8507>>>>>>>>>>>Function ValidStringBufferLength Global Pointer pData Returns Boolean
8509>>>>>>>>>>>    Function_Return True
8510>>>>>>>>>>>End_Function
8511>>>>>>>>>>>
8511>>>>>>>>>>>
8511>>>>>>>>>Use CharTranslate.pkg
8511>>>>>>>>>Use GlobalFunctionsProcedures.pkg
8511>>>>>>>>>
8511>>>>>>>>>// special for UTF16, which is really not a code page at all
8511>>>>>>>>>Define CP_UTF16 for -1
8511>>>>>>>>>
8511>>>>>>>>>Class cCharTranslate is a cObject
8512>>>>>>>>>    
8512>>>>>>>>>    
8512>>>>>>>>>    // UTF16 functions that allow you to move between a char (UTF8, ANS, OEM) and a UTF16 buffer
8512>>>>>>>>>    
8512>>>>>>>>>    // converts from buffer of encoded eCharType to a new UTF16 buffer
8512>>>>>>>>>    // note: Utf16FromBuffer with eCharType of CP_OEM can replace OEMToUTF16Buffer
8512>>>>>>>>>    Function Utf16FromBuffer  Pointer pMultiCharBuffer Integer eCharType Integer ByRef iLen Returns Pointer
8514>>>>>>>>>        Pointer pWideBuf
8514>>>>>>>>>        Integer iWideBufLen iStrLen
8514>>>>>>>>>        Move 0 to pWideBuf
8515>>>>>>>>>        Move 0 to iLen
8516>>>>>>>>>        If (pMultiCharBuffer) Begin
8518>>>>>>>>>            Move (CStringSize(pMultiCharBuffer)) to iStrLen
8519>>>>>>>>>            If (iStrLen) Begin
8521>>>>>>>>>                Move (MultiToWideBuffer(eCharType,pMultiCharBuffer, iStrLen, AddressOf(pWideBuf))) to iLen
8522>>>>>>>>>                If (iLen=0) Begin
8524>>>>>>>>>                    Function_Return 0
8525>>>>>>>>>                End
8525>>>>>>>>>>
8525>>>>>>>>>            End
8525>>>>>>>>>>
8525>>>>>>>>>        End
8525>>>>>>>>>>
8525>>>>>>>>>        Function_Return pWideBuf
8526>>>>>>>>>    End_Function
8527>>>>>>>>>    
8527>>>>>>>>>    Function Utf16FromStr String sValue Integer eCharType Integer ByRef iLen Returns Pointer
8529>>>>>>>>>        Pointer pValue
8529>>>>>>>>>        Get Utf16FromBuffer (AddressOf(sValue)) eCharType (&iLen) to pValue
8530>>>>>>>>>        Function_Return pValue
8531>>>>>>>>>    End_Function
8532>>>>>>>>>    
8532>>>>>>>>>    // converts from utf16 buffer to a new buffer of encoded eCharType
8532>>>>>>>>>    // note: Utf16ToBuffer with eCharType of CP_OEM can replace UTFtoOEMBuffer
8532>>>>>>>>>    Function Utf16ToBuffer Pointer pWideBuf Integer eCharType Integer iLen Returns Pointer
8534>>>>>>>>>        Pointer pRetBuf
8534>>>>>>>>>        Integer iRetBufLen
8534>>>>>>>>>        Move 0 to pRetBuf
8535>>>>>>>>>        If (pWideBuf and iLen) Begin
8537>>>>>>>>>            Move (WideToMultiBuffer(eCharType,pWideBuf,iLen,AddressOf(pRetBuf))) to iRetBufLen
8538>>>>>>>>>            If (iRetBufLen=0) Begin
8540>>>>>>>>>                Function_Return 0
8541>>>>>>>>>            End
8541>>>>>>>>>>
8541>>>>>>>>>        End
8541>>>>>>>>>>
8541>>>>>>>>>        Function_Return pRetBuf
8542>>>>>>>>>    End_Function
8543>>>>>>>>>    
8543>>>>>>>>>    Function Utf16ToStr Pointer pWideBuf Integer eCharType Integer iLen Returns String
8545>>>>>>>>>        String sValue
8545>>>>>>>>>        Pointer pValue
8545>>>>>>>>>        Boolean bOk
8545>>>>>>>>>        Get Utf16ToBuffer pWideBuf eCharType iLen to pValue
8546>>>>>>>>>        If (not(ValidStringBufferLength(pValue))) Begin
8548>>>>>>>>>            Error DFERR_PROGRAM "Buffer exceeds maximum string size"
8549>>>>>>>>>>
8549>>>>>>>>>        End
8549>>>>>>>>>>
8549>>>>>>>>>        Move (PointerToString(pValue)) to sValue
8550>>>>>>>>>        Move (Free(pValue)) to bOk
8551>>>>>>>>>        Function_Return sValue
8552>>>>>>>>>    End_Function
8553>>>>>>>>>    
8553>>>>>>>>>    
8553>>>>>>>>>    // UTF8 functions that allow you to move between a UTF8 buffer and other single char OEM/ASNI
8553>>>>>>>>>    
8553>>>>>>>>>    Function Utf8FromBuffer Pointer pMultiCharBuffer Integer eCharType Returns Pointer
8555>>>>>>>>>        Pointer pWideBuf
8555>>>>>>>>>        Pointer pUtf8Buf
8555>>>>>>>>>        Integer iLen iMultiBufLen
8555>>>>>>>>>        Boolean bOk
8555>>>>>>>>>        Get Utf16FromBuffer pMultiCharBuffer eCharType (&iLen) to pWideBuf
8556>>>>>>>>>        If (iLen=0) Begin
8558>>>>>>>>>            Function_Return 0
8559>>>>>>>>>        End
8559>>>>>>>>>>
8559>>>>>>>>>        Move 0 to pUtf8Buf
8560>>>>>>>>>        Move (WideToMultiBuffer(CP_UTF8,pWideBuf,iLen,AddressOf(pUtf8Buf))) to iMultiBufLen
8561>>>>>>>>>        Move (Free(pWideBuf)) to bOk
8562>>>>>>>>>        Function_Return pUtf8Buf
8563>>>>>>>>>    End_Function
8564>>>>>>>>>    
8564>>>>>>>>>    Function Utf8FromStr String sValue Integer eCharType Returns Pointer
8566>>>>>>>>>        Pointer pValue
8566>>>>>>>>>        Get Utf8FromBuffer (AddressOf(sValue)) eCharType to pValue
8567>>>>>>>>>        Function_Return pValue
8568>>>>>>>>>    End_Function
8569>>>>>>>>>    
8569>>>>>>>>>    Function Utf8ToBuffer Pointer pMultiCharBuffer Integer eCharType Returns Pointer
8571>>>>>>>>>        Pointer pRetBuf pWideBuf
8571>>>>>>>>>        Integer iWideBufLen
8571>>>>>>>>>        Integer iRetBufLen
8571>>>>>>>>>        Boolean bOk
8571>>>>>>>>>        Get Utf16FromBuffer pMultiCharBuffer CP_UTF8 (&iWideBufLen) to pWideBuf
8572>>>>>>>>>        If (iWideBufLen=0) Begin
8574>>>>>>>>>            Function_Return 0
8575>>>>>>>>>        End
8575>>>>>>>>>>
8575>>>>>>>>>        Move 0 to pRetBuf
8576>>>>>>>>>        Move (WideToMultiBuffer(eCharType,pWideBuf,iWideBufLen,AddressOf(pRetBuf))) to iRetBufLen
8577>>>>>>>>>        Move (Free(pWideBuf)) to bOk
8578>>>>>>>>>        Function_Return pRetBuf
8579>>>>>>>>>    End_Function
8580>>>>>>>>>    
8580>>>>>>>>>    Function Utf8ToStr Pointer pWideBuf Integer eCharType Returns String
8582>>>>>>>>>        String sValue
8582>>>>>>>>>        Pointer pValue
8582>>>>>>>>>        Boolean bOk
8582>>>>>>>>>        Get Utf8ToBuffer pWideBuf eCharType to pValue
8583>>>>>>>>>        If (not(ValidStringBufferLength(pValue))) Begin
8585>>>>>>>>>            Error DFERR_PROGRAM "Buffer exceeds maximum string size"
8586>>>>>>>>>>
8586>>>>>>>>>        End
8586>>>>>>>>>>
8586>>>>>>>>>        Move (PointerToString(pValue)) to sValue
8587>>>>>>>>>        Move (Free(pValue)) to bOk
8588>>>>>>>>>        Function_Return sValue
8589>>>>>>>>>    End_Function
8590>>>>>>>>>    
8590>>>>>>>>>    // Variant functions that allow you to move between a variant string (wide char) and other
8590>>>>>>>>>    // buffer and string types. Normally a Move vVar to sVar does a OEM/Unicode translation. These
8590>>>>>>>>>    // allow you translate to other formats (UTF8, OEM and ANSI)
8590>>>>>>>>>    
8590>>>>>>>>>    // Create data buffer from variant string. data buffer is encoded by eCharType
8590>>>>>>>>>    Function VariantStrToBuffer Variant vValue Integer eCharType Returns Pointer
8592>>>>>>>>>        Pointer pBSTR pRetStr
8592>>>>>>>>>        Integer iLen iBufLen
8592>>>>>>>>>        Boolean bOk
8592>>>>>>>>>        Move 0 to pRetStr
8593>>>>>>>>>        Move (VariantStringLength( vValue)) to iLen
8594>>>>>>>>>        If (iLen) Begin
8596>>>>>>>>>            Move (DeRefPtr(AddressOf(vValue),8)) to pBSTR
8597>>>>>>>>>            Move (WideToMultiBuffer(eCharType,pBSTR,iLen,AddressOf(pRetStr))) to iBufLen
8598>>>>>>>>>        End
8598>>>>>>>>>>
8598>>>>>>>>>        Function_Return pRetStr
8599>>>>>>>>>    End_Function
8600>>>>>>>>>    
8600>>>>>>>>>    // Create string from variant string. data buffer is encoded by eCharType
8600>>>>>>>>>    
8600>>>>>>>>>    Function VariantStrToStr Variant vValue Integer eCharType Returns String
8602>>>>>>>>>        String sValue
8602>>>>>>>>>        Pointer pValue
8602>>>>>>>>>        Boolean bOk
8602>>>>>>>>>        Get VariantStrToBuffer vValue eCharType to pValue
8603>>>>>>>>>        If (not(ValidStringBufferLength(pValue))) Begin
8605>>>>>>>>>            Error DFERR_PROGRAM "Buffer exceeds maximum string size"
8606>>>>>>>>>>
8606>>>>>>>>>        End
8606>>>>>>>>>>
8606>>>>>>>>>        Move (PointerToString(pValue)) to sValue
8607>>>>>>>>>        Move (Free(pValue)) to bOk
8608>>>>>>>>>        Function_Return sValue
8609>>>>>>>>>    End_Function
8610>>>>>>>>>    
8610>>>>>>>>>    // Create variant string from data buffer. data buffer is encoded by eCharType
8610>>>>>>>>>    
8610>>>>>>>>>    Function VariantStrFromBuffer Pointer pSource Integer eCodeType Returns Variant
8612>>>>>>>>>        Variant vValue
8612>>>>>>>>>        Pointer pvValue
8612>>>>>>>>>        Boolean bOk
8612>>>>>>>>>        Pointer pWStr
8612>>>>>>>>>        Move "" to vValue
8613>>>>>>>>>        If (pSource) Begin
8615>>>>>>>>>            //Initialize pWstr variable so it has the correct type and AddressOf will return a proper pointer
8615>>>>>>>>>            Move 0 to pWStr
8616>>>>>>>>>            //Convert the Ansi string to Unicode
8616>>>>>>>>>            Move (MultiToWideBuffer( eCodeType, pSource, CStringSize(pSource), AddressOf(pWStr))) to bOk
8617>>>>>>>>>            //Initialize vValue variable so it has the correct type and AddressOf will return a proper pointer
8617>>>>>>>>>            Move 0 to vValue
8618>>>>>>>>>            Move (AddressOf(vValue)) to pvValue
8619>>>>>>>>>            //Change the Variant type to VT_BSTR
8619>>>>>>>>>            Move (StoreDw(pvValue,0,OLE_VT_Bstr)) to bOk
8620>>>>>>>>>            //Allocate a proper COM BSTR, assign the Unicode string, and store the BSTR in the Variant variable
8620>>>>>>>>>            Move (StorePtr(pvValue,8,SysAllocString(pWStr))) to bOk
8621>>>>>>>>>            //Now clear up the Unicode string, the Variant owns a BSTR copy of the string
8621>>>>>>>>>            Move (Free(pWStr)) to bOk
8622>>>>>>>>>        End
8622>>>>>>>>>>
8622>>>>>>>>>        Function_Return vValue
8623>>>>>>>>>    End_Function
8624>>>>>>>>>    
8624>>>>>>>>>    // Create variant string from data string. data string is encoded by eCharType
8624>>>>>>>>>    
8624>>>>>>>>>    Function VariantStrFromStr String sValue Integer eCodeType Returns Variant
8626>>>>>>>>>        Variant vValue
8626>>>>>>>>>        Get VariantStrFromBuffer (AddressOf(sValue)) eCodeType to vValue
8627>>>>>>>>>        Function_Return vValue
8628>>>>>>>>>    End_Function
8629>>>>>>>>>    
8629>>>>>>>>>    // Create buffer of utf16 data from variant.
8629>>>>>>>>>    // Returns newly created memory address and length (by reference)
8629>>>>>>>>>    Function VariantStrToUTF16 Variant vValue Integer ByRef iLen Returns Pointer
8631>>>>>>>>>        Pointer pBSTR pRetStr
8631>>>>>>>>>        Boolean bOk
8631>>>>>>>>>        Move 0 to pRetStr
8632>>>>>>>>>        Move (VariantStringLength( vValue)) to iLen
8633>>>>>>>>>        If (iLen) Begin
8635>>>>>>>>>            Move (DeRefPtr(AddressOf(vValue),8)) to pBSTR
8636>>>>>>>>>            Move (Alloc(iLen+1 * 2)) to pRetStr
8637>>>>>>>>>            Move (MemCopy(pRetStr,pBSTR,(iLen+1 * 2))) to bOk
8638>>>>>>>>>        End
8638>>>>>>>>>>
8638>>>>>>>>>        Function_Return pRetStr
8639>>>>>>>>>    End_Function
8640>>>>>>>>>    
8640>>>>>>>>>    // Create variant from buffer of utf16 data
8640>>>>>>>>>    Function VariantStrFromUTF16 Pointer pSource Returns Variant
8642>>>>>>>>>        Variant vValue
8642>>>>>>>>>        Pointer pvValue
8642>>>>>>>>>        Boolean bOk
8642>>>>>>>>>        Move "" to vValue
8643>>>>>>>>>        If (pSource) Begin
8645>>>>>>>>>            //Initialize pWstr variable so it has the correct type and AddressOf will return a proper pointer
8645>>>>>>>>>            //Initialize vValue variable so it has the correct type and AddressOf will return a proper pointer
8645>>>>>>>>>            Move 0 to vValue
8646>>>>>>>>>            Move (AddressOf(vValue)) to pvValue
8647>>>>>>>>>            //Change the Variant type to VT_BSTR
8647>>>>>>>>>            Move (StoreDw(pvValue,0,OLE_VT_Bstr)) to bOk
8648>>>>>>>>>            //Allocate a proper COM BSTR, assign the Unicode string, and store the BSTR in the Variant variable
8648>>>>>>>>>            Move (StorePtr(pvValue,8,SysAllocString(pSource))) to bOk
8649>>>>>>>>>        End
8649>>>>>>>>>>
8649>>>>>>>>>        Function_Return vValue
8650>>>>>>>>>    End_Function
8651>>>>>>>>>    
8651>>>>>>>>>    // Create Uchar array from variant string.
8651>>>>>>>>>    // Data buffer is encoded by eCharType
8651>>>>>>>>>    Function VariantStrToUCharArray Variant vValue Integer eCharType Returns UChar[]
8653>>>>>>>>>        Pointer pBSTR pRetStr
8653>>>>>>>>>        Integer iLen iBufLen
8653>>>>>>>>>        Boolean bOk
8653>>>>>>>>>        UChar[] UC1
8654>>>>>>>>>        Move 0 to pRetStr
8655>>>>>>>>>        Move (VariantStringLength( vValue)) to iLen
8656>>>>>>>>>        If (iLen) Begin
8658>>>>>>>>>            Move (DeRefPtr(AddressOf(vValue),8)) to pBSTR
8659>>>>>>>>>            If (eCharType=CP_UTF16) Begin
8661>>>>>>>>>                Move (iLen*2) to iBufLen
8662>>>>>>>>>                Move (ResizeArray(UC1,iBufLen)) to UC1
8663>>>>>>>>>                Move (MemCopy(AddressOf(UC1),pBSTR,iBufLen)) to bOk
8664>>>>>>>>>            End
8664>>>>>>>>>>
8664>>>>>>>>>            Else Begin
8665>>>>>>>>>                Move (WideToMultiBuffer(eCharType,pBSTR,iLen,AddressOf(pRetStr))) to iBufLen
8666>>>>>>>>>                Move (ResizeArray(UC1,iBufLen)) to UC1
8667>>>>>>>>>                Move (MemCopy(AddressOf(UC1),pRetStr,iBufLen)) to bOk
8668>>>>>>>>>                Move (Free(pRetStr)) to bOk
8669>>>>>>>>>            End
8669>>>>>>>>>>
8669>>>>>>>>>        End
8669>>>>>>>>>>
8669>>>>>>>>>        Function_Return UC1
8670>>>>>>>>>    End_Function
8671>>>>>>>>>    
8671>>>>>>>>>    // Create variant string from UChar array. data is encoded by eCharType
8671>>>>>>>>>    Function VariantStrFromUCharArray UChar[] ucSource Integer eCodeType Returns Variant
8673>>>>>>>>>        Variant vValue
8673>>>>>>>>>        Pointer pvValue
8673>>>>>>>>>        Boolean bOk
8673>>>>>>>>>        Pointer pWStr
8673>>>>>>>>>        Move "" to vValue
8674>>>>>>>>>        
8674>>>>>>>>>        //Initialize pWstr variable so it has the correct type and AddressOf will return a proper pointer
8674>>>>>>>>>        Move 0 to pWStr
8675>>>>>>>>>        //Convert the Ansi string to Unicode
8675>>>>>>>>>        If (eCodeType=CP_UTF16) Begin
8677>>>>>>>>>            Move 0 to ucSource[SizeOfArray(ucSource)]
8678>>>>>>>>>            Move 0 to ucSource[SizeOfArray(ucSource)]
8679>>>>>>>>>            Move (AddressOf(ucSource)) to pWStr
8680>>>>>>>>>        End
8680>>>>>>>>>>
8680>>>>>>>>>        Else Begin
8681>>>>>>>>>            Move (MultiToWideBuffer( eCodeType, AddressOf(ucSource), SizeOfArray(ucSource), AddressOf(pWStr))) to bOk
8682>>>>>>>>>        End
8682>>>>>>>>>>
8682>>>>>>>>>        //Initialize vValue variable so it has the correct type and AddressOf will return a proper pointer
8682>>>>>>>>>        Move 0 to vValue
8683>>>>>>>>>        Move (AddressOf(vValue)) to pvValue
8684>>>>>>>>>        //Change the Variant type to VT_BSTR
8684>>>>>>>>>        Move (StoreDw(pvValue,0,OLE_VT_Bstr)) to bOk
8685>>>>>>>>>        //Allocate a proper COM BSTR, assign the Unicode string, and store the BSTR in the Variant variable
8685>>>>>>>>>        Move (StorePtr(pvValue,8,SysAllocString(pWStr))) to bOk
8686>>>>>>>>>        //Now clear up the Unicode string, the Variant owns a BSTR copy of the string
8686>>>>>>>>>        If (eCodeType<>CP_UTF16) Begin
8688>>>>>>>>>            Move (Free(pWStr)) to bOk
8689>>>>>>>>>        End
8689>>>>>>>>>>
8689>>>>>>>>>        Function_Return vValue
8690>>>>>>>>>    End_Function
8691>>>>>>>>>    
8691>>>>>>>>>    
8691>>>>>>>>>    // UChar array conversions. Converts a passed uchar array with from-encoding to
8691>>>>>>>>>    // a new UChar array with to-encoding
8691>>>>>>>>>    
8691>>>>>>>>>    Function ConvertUCharArray UChar[] UCharData Integer iFromCP Integer iToCP Returns UChar[]
8693>>>>>>>>>        Pointer pFromBuf pToBuf
8693>>>>>>>>>        Integer iBytes iChars
8693>>>>>>>>>        Boolean bOk
8693>>>>>>>>>        
8693>>>>>>>>>        Move (SizeOfArray(UCharData)) to iBytes
8694>>>>>>>>>        If (iFromCP=iToCP or iBytes=0) Begin
8696>>>>>>>>>            Function_Return UCharData
8697>>>>>>>>>        End
8697>>>>>>>>>>
8697>>>>>>>>>        
8697>>>>>>>>>        If (iFromCP<>CP_UTF16) Begin
8699>>>>>>>>>            Move 0 to UCharData[iBytes] // extend to make sure we have 0 at end
8700>>>>>>>>>            Get Utf16FromBuffer (AddressOf(UCharData)) iFromCP (&iChars) to pFromBuf
8701>>>>>>>>>        End
8701>>>>>>>>>>
8701>>>>>>>>>        Else Begin
8702>>>>>>>>>            Move (iBytes/2) to iChars // if from is utf16
8703>>>>>>>>>        End
8703>>>>>>>>>>
8703>>>>>>>>>        
8703>>>>>>>>>        If (iToCP<>CP_UTF16) Begin
8705>>>>>>>>>            If (iFromCP=CP_UTF16) Begin
8707>>>>>>>>>                Get Utf16ToBuffer (AddressOf(UCharData)) iToCP iChars to pToBuf
8708>>>>>>>>>            End
8708>>>>>>>>>>
8708>>>>>>>>>            Else Begin
8709>>>>>>>>>                Get Utf16ToBuffer pFromBuf iToCP iChars to pToBuf
8710>>>>>>>>>                Move (Free(pFromBuf)) to bOk
8711>>>>>>>>>            End
8711>>>>>>>>>>
8711>>>>>>>>>            Move (CStringSize(pToBuf)) to iBytes
8712>>>>>>>>>        End
8712>>>>>>>>>>
8712>>>>>>>>>        Else Begin
8713>>>>>>>>>            Move (iChars*2) to iBytes
8714>>>>>>>>>            Move pFromBuf to pToBuf
8715>>>>>>>>>        End
8715>>>>>>>>>>
8715>>>>>>>>>        Move (ResizeArray(UCharData,iBytes)) to UCharData
8716>>>>>>>>>        Move (MemCopy(AddressOf(UCharData),pToBuf,iBytes)) to bOk
8717>>>>>>>>>        Move (Free(pToBuf)) to bOk
8718>>>>>>>>>        Function_Return UCharData
8719>>>>>>>>>    End_Function
8720>>>>>>>>>    
8720>>>>>>>>>    // Base64 Encoding functions that allow you to encode to and decode from strings and
8720>>>>>>>>>    // Variant strings. Binary data is always buffer
8720>>>>>>>>>    
8720>>>>>>>>>    Function Base64EncodeToStr Pointer pBinaryData Integer iBinaryLen Returns String
8722>>>>>>>>>        Pointer pBase64
8722>>>>>>>>>        String sResult
8722>>>>>>>>>        Integer iVoid
8722>>>>>>>>>        Move (Base64Encode(pBinaryData, iBinaryLen)) to pBase64
8723>>>>>>>>>        Move (PointerToString(pBase64)) to sResult
8724>>>>>>>>>        Move (Free(pBase64)) to iVoid
8725>>>>>>>>>        Function_Return sResult
8726>>>>>>>>>    End_Function
8727>>>>>>>>>    
8727>>>>>>>>>    Function Base64DecodeFromStr String sBase64 Integer ByRef iBinaryLen Returns Pointer
8729>>>>>>>>>        Pointer pBinaryData
8729>>>>>>>>>        String sBinary
8729>>>>>>>>>        Integer iVoid
8729>>>>>>>>>        Move (Base64Decode(AddressOf(sBase64), &iBinaryLen)) to pBinaryData
8730>>>>>>>>>        Function_Return pBinaryData
8731>>>>>>>>>    End_Function
8732>>>>>>>>>    
8732>>>>>>>>>    Function Base64EncodeToVariantStr Pointer pBinaryData Integer iBinaryLen Returns Variant
8734>>>>>>>>>        Pointer pBase64
8734>>>>>>>>>        Variant vVar
8734>>>>>>>>>        Integer iBase64Len iVoid
8734>>>>>>>>>        If (pBinaryData and iBinaryLen) Begin
8736>>>>>>>>>            Move (Base64Encode(pBinaryData,iBinaryLen)) to pBase64
8737>>>>>>>>>            Get  VariantStrFromBuffer pBase64 CP_ACP to vVar
8738>>>>>>>>>            Move (Free(pBase64)) to iVoid
8739>>>>>>>>>        End
8739>>>>>>>>>>
8739>>>>>>>>>        Function_Return vVar
8740>>>>>>>>>    End_Function
8741>>>>>>>>>    
8741>>>>>>>>>    Function Base64DecodeFromVariantStr Variant vBase64Str Integer ByRef iBinaryLen Returns Pointer
8743>>>>>>>>>        Pointer pBase64 pBinaryData
8743>>>>>>>>>        Integer iVoid
8743>>>>>>>>>        Move 0 to iBinaryLen
8744>>>>>>>>>        Get VariantStrToBuffer vBase64Str CP_ACP to pBase64
8745>>>>>>>>>        If (pBase64) Begin
8747>>>>>>>>>            Move (Base64Decode(pBase64,&iBinaryLen)) to pBinaryData
8748>>>>>>>>>            Move (Free(pBase64)) to iVoid
8749>>>>>>>>>        End
8749>>>>>>>>>>
8749>>>>>>>>>        Function_Return pBinaryData
8750>>>>>>>>>    End_Function
8751>>>>>>>>>    
8751>>>>>>>>>    // base 64 Encode from Uchar array to a Uchar array
8751>>>>>>>>>    Function Base64EncodeUCharArray UChar[] UCharData Returns UChar[]
8753>>>>>>>>>        Pointer pBase64
8753>>>>>>>>>        Integer iLen
8753>>>>>>>>>        Boolean bOk
8753>>>>>>>>>        
8753>>>>>>>>>        Move (SizeOfArray(UCharData)) to iLen
8754>>>>>>>>>        If (iLen) Begin
8756>>>>>>>>>            Move (Base64Encode(AddressOf(UCharData), iLen)) to pBase64
8757>>>>>>>>>            Move (CStringSize(pBase64)) to iLen
8758>>>>>>>>>            Move (ResizeArray(UCharData,iLen)) to UCharData
8759>>>>>>>>>            Move (MemCopy(AddressOf(UCharData),pBase64,iLen)) to bOk
8760>>>>>>>>>            Move (Free(pBase64)) to bOk
8761>>>>>>>>>        End
8761>>>>>>>>>>
8761>>>>>>>>>        Function_Return UCharData
8762>>>>>>>>>    End_Function
8763>>>>>>>>>    
8763>>>>>>>>>    // base 64 Decode from Uchar array to a Uchar array
8763>>>>>>>>>    Function Base64DecodeUCharArray UChar[] UCharData Returns UChar[]
8765>>>>>>>>>        Pointer pData
8765>>>>>>>>>        Integer iLen
8765>>>>>>>>>        Boolean bOk
8765>>>>>>>>>        
8765>>>>>>>>>        Move (SizeOfArray(UCharData)) to iLen
8766>>>>>>>>>        If (iLen) Begin
8768>>>>>>>>>            Move 0 to UCharData[iLen]
8769>>>>>>>>>            Move (Base64Decode(AddressOf(UCharData),&iLen)) to pData
8770>>>>>>>>>            Move (ResizeArray(UCharData,iLen)) to UCharData
8771>>>>>>>>>            Move (MemCopy(AddressOf(UCharData),pData,iLen)) to bOk
8772>>>>>>>>>            Move (Free(pData)) to bOk
8773>>>>>>>>>        End
8773>>>>>>>>>>
8773>>>>>>>>>        Function_Return UCharData
8774>>>>>>>>>    End_Function
8775>>>>>>>>>    
8775>>>>>>>>>End_Class
8776>>>>>>>>>
8776>>>>>>>>>
8776>>>>>>>
8776>>>>>>>// it is important that psFileName is defined. If blank, the registry may be accessed. We will check all WritePrivateProfileString
8776>>>>>>>// and GetPrivateProfileString to make sure that a file is defined.
8776>>>>>>>
8776>>>>>>>
8776>>>>>>>External_Function WritePrivateProfileStringW "WritePrivateProfileStringW" Kernel32.dll ;    WString sSection ;    WString sKeyName ;    WString sValue ;    WString sFileName ;    Returns Integer
8777>>>>>>>
8777>>>>>>>
8777>>>>>>>// When called directly, be sure to use WString types.
8777>>>>>>>External_Function GetPrivateProfileStringW "GetPrivateProfileStringW" Kernel32.dll ;    Pointer lpSection ;    Pointer lpKeyName ;    Pointer lpDefault ;    Pointer lpsValue ;    Integer nSize ;    WString lpFileName ;    Returns Integer
8778>>>>>>>
8778>>>>>>>External_Function WritePrivateProfileStringA "WritePrivateProfileStringA" Kernel32.dll ;    String sSection ;    String sKeyName ;    String sValue ;    String sFileName ;    Returns Integer
8779>>>>>>>    
8779>>>>>>>// When called directly, be sure to use String types.
8779>>>>>>>External_Function GetPrivateProfileStringA "GetPrivateProfileStringA" Kernel32.dll ;    Pointer lpSection ;    Pointer lpKeyName ;    Pointer lpDefault ;    Pointer lpsValue ;    Integer nSize ;    String lpFileName ;    Returns Integer
8780>>>>>>>    
8780>>>>>>>// Wrapper redirecting direct access to the wide for backwards compatibility (parameters will be auto converted)
8780>>>>>>>Define WritePrivateProfileString for WritePrivateProfileStringW
8780>>>>>>>    
8780>>>>>>>
8780>>>>>>>// Wrapper Function GetPrivateProfileString for backwards compatibility
8780>>>>>>>Function GetPrivateProfileString Global ;    Pointer pSection ;    Pointer pKeyName ;    Pointer pDefault ;    Pointer lpsValue ;    Integer nSize ;    String  sFileName ;    Returns Integer
8782>>>>>>>    
8782>>>>>>>    Integer iResult
8782>>>>>>>    UWide   uwSection uwKeyName uwDefault uwValue uwFileName
8782>>>>>>>    UWide   uwSection uwKeyName uwDefault uwValue uwFileName
8782>>>>>>>
8782>>>>>>>    Send StringToWide pSection (&uwSection)
8783>>>>>>>    Send StringToWide pKeyName (&uwKeyName)
8784>>>>>>>    Send StringToWide pDefault (&uwDefault)    
8785>>>>>>>    Send StringToWide (AddressOf(sFileName)) (&uwFileName)
8786>>>>>>>                           
8786>>>>>>>    Send WideSetBuffer lpsValue (AddressOf(nSize)) (&uwValue) 
8787>>>>>>>       
8787>>>>>>>    Move (GetPrivateProfileStringW (uwSection.lpUText, uwKeyName.lpUText, uwDefault.lpUText, uwValue.lpUText, nSize, uwFileName.lpUText)) to iResult
8788>>>>>>>        
8788>>>>>>>    Send WideToStringSized (&uwValue) lpsValue iResult      // iResult is number of characters
8789>>>>>>>    
8789>>>>>>>    Function_Return iResult
8790>>>>>>>End_Function
8791>>>>>>> 
8791>>>>>>>
8791>>>>>>>Class cIniFile is a cObject
8792>>>>>>>    Procedure Construct_Object
8794>>>>>>>        Forward Send Construct_Object
8796>>>>>>>        
8796>>>>>>>        
8796>>>>>>>        // Set to false to use the narrow windows API's to access the ini files. This allows UTF-8 data to be written
8796>>>>>>>        // and read (except if the file is stored as UTF-16) but has the downside of not supporting unicode file paths.
8796>>>>>>>        Property Boolean pbWideAPI True
8797>>>>>>>        
8797>>>>>>>        // Set to true to save the ini file as UTF-16LE (with a BOM). This allows unicode data to be saved properly
8797>>>>>>>        // using the wide API's. Note that pbWideAPI should be true to use this property. Existing ini files will be
8797>>>>>>>        // converted on first write (WriteString).
8797>>>>>>>        Property Boolean pbStoreAsUTF16 False
8798>>>>>>>        
8798>>>>>>>        Property String psPrivate_FileName ""
8799>>>>>>>        Property Boolean pbPrivate_FirstWrite True
8800>>>>>>>    End_Procedure
8801>>>>>>>    
8801>>>>>>>    Procedure Set psFileName String sVal
8803>>>>>>>        Set pbPrivate_FirstWrite to True
8804>>>>>>>        Set psPrivate_FileName to sVal
8805>>>>>>>    End_Procedure
8806>>>>>>>    
8806>>>>>>>    Function psFileName Returns String
8808>>>>>>>        Function_Return (psPrivate_FileName(Self))
8809>>>>>>>    End_Function
8810>>>>>>>    
8810>>>>>>>    Procedure InitFile
8812>>>>>>>        Boolean bExists bHasBom
8812>>>>>>>        Integer iChnl
8812>>>>>>>        UChar[] ucData
8813>>>>>>>        Handle hoTranslate
8813>>>>>>>        
8813>>>>>>>        If (pbPrivate_FirstWrite(Self) and pbStoreAsUTF16(Self) and pbWideAPI(Self)) Begin
8815>>>>>>>            File_Exist (psPrivate_FileName(Self)) bExists
8816>>>>>>>            If (not(bExists)) Begin
8818>>>>>>>                //  Create the file with a UTF-16 BOM so
8818>>>>>>>                Move (Seq_New_Channel()) to iChnl
8819>>>>>>>                If (iChnl >= 0) Begin
8821>>>>>>>                    Direct_Output channel iChnl ("binary:" + psPrivate_FileName(Self))
8823>>>>>>>                    Write channel iChnl C_BOM_UTF16LE
8825>>>>>>>                    Close_Output channel iChnl
8827>>>>>>>                    Send Seq_Release_Channel iChnl
8828>>>>>>>                End
8828>>>>>>>>
8828>>>>>>>                Else If (iChnl = -1) Begin
8831>>>>>>>                    Error DFErr_Program "I/O Channel Error"
8832>>>>>>>>
8832>>>>>>>                End
8832>>>>>>>>
8832>>>>>>>                Else If (iChnl = -2) Begin
8835>>>>>>>                    Error DFErr_Program "No I/O Channel Available"
8836>>>>>>>>
8836>>>>>>>                End
8836>>>>>>>>
8836>>>>>>>            End
8836>>>>>>>>
8836>>>>>>>            Else Begin
8837>>>>>>>                //  Check for BOM
8837>>>>>>>                Move (Seq_New_Channel()) to iChnl
8838>>>>>>>                If (iChnl >= 0) Begin
8840>>>>>>>                    Direct_Input channel iChnl ("binary:" + psPrivate_FileName(Self))
8842>>>>>>>                    Read_Block channel iChnl ucData 2
8844>>>>>>>                    
8844>>>>>>>                    Move (SizeOfArray(ucData) >= 2 and ucData[0] = C_BOM_UTF16LEc1 and ucData[1] = C_BOM_UTF16LEc2) to bHasBom
8845>>>>>>>                    
8845>>>>>>>                    //  If no BOM we'll have to read the entire file to convert it
8845>>>>>>>                    If (not(bHasBom)) Begin
8847>>>>>>>                        Set_Channel_Position iChnl to 0
8848>>>>>>>>
8848>>>>>>>                        Read_Block ucData -1
8849>>>>>>>                    End
8849>>>>>>>>
8849>>>>>>>    
8849>>>>>>>                    Close_Input channel iChnl
8851>>>>>>>                    
8851>>>>>>>                    If (not(bHasBom)) Begin
8853>>>>>>>                        //  Convert thedata
8853>>>>>>>                        Get Create (RefClass(cCharTranslate)) to hoTranslate
8854>>>>>>>                        Get ConvertUCharArray of hoTranslate ucData CP_OEMCP CP_UTF16 to ucData
8855>>>>>>>                        
8855>>>>>>>                        //  Write out the UTF 16 file with BOM
8855>>>>>>>                        Direct_Output channel iChnl ("binary:" + psPrivate_FileName(Self))
8857>>>>>>>                        Write channel iChnl C_BOM_UTF16LE
8859>>>>>>>                        
8859>>>>>>>                        Write channel iChnl ucData
8861>>>>>>>                        
8861>>>>>>>                        Close_Output channel iChnl
8863>>>>>>>                        
8863>>>>>>>                        Send Destroy of hoTranslate
8864>>>>>>>                    End
8864>>>>>>>>
8864>>>>>>>                    
8864>>>>>>>                    Send Seq_Release_Channel iChnl
8865>>>>>>>                End
8865>>>>>>>>
8865>>>>>>>                Else If (iChnl = -1) Begin
8868>>>>>>>                    Error DFErr_Program "I/O Channel Error"
8869>>>>>>>>
8869>>>>>>>                End
8869>>>>>>>>
8869>>>>>>>                Else If (iChnl = -2) Begin
8872>>>>>>>                    Error DFErr_Program "No I/O Channel Available"
8873>>>>>>>>
8873>>>>>>>                End
8873>>>>>>>>
8873>>>>>>>            End
8873>>>>>>>>
8873>>>>>>>            
8873>>>>>>>            Set pbPrivate_FirstWrite to False
8874>>>>>>>        End
8874>>>>>>>>
8874>>>>>>>    End_Procedure
8875>>>>>>>    
8875>>>>>>>    Procedure WriteString String sSection String sKey String sValue
8877>>>>>>>        Boolean bSuccess
8877>>>>>>>        String sFileName
8877>>>>>>>        
8877>>>>>>>        If (trim(psPrivate_FileName(Self))="") Begin
8879>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
8880>>>>>>>>
8880>>>>>>>            Procedure_Return
8881>>>>>>>        End
8881>>>>>>>>
8881>>>>>>>        
8881>>>>>>>        Send InitFile
8882>>>>>>>        
8882>>>>>>>        // All parameters are Strings and are converted to WString upon invoking the external function.
8882>>>>>>>        If (pbWideAPI(Self)) Begin
8884>>>>>>>            Move (WritePrivateProfileStringW(sSection, sKey, sValue, psPrivate_FileName(Self))) to bSuccess
8885>>>>>>>        End
8885>>>>>>>>
8885>>>>>>>        Else Begin
8886>>>>>>>            Move (Utf8ToAnsi(psPrivate_FileName(Self))) to sFileName
8887>>>>>>>            Move (WritePrivateProfileStringA(sSection, sKey, sValue, sFilename)) to bSuccess 
8888>>>>>>>        End
8888>>>>>>>>
8888>>>>>>>        If (bSuccess = False) ;            Error DFERR_INI_FILE C_$CannotWriteToTheIniFile
8891>>>>>>>    End_Procedure
8892>>>>>>>    
8892>>>>>>>    
8892>>>>>>>    Function ReadString String sSection String sKey String sDefault Returns String
8894>>>>>>>        Integer iNumChars iSizeValue
8894>>>>>>>        WString wValue wFileName wSection wKey wDefault
8894>>>>>>>        String sFileName sValue
8894>>>>>>>        
8894>>>>>>>        Move 2047 to iSizeValue
8895>>>>>>>        Move (Repeat(" ", iSizeValue)) to sValue
8896>>>>>>>        
8896>>>>>>>        If (trim(psPrivate_FileName(Self))="") Begin
8898>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
8899>>>>>>>>
8899>>>>>>>            Function_Return ''
8900>>>>>>>        End
8900>>>>>>>>
8900>>>>>>>        
8900>>>>>>>        If (pbWideAPI(Self)) Begin
8902>>>>>>>            Move sSection to wSection
8903>>>>>>>            Move sKey to wKey
8904>>>>>>>            Move sDefault to wDefault
8905>>>>>>>            Move sValue to wValue
8906>>>>>>>            Move (GetPrivateProfileStringW(AddressOf(wSection), AddressOf(wKey), AddressOf(wDefault), AddressOf(wValue), iSizeValue, psPrivate_FileName(Self))) to iNumChars
8907>>>>>>>            Move wValue to sValue
8908>>>>>>>        End
8908>>>>>>>>
8908>>>>>>>        Else Begin
8909>>>>>>>            Move (Utf8ToAnsi(psPrivate_FileName(Self))) to sFileName
8910>>>>>>>            Move (GetPrivateProfileStringA(AddressOf(sSection), AddressOf(sKey), AddressOf(sDefault), AddressOf(sValue), iSizeValue, sFileName)) to iNumChars
8911>>>>>>>        End
8911>>>>>>>>
8911>>>>>>>        
8911>>>>>>>        Function_Return  (CString(sValue))
8912>>>>>>>    End_Function
8913>>>>>>>    
8913>>>>>>>    Function SectionExists String sSection Returns Boolean
8915>>>>>>>        // A section exists only if it has at least one Key. A section with no keys is said not to exist
8915>>>>>>>        Handle hoKeys
8915>>>>>>>        Integer icKey iKey
8915>>>>>>>        
8915>>>>>>>        Get Create U_ARRAY to hoKeys
8916>>>>>>>        Send ReadSection sSection hoKeys
8917>>>>>>>        Get Item_Count of hoKeys to icKey
8918>>>>>>>        Send Destroy of hoKeys
8919>>>>>>>        
8919>>>>>>>        Function_Return (icKey >0)
8920>>>>>>>    End_Function
8921>>>>>>>    
8921>>>>>>>    Procedure ReadSection WString wSection Handle hoArray
8923>>>>>>>        Integer iNumChars iSizeValue iPos
8923>>>>>>>        Pointer lpsKeys
8923>>>>>>>        WString wKeys wKey
8923>>>>>>>        String  sSection sKeys sKey
8923>>>>>>>        
8923>>>>>>>        Move 16384 to iSizeValue
8924>>>>>>>        
8924>>>>>>>        If (trim(psPrivate_FileName(Self))="") Begin
8926>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
8927>>>>>>>>
8927>>>>>>>            Procedure_Return
8928>>>>>>>        End
8928>>>>>>>>
8928>>>>>>>        // The last parameter is a String and is converted to WString upon invoking the external function.
8928>>>>>>>        If (pbWideAPI(Self)) Begin
8930>>>>>>>            Move (Repeat(character(0),  iSizeValue)) to wKeys        
8931>>>>>>>            Move (AddressOf(wKeys)) to lpsKeys
8932>>>>>>>            
8932>>>>>>>            Move (GetPrivateProfileStringW(AddressOf(wSection), 0, 0, lpsKeys, Length(wKeys), psPrivate_FileName(Self))) to iNumChars
8933>>>>>>>            If (iNumChars >0) Begin
8935>>>>>>>                Repeat
8935>>>>>>>>
8935>>>>>>>                    Move (Pos(Character(0),wKeys)) to iPos
8936>>>>>>>                    If (iPos >1) Begin
8938>>>>>>>                        Move (Left(wKeys,iPos -1))  to wKey
8939>>>>>>>                        Move (Right(wKeys,Length(wKeys) - iPos)) to wKeys
8940>>>>>>>                        Set Value of hoArray (Item_Count(hoArray)) to wKey
8941>>>>>>>                    End
8941>>>>>>>>
8941>>>>>>>                Until (iPos <=1)
8943>>>>>>>            End
8943>>>>>>>>
8943>>>>>>>        End
8943>>>>>>>>
8943>>>>>>>        Else Begin
8944>>>>>>>            Move wSection to sSection            
8945>>>>>>>            Move (Repeat(character(0),  iSizeValue)) to sKeys        
8946>>>>>>>            Move (AddressOf(sKeys)) to lpsKeys
8947>>>>>>>        
8947>>>>>>>            Move (GetPrivateProfileStringA(AddressOf(sSection), 0, 0, lpsKeys, Length(sKeys), psPrivate_FileName(Self))) to iNumChars
8948>>>>>>>            If (iNumChars >0) Begin
8950>>>>>>>                Repeat
8950>>>>>>>>
8950>>>>>>>                    Move (Pos(Character(0),sKeys)) to iPos
8951>>>>>>>                    If (iPos >1) Begin
8953>>>>>>>                        Move (Left(sKeys,iPos -1))  to sKey
8954>>>>>>>                        Move (Right(sKeys,Length(sKeys) - iPos)) to sKeys
8955>>>>>>>                        Set Value of hoArray (Item_Count(hoArray)) to sKey
8956>>>>>>>                    End
8956>>>>>>>>
8956>>>>>>>                Until (iPos <=1)
8958>>>>>>>            End
8958>>>>>>>>
8958>>>>>>>        End
8958>>>>>>>>
8958>>>>>>>    End_Procedure
8959>>>>>>>    
8959>>>>>>>    Procedure ReadSections Handle hoArray
8961>>>>>>>        Integer iNumChars iSizeValue iPos
8961>>>>>>>        Pointer lpwSections
8961>>>>>>>        WString wSections
8961>>>>>>>        String sSection
8961>>>>>>>        
8961>>>>>>>        Move 16384 to iSizeValue
8962>>>>>>>        
8962>>>>>>>        Move (Repeat(character(0),  iSizeValue)) to wSections
8963>>>>>>>        Move (AddressOf(wSections)) to lpwSections
8964>>>>>>>        
8964>>>>>>>        If (trim(psPrivate_FileName(Self))="") Begin
8966>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
8967>>>>>>>>
8967>>>>>>>            Procedure_Return
8968>>>>>>>        End
8968>>>>>>>>
8968>>>>>>>        // The last parameter is a String and is converted to WString upon invoking the external function.
8968>>>>>>>        Move (GetPrivateProfileStringW(0, 0, 0, lpwSections, Length(wSections), psPrivate_FileName(Self))) to iNumChars
8969>>>>>>>        If (iNumChars >0) Begin
8971>>>>>>>            Repeat
8971>>>>>>>>
8971>>>>>>>                Move (Pos(Character(0),wSections)) to iPos
8972>>>>>>>                If (iPos >1) Begin
8974>>>>>>>                    Move (Left(wSections,iPos -1)) to sSection
8975>>>>>>>                    Move (Right(wSections, Length(wSections) - iPos)) to wSections
8976>>>>>>>                    Set Value of hoArray (Item_Count(hoArray)) to sSection
8977>>>>>>>                End
8977>>>>>>>>
8977>>>>>>>            Until (iPos <=1)
8979>>>>>>>        End
8979>>>>>>>>
8979>>>>>>>        
8979>>>>>>>    End_Procedure
8980>>>>>>>    
8980>>>>>>>    Procedure DeleteSection String sSection
8982>>>>>>>        
8982>>>>>>>        If (trim(psPrivate_FileName(Self))="") Begin
8984>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
8985>>>>>>>>
8985>>>>>>>            Procedure_Return
8986>>>>>>>        End
8986>>>>>>>>
8986>>>>>>>        If (WritePrivateProfileString(sSection, "", "", psPrivate_FileName(Self)) = 0) ;            Error DFERR_INI_FILE C_$CanNotDeleteSection
8989>>>>>>>    End_Procedure
8990>>>>>>>    
8990>>>>>>>    Procedure DeleteKey String sSection String sKey
8992>>>>>>>        Integer iVoid
8992>>>>>>>        If (trim(psPrivate_FileName(Self))="") Begin
8994>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
8995>>>>>>>>
8995>>>>>>>            Procedure_Return
8996>>>>>>>        End
8996>>>>>>>>
8996>>>>>>>        Move (WritePrivateProfileString(sSection, sKey, "", psPrivate_FileName(Self))) to iVoid
8997>>>>>>>    End_Procedure
8998>>>>>>>    
8998>>>>>>>    Function KeyExists String sSection String sKey Returns Boolean
9000>>>>>>>        Handle hoKeys
9000>>>>>>>        Integer iKey
9000>>>>>>>        Boolean bExists
9000>>>>>>>        
9000>>>>>>>        Move (False) to bExists
9001>>>>>>>        
9001>>>>>>>        Move (Uppercase(sKey)) to sKey
9002>>>>>>>        
9002>>>>>>>        Get Create U_ARRAY to hoKeys
9003>>>>>>>        
9003>>>>>>>        Send ReadSection sSection hoKeys
9004>>>>>>>        For iKey from 0 to (Item_Count(hoKeys) -1)
9010>>>>>>>>
9010>>>>>>>            If (sKey = Uppercase(Value(hoKeys, iKey))) Begin
9012>>>>>>>                Move (True) to bExists
9013>>>>>>>            End
9013>>>>>>>>
9013>>>>>>>        Loop
9014>>>>>>>>
9014>>>>>>>        
9014>>>>>>>        Send Destroy of hoKeys
9015>>>>>>>        
9015>>>>>>>        Function_Return bExists
9016>>>>>>>    End_Function
9017>>>>>>>    
9017>>>>>>>End_Class
9018>>>>>
9018>>>>>Class cWorkspace is a cObject
9019>>>>>    
9019>>>>>    Procedure Construct_Object
9021>>>>>        Forward Send Construct_Object
9023>>>>>        
9023>>>>>        
9023>>>>>        Property String psAppSrcPath
9024>>>>>        Property String psBitmapPath
9025>>>>>        Property String psDataPath
9026>>>>>        Property String psDdSrcPath
9027>>>>>        Property String psDescription
9028>>>>>        Property String psFileList
9029>>>>>        Property String psHelpPath
9030>>>>>        Property String psHome
9031>>>>>        Property String psIdeSrcPath
9032>>>>>        Property String psProgramPath
9033>>>>>        Property String psAppHtmlPath
9034>>>>>        Property String psWorkspaceName
9035>>>>>        Property String psWorkspaceWSFile
9036>>>>>        Property String psConnectionIni
9037>>>>>        
9037>>>>>        Property String psSystemDfPath // took from the Registry!
9038>>>>>        Property String psSystemMakePath // took from the Registry!
9039>>>>>        Property String psDfPath        // Calculated
9040>>>>>        
9040>>>>>        Property Boolean pbWorkspaceOpened False // used internally to tell if we are switching workspaces
9041>>>>>        
9041>>>>>    End_Procedure
9042>>>>>    
9042>>>>>    Function FullPathNames String sShortPathNames Returns String
9044>>>>>        String sFileName
9044>>>>>        String sFullPathNames 
9044>>>>>        WString sFullPathName sShortPathName
9044>>>>>        Pointer lpsFilePart
9044>>>>>        Integer icChar // the number of characters returned
9044>>>>>        Integer iPos
9044>>>>>        
9044>>>>>        Move (Pos(";", sShortPathNames)) to iPos
9045>>>>>        While (length(sShortPathNames) >0)
9049>>>>>            If (iPos =0) Begin
9051>>>>>                Move sShortPathNames to sShortPathName
9052>>>>>                Move "" to sShortPathNames
9053>>>>>            End
9053>>>>>>
9053>>>>>            Else Begin // multiple paths
9054>>>>>                Move (Left(sShortPathNames, iPos -1)) to sShortPathName
9055>>>>>                Move (Right(sShortPathNames, length(sShortPathNames) -iPos)) to sShortPathNames // remove this path from the paths
9056>>>>>            End
9056>>>>>>
9056>>>>>            Move (Repeat(character(0), 4096)) to sFullPathName
9057>>>>>            Move -1 to lpsFilePart
9058>>>>>            Move (GetFullPathNameW(sShortPathName, 4096, AddressOf(sFullPathName), AddressOf(lpsFilePart))) to icChar
9059>>>>>            Append sFullPathNames (CString(sFullPathName))
9060>>>>>            If (sShortPathNames <>"") ;                Append sFullPathNames ";"
9063>>>>>            Move (Pos(";", sShortPathNames)) to iPos
9064>>>>>        Loop
9065>>>>>>
9065>>>>>        
9065>>>>>        Function_Return sFullPathNames
9066>>>>>    End_Function
9067>>>>>    
9067>>>>>    Function GetApplicationPath Returns String
9069>>>>>        // Returns the path of the Application (no trailing "\")
9069>>>>>        WString wApplicationFileName 
9069>>>>>        Boolean bRemoved
9069>>>>>        Integer iNumChars
9069>>>>>        String sFilename sPath
9069>>>>>        
9069>>>>>        Move (Repeat(Character(0), 1024)) to wApplicationFileName
9070>>>>>        Move (GetModuleFileNameW(0, AddressOf(wApplicationFileName), 1024)) to iNumChars
9071>>>>>        Move (CString(wApplicationFileName)) to wApplicationFileName
9072>>>>>        
9072>>>>>        Move (PathRemoveFileSpecW(AddressOf(wApplicationFileName))) to bRemoved
9073>>>>>        Move (CString(wApplicationFileName)) to sPath
9074>>>>>        
9074>>>>>        If (Right(sPath, 1) ="\") ;            Move (Left(sPath, Length(sPath) -1)) to sPath
9077>>>>>        Function_Return sPath
9078>>>>>    End_Function
9079>>>>>    
9079>>>>>    Procedure DoClearPaths
9081>>>>>        // Call this prior to changing from one WorkspAce to another
9081>>>>>        // if you don't, OpenWorkspaceFile will ignore the new paths.
9081>>>>>        Set psHome           to ""
9082>>>>>        Set psAppSrcPath     to ""
9083>>>>>        Set psBitmapPath     to ""
9084>>>>>        Set psDataPath       to ""
9085>>>>>        Set psDdSrcPath      to ""
9086>>>>>        Set psDescription    to ""
9087>>>>>        Set psFileList       to ""
9088>>>>>        Set psHelpPath       to ""
9089>>>>>        Set psIdeSrcPath     to ""
9090>>>>>        Set psAppHtmlPath    to ""
9091>>>>>        Set psProgramPath    to ""
9092>>>>>        Set psWorkspaceName  to ""
9093>>>>>        Set psSystemDfPath   to ""
9094>>>>>        Set psSystemMakePath to ""
9095>>>>>        Set psWorkspaceWSFile to ""
9096>>>>>        Set psConnectionIni to ""
9097>>>>>    End_Procedure
9098>>>>>    
9098>>>>>    Function OpenWorkspaceFile String sWorkspaceFile Returns Integer
9100>>>>>        WString wApplicationStartPath
9100>>>>>        String sWsName // name of Workspace is inferred from the Workspacefile name
9100>>>>>        Boolean bRemoved
9100>>>>>        Handle hoIniFile
9100>>>>>        Boolean bSuccess // call succeeded?
9100>>>>>        String sOldDirectory
9100>>>>>        String sSystemDfPath sSystemMakePath
9100>>>>>        Boolean bExist // does the WS file exist?
9100>>>>>        Boolean bChangingWorkspace
9100>>>>>        
9100>>>>>        String sHome sAppSrcPath sBitmapPath sDataPath sDdSrcPath sDescription sAppHtmlPath
9100>>>>>        String sFileList sHelpPath sIdeSrcPath sProgramPath sWorkspaceName sConnectionIni
9100>>>>>        
9100>>>>>        Set psWorkspaceWSFile to ""
9101>>>>>        If (sWorkspaceFile ="") ;            Function_Return wsWorkspaceFileNotFound
9104>>>>>        
9104>>>>>        // Append extension if not supplied...
9104>>>>>        If (Uppercase(Right(Trim(sWorkspaceFile),3)) <> ".WS") Begin
9106>>>>>            Move (sWorkspaceFile-".ws") to sWorkspaceFile
9107>>>>>        End
9107>>>>>>
9107>>>>>        
9107>>>>>        Get pbWorkspaceOpened to bChangingWorkspace // if we had an existing workspace. We are changing
9108>>>>>        
9108>>>>>        If (IsFilenameQualified(sWorkspaceFile) = False) Begin
9110>>>>>            // Set the properties to the paths of the Workspace
9110>>>>>            // Find the WS file (with program)...
9110>>>>>            Get GetApplicationPath to wApplicationStartPath
9111>>>>>            
9111>>>>>            Move sWorkspaceFile to sWsName
9112>>>>>            Move (wApplicationStartPath +"\" +sWorkspaceFile) to sWorkspaceFile
9113>>>>>        End
9113>>>>>>
9113>>>>>        Else Begin
9114>>>>>            Move (ExtractFileName(sWorkspaceFile)) to sWsName
9115>>>>>            
9115>>>>>            Move sWorkspaceFile to wApplicationStartPath
9116>>>>>            Move (PathRemoveFileSpecW(AddressOf(wApplicationStartPath))) to bRemoved
9117>>>>>        End
9117>>>>>>
9117>>>>>        
9117>>>>>        // Ensure that the file can be found...
9117>>>>>        //File_Exist (ToAnsi(sWorkspaceFile)) bExist        // [JVH] 8.3.8.0 Convert filename to Ansi
9117>>>>>        // [JVH] Turn off support for
9117>>>>>        // Ansi extended characters in workspace until we can
9117>>>>>        // resolve all open issues
9117>>>>>        Set psWorkspaceWSFile to sWorkspaceFile
9118>>>>>        File_Exist sWorkspaceFile bExist
9119>>>>>        If (bExist = False) ;            Function_Return wsWorkspaceFileNotFound
9122>>>>>        
9122>>>>>        Get psHome           to sHome
9123>>>>>        Get psAppSrcPath     to sAppSrcPath
9124>>>>>        Get psAppHtmlPath    to sAppHtmlPath
9125>>>>>        Get psBitmapPath     to sBitmapPath
9126>>>>>        Get psDataPath       to sDataPath
9127>>>>>        Get psDdSrcPath      to sDdSrcPath
9128>>>>>        Get psDescription    to sDescription
9129>>>>>        Get psFileList       to sFileList
9130>>>>>        Get psHelpPath       to sHelpPath
9131>>>>>        Get psIdeSrcPath     to sIdeSrcPath
9132>>>>>        Get psProgramPath    to sProgramPath
9133>>>>>        Get psSystemDfPath   to sSystemDfPath
9134>>>>>        Get psSystemMakePath to sSystemMakePath
9135>>>>>        Get psWorkspaceName  to sWorkspaceName
9136>>>>>        Get psConnectionIni to sConnectionIni
9137>>>>>        
9137>>>>>        Get_Current_Directory to sOldDirectory
9138>>>>>        // Note- this conversion is temporarily rolled back
9138>>>>>        //Move (SetCurrentDirectory(ToAnsi(CString(wApplicationStartPath)))) To bSuccess    // [JVH] 8.3.8.0 Convert AppStartPath to ANSI
9138>>>>>        Move (SetCurrentDirectory(CString(wApplicationStartPath))) to bSuccess
9139>>>>>        
9139>>>>>        Get Create U_cIniFile to hoIniFile
9140>>>>>        Set pbWideAPI of hoIniFile to False
9141>>>>>        Set psFilename of hoIniFile to sWorkspaceFile
9142>>>>>        
9142>>>>>        If (sHome ="") ;            Get ReadString of hoIniFile "Workspace" "Home" ""          to sHome
9145>>>>>        If (sAppSrcPath ="") ;            Get ReadString of hoIniFile "Workspace" "AppSrcPath" ""    to sAppSrcPath
9148>>>>>        If (sAppHtmlPath ="") ;            Get ReadString of hoIniFile "Workspace" "AppHtmlPath" ""   to sAppHtmlPath
9151>>>>>        If (sBitmapPath ="") ;            Get ReadString of hoIniFile "Workspace" "BitmapPath" ""    to sBitmapPath
9154>>>>>        If (sDataPath ="") ;            Get ReadString of hoIniFile "Workspace" "DataPath" ""      to sDataPath
9157>>>>>        If (sDdSrcPath ="") ;            Get ReadString of hoIniFile "Workspace" "DdSrcPath" ""     to sDdSrcPath
9160>>>>>        If (sDescription ="") ;            Get ReadString of hoIniFile "Workspace" "Description" ""   to sDescription
9163>>>>>        If (sFileList ="") ;            Get ReadString of hoIniFile "Workspace" "FileList" ""      to sFileList
9166>>>>>        If (sHelpPath ="") ;            Get ReadString of hoIniFile "Workspace" "HelpPath" ""      to sHelpPath
9169>>>>>        If (sIdeSrcPath ="") ;            Get ReadString of hoIniFile "Workspace" "IdeSrcPath" ""    to sIdeSrcPath
9172>>>>>        If (sProgramPath ="") ;            Get ReadString of hoIniFile "Workspace" "ProgramPath" ""   to sProgramPath
9175>>>>>        If (sWorkspaceName ="") ;            Move (Left(sWsName, Length(sWsName) -3))                   to sWorkspaceName
9178>>>>>        If (sConnectionIni ="") ;            Get ReadString of hoIniFile "Workspace" "ConnectionIni" ""   to sConnectionIni
9181>>>>>        
9181>>>>>        If (sSystemDfPath ="") ;            Set psSystemDfPath   to (VdfSystemDfPath(Self))
9184>>>>>        If (sSystemMakePath ="") ;            Set psSystemMakePath to (VdfSystemMakePath(Self))
9187>>>>>        
9187>>>>>        Set psHome          to (FullPathNames(Self, sHome))
9188>>>>>        
9188>>>>>        // Set CWD to Home...
9188>>>>>        Move (SetCurrentDirectory(sHome)) to bSuccess
9189>>>>>        Set psAppSrcPath    to (FullPathNames(Self, sAppSrcPath))
9190>>>>>        Set psAppHtmlPath   to (FullPathNames(Self, sAppHtmlPath))
9191>>>>>        Set psBitmapPath    to (FullPathNames(Self, sBitmapPath))
9192>>>>>        Set psDataPath      to (FullPathNames(Self, sDataPath))
9193>>>>>        Set psDdSrcPath     to (FullPathNames(Self, sDdSrcPath))
9194>>>>>        Set psFileList      to (FullPathNames(Self, sFileList))
9195>>>>>        Set psHelpPath      to (FullPathNames(Self, sHelpPath))
9196>>>>>        Set psIdeSrcPath    to (FullPathNames(Self, sIdeSrcPath))
9197>>>>>        Set psProgramPath   to (FullPathNames(Self, sProgramPath))
9198>>>>>        Set psConnectionIni to (FullPathNames(Self, sConnectionIni))
9199>>>>>        
9199>>>>>        Set psWorkspaceName to sWorkspaceName
9200>>>>>        Set psDescription   to sDescription
9201>>>>>        
9201>>>>>        Send Destroy of hoIniFile // destroy dynaically created inifile object
9202>>>>>        
9202>>>>>        // Restore CWD...
9202>>>>>        Move (SetCurrentDirectory(sOldDirectory)) to sOldDirectory
9203>>>>>        
9203>>>>>        // Check for error conditions:
9203>>>>>        // DataPath and FileList must be defined; the FileList entry must point to a valid FileList.cfg
9203>>>>>        If (psDataPath(Self) = "") ;            Function_Return wsDataPathEmpty
9206>>>>>        If (psFileList(Self) = "") ;            Function_Return wsFileListEmpty
9209>>>>>        
9209>>>>>        Move (DoesFileExist(psFileList(Self))) to bExist
9210>>>>>        If (bExist = False) ;            Function_Return wsFileListNotExist
9213>>>>>        
9213>>>>>        If bChangingWorkspace ;            Close DF_ALL // if there is a WS open, we must close all the files
9216>>>>>        
9216>>>>>        Send DoAssignPaths // set psDfPath
9217>>>>>        Send DoSetPaths    // Set the application's Attributes of Filelist_Name and Open_Path
9218>>>>>        Set pbWorkspaceOpened to True
9219>>>>>        
9219>>>>>        Function_Return wsWorkspaceOpened
9220>>>>>    End_Function
9221>>>>>    
9221>>>>>    Function OpenWorkspace String sWorkspace Returns Integer
9223>>>>>        // Look in the Workspaces.ini file for the name, then open it by path
9223>>>>>        
9223>>>>>        Handle hoSections hoIniFile
9223>>>>>        Integer iWorkspace eOpened
9223>>>>>        String sWorkspaceName sPath
9223>>>>>        String sVdfRootDir
9223>>>>>        
9223>>>>>        Get Create U_Array    to hoSections
9224>>>>>        Get Create U_cIniFile to hoIniFile
9225>>>>>        
9225>>>>>        Get_Profile_String "Defaults" "VdfRootDir" to sVdfRootDir
9228>>>>>        If (Right(sVdfRootDir,1) <>"\") ;            Move (sVdfRootDir +"\") to sVdfRootDir
9231>>>>>        
9231>>>>>        Set psFilename of hoIniFile to (sVdfRootDir +"bin\Workspaces.ini")
9232>>>>>        
9232>>>>>        Send ReadSections of hoIniFile hoSections
9233>>>>>        
9233>>>>>        For iWorkspace from 0 to (Item_Count(hoSections) -1)
9239>>>>>>
9239>>>>>            Get Value of hoSections iWorkspace to sWorkspaceName
9240>>>>>            If (Uppercase(sWorkspaceName) = Uppercase(sWorkspace)) Begin
9242>>>>>                Get ReadString of hoIniFile sWorkspace "Path" "" to sPath
9243>>>>>                If (Right(sPath,1) <>"\") ;                    Move (sPath +"\") to sPath
9246>>>>>                
9246>>>>>                Get OpenWorkspaceFile (sPath + sWorkspace) to eOpened
9247>>>>>                Send Destroy of hoSections
9248>>>>>                Send Destroy of hoIniFile
9249>>>>>                Function_Return eOpened
9250>>>>>            End
9250>>>>>>
9250>>>>>        Loop
9251>>>>>>
9251>>>>>        
9251>>>>>        Send Destroy of hoSections
9252>>>>>        Send Destroy of hoIniFile
9253>>>>>        Function_Return wsWorkspaceNotFound
9254>>>>>    End_Function
9255>>>>>    
9255>>>>>    Function IsRegistered String sWorkspace Returns Boolean
9257>>>>>        Boolean bRegistered
9257>>>>>        Handle hoIniFile
9257>>>>>        String sVdfRootDir
9257>>>>>        
9257>>>>>        Get Create U_cIniFile to hoIniFile
9258>>>>>        
9258>>>>>        Get_Profile_String "Defaults" "VdfRootDir" to sVdfRootDir
9261>>>>>        If (Right(sVdfRootDir,1) <>"\") ;            Move (sVdfRootDir +"\") to sVdfRootDir
9264>>>>>        Set psFilename of hoIniFile to (sVdfRootDir +"bin\Workspaces.ini")
9265>>>>>        Move (SectionExists(hoIniFile, sWorkspace)) to bRegistered
9266>>>>>        
9266>>>>>        Send Destroy of hoIniFile
9267>>>>>        
9267>>>>>        Function_Return bRegistered
9268>>>>>    End_Function
9269>>>>>    
9269>>>>>    Function VdfSystemDfPath Returns String
9271>>>>>        String sSystemDfPath
9271>>>>>        Get_Profile_String "Workspaces" "SystemDfPath" to sSystemDfPath
9274>>>>>        
9274>>>>>        Function_Return sSystemDfPath
9275>>>>>    End_Function
9276>>>>>    
9276>>>>>    Function VdfSystemMakePath Returns String
9278>>>>>        String sSystemMakePath
9278>>>>>        Get_Profile_String "Workspaces" "SystemMakePath" to sSystemMakePath
9281>>>>>        
9281>>>>>        Function_Return sSystemMakePath
9282>>>>>    End_Function
9283>>>>>    
9283>>>>>    Procedure DoAssignPaths
9285>>>>>        String sDataPath sBitmapPath sHelpPath sProgramPath sSystemDfPath
9285>>>>>        
9285>>>>>        Get psDataPath     to sDataPath
9286>>>>>        Get psBitmapPath   to sBitmapPath
9287>>>>>        Get psHelpPath     to sHelpPath
9288>>>>>        Get psProgramPath  to sProgramPath
9289>>>>>        Get psSystemDfPath to sSystemDfPath
9290>>>>>        
9290>>>>>        Set psDfPath to (sDataPath +';' + sBitmapPath +';' + sHelpPath +';' + sProgramPath +';' + sSystemDfPath)
9291>>>>>        
9291>>>>>    End_Procedure
9292>>>>>    
9292>>>>>    Procedure DoSetPaths
9294>>>>>        // [JVH] must convert paths to Ansi before setting these values
9294>>>>>        // Note- this conversion is temporarily rolled back
9294>>>>>        //Set_Attribute DF_FILELIST_NAME To (ToAnsi(psFileList(self)))
9294>>>>>        //Set_Attribute DF_OPEN_PATH     To (ToAnsi(psDfPath(self)))
9294>>>>>        Set_Attribute DF_FILELIST_NAME to (psFileList(Self))
9297>>>>>        Set_Attribute DF_OPEN_PATH     to (psDfPath(Self))
9300>>>>>    End_Procedure
9301>>>>>    
9301>>>>>    Procedure EnumerateWorkspaceData Handle hoCallBack Handle hmGeneric
9303>>>>>        String sPath
9303>>>>>        
9303>>>>>        If (psWorkspaceName(Self)="") ;            Send hmGeneric to hoCallBack C_$WorkspaceNotUsed
9306>>>>>        Else Begin
9307>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$WorkspaceDesc, psDescription(Self)))
9308>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$WorkspaceName, psWorkspaceName(Self)))
9309>>>>>            Send hmGeneric to hoCallBack ""
9310>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$Filelist, psFileList(Self)))
9311>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$DataPath, psDataPath(Self)))
9312>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$ProgramPath, psProgramPath(Self)))
9313>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$HelpPath, psHelpPath(Self)))
9314>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$BitmapsPath, psBitmapPath(Self)))
9315>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$SystemPaths, psSystemDfPath(Self)))
9316>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$FullDFPath, psDfPath(Self)))
9317>>>>>        End
9317>>>>>>
9317>>>>>    End_Procedure
9318>>>>>    
9318>>>>>    Function OpenWorkspaceErrorMessage Integer eErrorCode Returns String
9320>>>>>        // Decodes the enumerated integer returned by OpenWorkspace and
9320>>>>>        // returns a corresponding message string.
9320>>>>>        String sError
9320>>>>>        
9320>>>>>        Case Begin
9320>>>>>            Case (eErrorCode = wsWorkspaceOpened)
9322>>>>>                Move C_$NoErrors to sError
9323>>>>>                Case Break
9324>>>>>            Case (eErrorCode = wsWorkspaceNotFound)
9327>>>>>                Move C_$NoWsName to sError
9328>>>>>                Case Break
9329>>>>>            Case (eErrorCode = wsWorkspaceFileNotFound)
9332>>>>>                Move C_$NoWsFileFound to sError
9333>>>>>                Case Break
9334>>>>>            Case (eErrorCode = wsDataPathEmpty)
9337>>>>>                Move C_$NoWsDataPath to sError
9338>>>>>                Case Break
9339>>>>>            Case (eErrorCode = wsFileListEmpty)
9342>>>>>                Move C_$NoWsFileList to sError
9343>>>>>                Case Break
9344>>>>>            Case (eErrorCode = wsFileListNotExist)
9347>>>>>                Move C_$NoFileListCfg to sError
9348>>>>>                Case Break
9349>>>>>            Case Else
9349>>>>>                Move C_$UnknownError to sError
9350>>>>>                Case Break
9351>>>>>        Case End
9351>>>>>        
9351>>>>>        Function_Return (sError-".")
9352>>>>>    End_Function
9353>>>>>    
9353>>>>>    Function GetWorkspaceFileName String sWorkspace Returns String
9355>>>>>        // Returns the name of the physical Workspace file for the passed Workspace name.
9355>>>>>        String sVdfRootDir
9355>>>>>        Handle hoIniFile
9355>>>>>        String sPath
9355>>>>>        String sFileName
9355>>>>>        String sWorkspacePath
9355>>>>>        
9355>>>>>        Move "" to sFileName
9356>>>>>        
9356>>>>>        Get_Profile_String "Defaults" "VdfRootDir" to sVdfRootDir
9359>>>>>        If (Right(sVdfRootDir,1) <>"\") ;            Move (sVdfRootDir +"\") to sVdfRootDir
9362>>>>>        
9362>>>>>        Get Create U_cIniFile to hoIniFile
9363>>>>>        Set psFilename of hoIniFile to (sVdfRootDir +"bin\Workspaces.ini")
9364>>>>>        Get ReadString of hoIniFile sWorkspace "Path" "" to sWorkspacePath
9365>>>>>        If (sWorkspacePath <>"") Begin
9367>>>>>            If (Right(sWorkspacePath,1) <>"\") ;                Move (sWorkspacePath +"\") to sWorkspacePath
9370>>>>>            Move (sWorkspacePath +sWorkspace +".ws") to sFileName
9371>>>>>        End
9371>>>>>>
9371>>>>>        Send Destroy of hoIniFile
9372>>>>>        
9372>>>>>        Function_Return sFileName
9373>>>>>    End_Function
9374>>>>>    
9374>>>>>    Function CountOfPaths String sPaths Returns Integer
9376>>>>>        // Returns the number of paths defined in a string of paths
9376>>>>>        Integer iChar icChar icPath
9376>>>>>        
9376>>>>>        If (sPaths ="") ;            Function_Return 0
9379>>>>>        
9379>>>>>        Move (Length(sPaths) -1) to icChar
9380>>>>>        For iChar from 1 to icChar
9386>>>>>>
9386>>>>>            If (Mid(sPaths, 1, iChar) =";") ;                Increment icPath
9389>>>>>        Loop
9390>>>>>>
9390>>>>>        
9390>>>>>        Function_Return (icPath +1)
9391>>>>>    End_Function
9392>>>>>    
9392>>>>>    Function PathAtIndex String sPaths Integer iIndex Returns String
9394>>>>>        // Returns the path at the 1-based index of passed paths.
9394>>>>>        // If the path contains a trailing "\", it will be removed
9394>>>>>        Integer iChar icPath iPath iPos
9394>>>>>        String sPath
9394>>>>>        
9394>>>>>        Move (sPaths +";") to sPaths
9395>>>>>        For iPath from 1 to iIndex
9401>>>>>>
9401>>>>>            Move (Pos(";", sPaths)) to iPos
9402>>>>>            If iPos Begin
9404>>>>>                Move (Left(sPaths, iPos -1)) to sPath
9405>>>>>                If (Right(sPath,1) = '\') ;                    Move (Left(sPath, Length(sPath) -1)) to sPath
9408>>>>>                Move (Right(sPaths, Length(sPaths) -iPos)) to sPaths
9409>>>>>            End
9409>>>>>>
9409>>>>>            Else ;                Function_Return "" // index past number of paths
9411>>>>>        Loop
9412>>>>>>
9412>>>>>        
9412>>>>>        Function_Return sPath
9413>>>>>    End_Function
9414>>>>>    
9414>>>>>End_Class
9415>>>Use cCommandLine.pkg
Including file: cCommandLine.pkg    (C:\Program Files\DataFlex 26.0\Pkg\cCommandLine.pkg)
9415>>>>>Use VDFBase.pkg
9415>>>>>
9415>>>>>Class cCommandLine is a cObject
9416>>>>>    
9416>>>>>    Procedure Construct_Object
9418>>>>>        Forward Send Construct_Object
9420>>>>>        
9420>>>>>        Property Handle phoArgs // private object-handle of internal array of arguments
9421>>>>>    End_Procedure
9422>>>>>    
9422>>>>>    Procedure Private_DoCreateArgsArray
9424>>>>>        // creates the array for holding the arguments. Created upon demand only!
9424>>>>>        Integer icArg
9424>>>>>        String sArg
9424>>>>>        
9424>>>>>        Object oArgs is an Array
9426>>>>>            Delegate Set phoArgs to Self
9428>>>>>            Repeat
9428>>>>>>
9428>>>>>                CmdLine sArg
9429>>>>>>
9429>>>>>                If (sArg <> "") Begin
9431>>>>>                    Increment icArg
9432>>>>>                    Set Value  (icArg -1) to sArg
9433>>>>>                End
9433>>>>>>
9433>>>>>            Until (sArg = "")
9435>>>>>        End_Object
9436>>>>>    End_Procedure
9437>>>>>    
9437>>>>>    Function CountOfArgs Returns Integer
9439>>>>>        //Returns the number of arguments passed
9439>>>>>        If (phoArgs(Self) =0) ;            Send Private_DoCreateArgsArray
9442>>>>>        Function_Return (Item_Count(phoArgs(Self)))
9443>>>>>    End_Function
9444>>>>>    
9444>>>>>    Function Argument Integer iIndex Returns String
9446>>>>>        //Returns the one-based argument string
9446>>>>>        If (phoArgs(Self) =0) ;            Send Private_DoCreateArgsArray
9449>>>>>        Function_Return (Value(phoArgs(Self), iIndex -1))
9450>>>>>    End_Function
9451>>>>>    
9451>>>>>End_Class
9452>>>>>
9452>>>Use cRegistry.pkg
Including file: cRegistry.pkg    (C:\Program Files\DataFlex 26.0\Pkg\cRegistry.pkg)
9452>>>>>Use Dll.pkg
9452>>>>>Use RegistryAPI.pkg
9452>>>>>Use tWinStructs.pkg
9452>>>>>
9452>>>>>Enum_List // Registry Data types
9452>>>>>    Define rdString
9452>>>>>    Define rdDword
9452>>>>>    Define rdBinary
9452>>>>>    Define rdUnknown
9452>>>>>End_Enum_List
9452>>>>>
9452>>>>>
9452>>>>>Class cRegistry is a cObject
9453>>>>>    Procedure Construct_Object
9455>>>>>        Forward Send Construct_Object
9457>>>>>        
9457>>>>>        Property Handle phRootKey HKEY_CURRENT_USER
9458>>>>>        Property UInteger pfAccessRights  KEY_ALL_ACCESS // what access level should be used to open a Key?
9459>>>>>        Property Handle phCurrentKey
9460>>>>>        Property Boolean pbLazyWrite True
9461>>>>>    End_Procedure
9462>>>>>    
9462>>>>>    Function CountOfSubkeys Returns Integer
9464>>>>>        Integer dwCountOfSubkeys
9464>>>>>        Integer iError
9464>>>>>        String sError
9464>>>>>        
9464>>>>>        Move 0 to dwCountOfSubkeys
9465>>>>>        Move (RegQueryInfoKeyW(phCurrentKey(Self), 0, 0, 0, AddressOf(dwCountOfSubkeys), 0, 0, 0, 0, 0, 0, 0)) to iError
9466>>>>>        If iError Begin
9468>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9469>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9470>>>>>>
9470>>>>>        End
9470>>>>>>
9470>>>>>        Function_Return dwCountOfSubkeys
9471>>>>>    End_Function
9472>>>>>    
9472>>>>>    Function CountOfValues Returns Integer
9474>>>>>        Integer dwCountOfValues
9474>>>>>        Integer iError
9474>>>>>        String sError
9474>>>>>        
9474>>>>>        Move 0 to dwCountOfValues
9475>>>>>        Move (RegQueryInfoKeyW(phCurrentKey(Self), 0, 0, 0, 0, 0, 0, AddressOf(dwCountOfValues), 0, 0, 0, 0)) to iError
9476>>>>>        If iError Begin
9478>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9479>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9480>>>>>>
9480>>>>>        End
9480>>>>>>
9480>>>>>        
9480>>>>>        Function_Return dwCountOfValues
9481>>>>>    End_Function
9482>>>>>    
9482>>>>>    Function LongestSubkeyLength Returns Integer
9484>>>>>        Integer dwLongestSubkeyLength
9484>>>>>        Integer iError
9484>>>>>        String sError
9484>>>>>        
9484>>>>>        Move 0 to dwLongestSubkeyLength
9485>>>>>        Move (RegQueryInfoKeyW(phCurrentKey(Self), 0, 0, 0, 0, AddressOf(dwLongestSubkeyLength), 0, 0, 0, 0, 0, 0)) to iError
9486>>>>>        If iError Begin
9488>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9489>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9490>>>>>>
9490>>>>>        End
9490>>>>>>
9490>>>>>        
9490>>>>>        Function_Return dwLongestSubkeyLength
9491>>>>>    End_Function
9492>>>>>    
9492>>>>>    Function LongestValueLength Returns Integer
9494>>>>>        Integer dwLongestValueLength
9494>>>>>        Integer iError
9494>>>>>        String sError
9494>>>>>        
9494>>>>>        Move 0 to dwLongestValueLength
9495>>>>>        Move (RegQueryInfoKeyW(phCurrentKey(Self), 0, 0, 0, 0, 0, 0, 0, AddressOf(dwLongestValueLength), 0, 0, 0)) to iError
9496>>>>>        If iError Begin
9498>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9499>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9500>>>>>>
9500>>>>>        End
9500>>>>>>
9500>>>>>        
9500>>>>>        Function_Return dwLongestValueLength
9501>>>>>    End_Function
9502>>>>>    
9502>>>>>    Function LongestDataLength Returns Integer
9504>>>>>        Integer dwLongestDataLength
9504>>>>>        Integer iError
9504>>>>>        String sError
9504>>>>>        
9504>>>>>        Move 0 to dwLongestDataLength
9505>>>>>        Move (RegQueryInfoKeyW(phCurrentKey(Self), 0, 0, 0, 0, 0, 0, 0, 0, AddressOf(dwLongestDataLength), 0, 0)) to iError
9506>>>>>        If iError Begin
9508>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9509>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9510>>>>>>
9510>>>>>        End
9510>>>>>>
9510>>>>>        
9510>>>>>        Function_Return dwLongestDataLength
9511>>>>>    End_Function
9512>>>>>    
9512>>>>>    Function ValueType String sValueName Returns Integer
9514>>>>>        Integer dwType
9514>>>>>        Integer iError eType
9514>>>>>        String sError
9514>>>>>        
9514>>>>>        Move 0 to dwType
9515>>>>>        Move (RegQueryValueExW(phCurrentKey(Self), sValueName, 0, AddressOf(dwType), 0, 0)) to iError
9516>>>>>        If iError Begin
9518>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9519>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9520>>>>>>
9520>>>>>        End
9520>>>>>>
9520>>>>>        
9520>>>>>        If (dwType = REG_SZ) ;            Move rdString to eType
9523>>>>>        Else If (dwType = REG_DWORD)  ;            Move rdDword to eType
9527>>>>>        Else If (dwType = REG_BINARY) ;            Move rdBinary to eType
9531>>>>>        Else ;            Move rdUnknown to eType
9533>>>>>        
9533>>>>>        Function_Return eType
9534>>>>>    End_Function
9535>>>>>    
9535>>>>>    Function ValueLength String sValueName Returns Integer
9537>>>>>        Integer dwSize
9537>>>>>        Integer iError
9537>>>>>        String sError
9537>>>>>        
9537>>>>>        Move 0 to dwSize
9538>>>>>        Move (RegQueryValueExW(phCurrentKey(Self), sValueName, 0, 0, 0, AddressOf(dwSize))) to iError
9539>>>>>        If iError Begin
9541>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9542>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9543>>>>>>
9543>>>>>        End
9543>>>>>>
9543>>>>>        
9543>>>>>        Function_Return dwSize
9544>>>>>    End_Function
9545>>>>>    
9545>>>>>    Function CreateKey String sKeyName Returns Integer // return=error code
9547>>>>>        // Calling CreateKey for an existing Key, merely opens it without error.
9547>>>>>        Handle hKey hKeyOpened
9547>>>>>        Integer iError
9547>>>>>        String sError
9547>>>>>        
9547>>>>>        Move 0 to hKeyOpened // initialize it so we can get its address
9548>>>>>        
9548>>>>>        Get phRootKey to hKey
9549>>>>>        
9549>>>>>        Move (RegCreateKeyEx(hKey, sKeyName, 0, 0, REG_OPTION_NON_VOLATILE, pfAccessRights(Self), 0, AddressOf(hKeyOpened), 0)) to iError
9550>>>>>        If (iError =0) ;            Set phCurrentKey to hKeyOpened
9553>>>>>        Else Begin
9554>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9555>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9556>>>>>>
9556>>>>>        End
9556>>>>>>
9556>>>>>        Function_Return iError
9557>>>>>    End_Function
9558>>>>>    
9558>>>>>    Procedure CloseKey
9560>>>>>        Integer iError
9560>>>>>        Handle hKey
9560>>>>>        
9560>>>>>        Get phCurrentKey to hKey
9561>>>>>        
9561>>>>>        If (hKey <>0) Begin
9563>>>>>            If (pbLazyWrite(Self)) ;                Move (RegCloseKey(hKey)) to iError
9566>>>>>            Else ;                Move (RegFlushKey(hKey)) to iError
9568>>>>>            
9568>>>>>            Set phCurrentKey to 0
9569>>>>>        End
9569>>>>>>
9569>>>>>    End_Procedure
9570>>>>>    
9570>>>>>    Function OpenKey String sKeyName Returns Boolean
9572>>>>>        Handle hKey hKeyOpened
9572>>>>>        Integer iError
9572>>>>>        
9572>>>>>        Move 0 to hKeyOpened // initialize it so we can get its address
9573>>>>>        
9573>>>>>        Get phRootKey to hKey
9574>>>>>        Move (RegOpenKeyEx(hKey, sKeyName, 0, pfAccessRights(Self), AddressOf(hKeyOpened))) to iError
9575>>>>>        If (iError =0) ;            Set phCurrentKey to hKeyOpened
9578>>>>>        
9578>>>>>        Function_Return (iError=0)
9579>>>>>    End_Function
9580>>>>>    
9580>>>>>    Procedure WriteInteger WString sValue Integer iValueData
9582>>>>>        Handle hKey
9582>>>>>        Integer iError
9582>>>>>        Integer iData
9582>>>>>        String sError
9582>>>>>        
9582>>>>>        Move iValueData to iData
9583>>>>>        Get phCurrentKey to hKey
9584>>>>>        Move (RegSetValueExW(hKey, sValue, 0, REG_DWORD, AddressOf(iData), SizeOfType(Integer))) to iError
9585>>>>>        If iError Begin
9587>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9588>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9589>>>>>>
9589>>>>>        End
9589>>>>>>
9589>>>>>    End_Procedure
9590>>>>>    
9590>>>>>    // WriteDword is obsolete. Please use WriteInteger or WriteUInt, depending on whether you use a signed or unsigned value.
9590>>>>>    Procedure WriteDword String sValue Integer iValueData
9592>>>>>        Send WriteInteger of Self sValue iValueData
9593>>>>>    End_Procedure
9594>>>>>    
9594>>>>>    Procedure WriteUInt WString sValue UInteger uValueData
9596>>>>>        Handle hKey
9596>>>>>        Integer iError
9596>>>>>        UInteger uData
9596>>>>>        String sError
9596>>>>>        
9596>>>>>        Move uValueData to uData
9597>>>>>        Get phCurrentKey to hKey
9598>>>>>        Move (RegSetValueExW(hKey, sValue, 0, REG_DWORD, AddressOf(uData), SizeOfType(UInteger))) to iError
9599>>>>>        If iError Begin
9601>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9602>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9603>>>>>>
9603>>>>>        End
9603>>>>>>
9603>>>>>    End_Procedure
9604>>>>>
9604>>>>>    Procedure WriteString WString sValue WString wValueData
9606>>>>>        Handle hKey
9606>>>>>        Integer iError cbData
9606>>>>>        String sError
9606>>>>>        
9606>>>>>        If (wValueData = "") Begin
9608>>>>>            Move (Character(0)) to wValueData
9609>>>>>            Move 1 to cbData
9610>>>>>        End
9610>>>>>>
9610>>>>>        Else Begin
9611>>>>>            Move ((SizeOfWString(wValueData) +1)*2) to cbData
9612>>>>>        End
9612>>>>>>
9612>>>>>        Get phCurrentKey to hKey
9613>>>>>        Move (RegSetValueExW(hKey, sValue, 0, REG_SZ, AddressOf(wValueData), cbData)) to iError
9614>>>>>        If iError Begin
9616>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9617>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9618>>>>>>
9618>>>>>        End
9618>>>>>>
9618>>>>>    End_Procedure
9619>>>>>    
9619>>>>>    Procedure WriteBinary WString sValue Pointer pValueData Integer iDataLength
9621>>>>>        Handle hKey
9621>>>>>        Integer iError
9621>>>>>        String sError
9621>>>>>        
9621>>>>>        Get phCurrentKey to hKey
9622>>>>>        Move (RegSetValueExw(hKey, sValue, 0, REG_BINARY, pValueData, iDataLength)) to iError
9623>>>>>        If iError Begin
9625>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9626>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9627>>>>>>
9627>>>>>        End
9627>>>>>>
9627>>>>>    End_Procedure
9628>>>>>    
9628>>>>>    Function ReadInteger WString sValueName Returns Integer
9630>>>>>        Handle hKey
9630>>>>>        Integer iError
9630>>>>>        Integer iValueData iValueDataLength
9630>>>>>        String sError
9630>>>>>        
9630>>>>>        Move 0           to iValueData
9631>>>>>        Move (SizeOfType(Integer)) to iValueDataLength
9632>>>>>        
9632>>>>>        Get phCurrentKey to hKey
9633>>>>>        Move (RegQueryValueExW(hKey, sValueName, 0, 0, AddressOf(iValueData), AddressOf(iValueDataLength))) to iError
9634>>>>>        If iError Begin
9636>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9637>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9638>>>>>>
9638>>>>>        End
9638>>>>>>
9638>>>>>        
9638>>>>>        Function_Return iValueData
9639>>>>>    End_Function
9640>>>>>    
9640>>>>>    // ReadDword is obsolete. Please use ReadInteger or ReadUInt, depending on whether you expect a signed or unsigned value.
9640>>>>>    Function ReadDword String sValueName Returns Integer
9642>>>>>        Function_Return (ReadInteger(Self, sValueName))
9643>>>>>    End_Function
9644>>>>>
9644>>>>>    Function ReadUInt WString sValueName Returns UInteger
9646>>>>>        Handle hKey
9646>>>>>        Integer iError
9646>>>>>        UInteger uValueData uValueDataLength
9646>>>>>        String sError
9646>>>>>        
9646>>>>>        Move 0           to uValueData
9647>>>>>        Move (SizeOfType(UInteger)) to uValueDataLength
9648>>>>>        
9648>>>>>        Get phCurrentKey to hKey
9649>>>>>        Move (RegQueryValueExW(hKey, sValueName, 0, 0, AddressOf(uValueData), AddressOf(uValueDataLength))) to iError
9650>>>>>        If iError Begin
9652>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9653>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9654>>>>>>
9654>>>>>        End
9654>>>>>>
9654>>>>>        
9654>>>>>        Function_Return uValueData
9655>>>>>    End_Function
9656>>>>>    
9656>>>>>    Function ReadString String sValueName Returns String
9658>>>>>        Handle hKey
9658>>>>>        Integer iError
9658>>>>>        WString wValueData
9658>>>>>        DWord dwValueDataLength dwType
9658>>>>>        Pointer lpsValueData
9658>>>>>        String sError
9658>>>>>        
9658>>>>>        Move (Repeat(character(0), ValueLength(Self, sValueName))) to wValueData
9659>>>>>        Move (AddressOf(wValueData)) to lpsValueData
9660>>>>>        
9660>>>>>        Move (SizeOfWString(wValueData)) to dwValueDataLength
9661>>>>>        
9661>>>>>        Move REG_SZ to dwType
9662>>>>>        
9662>>>>>        Get phCurrentKey to hKey
9663>>>>>        Move (RegQueryValueExW(hKey, sValueName, 0, (AddressOf(dwType)), lpsValueData, AddressOf(dwValueDataLength))) to iError
9664>>>>>        If iError Begin
9666>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9667>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9668>>>>>>
9668>>>>>        End
9668>>>>>>
9668>>>>>        
9668>>>>>        Function_Return (CString(wValueData))
9669>>>>>    End_Function
9670>>>>>    
9670>>>>>    Function ReadBinary String sValueName Pointer pValueData Integer iDataLength Returns Boolean
9672>>>>>        Handle hKey
9672>>>>>        Integer iError
9672>>>>>        String sError
9672>>>>>        
9672>>>>>        Get phCurrentKey to hKey
9673>>>>>        Move (RegQueryValueExW(hKey, sValueName, 0, 0, pValueData, AddressOf(iDataLength))) to iError
9674>>>>>        If iError Begin
9676>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
9677>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
9678>>>>>>
9678>>>>>        End
9678>>>>>>
9678>>>>>        
9678>>>>>        Function_Return (iDataLength >0)
9679>>>>>    End_Function
9680>>>>>    
9680>>>>>    
9680>>>>>    // Private....
9680>>>>>    Function GetBaseKey Returns Handle
9682>>>>>        Handle hBaseKey
9682>>>>>        If (phCurrentKey(Self) = 0) ;            Get phRootKey to hBaseKey
9685>>>>>        Else ;            Get phCurrentKey to hBaseKey
9687>>>>>        
9687>>>>>        Function_Return hBaseKey
9688>>>>>    End_Function
9689>>>>>    
9689>>>>>    Function GetKey String sKeyName Returns Handle
9691>>>>>        Handle hKeyOpened
9691>>>>>        Integer iError
9691>>>>>        
9691>>>>>        Move 0 to hKeyOpened // initialize so we can get its address
9692>>>>>        
9692>>>>>        Move (RegOpenKeyEx(GetBaseKey(Self), sKeyName, 0, pfAccessRights(Self), AddressOf(hKeyOpened))) to iError
9693>>>>>        
9693>>>>>        If (iError =0) ;            Function_Return hKeyOpened
9696>>>>>        Else ;            Function_Return 0
9698>>>>>    End_Function
9699>>>>>    
9699>>>>>    // Public
9699>>>>>    Function KeyExists String sKeyName Returns Boolean
9701>>>>>        Handle hKey
9701>>>>>        Integer iVoid
9701>>>>>        
9701>>>>>        If (Trim(sKeyName) = "") ;            Function_Return False
9704>>>>>        
9704>>>>>        Get GetKey sKeyName to hKey
9705>>>>>        If hKey ;            Move (RegCloseKey(hKey)) to iVoid
9708>>>>>        Function_Return (hKey <>0)
9709>>>>>    End_Function
9710>>>>>    
9710>>>>>    Function ValueExists String sValueName Returns Boolean
9712>>>>>        // Determines whether a Value exists for the currently-opened Key.
9712>>>>>        Integer iError
9712>>>>>        DWord dwDataType
9712>>>>>        Move 0 to dwDataType // must initialize the variable to get its address
9713>>>>>        
9713>>>>>        Move (RegQueryValueExW(phCurrentKey(Self), sValueName, 0, AddressOf(dwDataType), 0, 0)) to iError
9714>>>>>        
9714>>>>>        Function_Return (iError=0)
9715>>>>>    End_Function
9716>>>>>    
9716>>>>>    Function DeleteKey String sKeyName Returns Boolean // Deleted successfully?
9718>>>>>        
9718>>>>>            If (Trim(sKeyName) = "") ;            Function_Return False
9721>>>>>        
9721>>>>>        Function_Return (ShDeleteKey(phRootKey(Self), sKeyName) =0)
9722>>>>>    End_Function
9723>>>>>    
9723>>>>>    Function DeleteValue String sValueName Returns Boolean // Deleted successfully?
9725>>>>>        Function_Return (RegDeleteValue(phCurrentKey(Self), sValueName) =0)
9726>>>>>    End_Function
9727>>>>>    
9727>>>>>    Function Subkeys Returns String[]
9729>>>>>        Integer iError
9729>>>>>        Integer icValue iLongestSubkey
9729>>>>>        Handle hKey
9729>>>>>        DWord dwSubkeyNameLength
9729>>>>>        String sSubkeyName sFileTime
9729>>>>>        Pointer lpsSubkeyName
9729>>>>>        String[] aResult
9730>>>>>        tWinFileTime fileTime
9730>>>>>        tWinFileTime fileTime
9730>>>>>
9730>>>>>        Get LongestSubkeyLength to iLongestSubkey
9731>>>>>        Move (Repeat(character(0), iLongestSubkey +1)) to sSubkeyName
9732>>>>>        Move (AddressOf(sSubkeyName)) to lpsSubkeyName
9733>>>>>
9733>>>>>        Get phCurrentKey to hKey
9734>>>>>        Repeat
9734>>>>>>
9734>>>>>            Move (iLongestSubkey +1) to dwSubkeyNameLength
9735>>>>>
9735>>>>>            Move (RegEnumKeyEx(hKey, icValue, lpsSubkeyName, AddressOf(dwSubkeyNameLength), 0, 0, 0, AddressOf(fileTime))) to iError
9736>>>>>            If (iError =0) Begin
9738>>>>>                Move (CString(sSubkeyName)) to aResult[icValue]
9739>>>>>                Increment icValue
9740>>>>>            End
9740>>>>>>
9740>>>>>        Until (iError)
9742>>>>>        Function_Return aResult
9743>>>>>    End_Function
9744>>>>>    
9744>>>>>    Function GetSubkeys Handle hoArray Returns Integer // count of Values
9746>>>>>        Integer iError
9746>>>>>        Integer icValue iLongestSubkey
9746>>>>>        Handle hKey
9746>>>>>        DWord dwSubkeyNameLength
9746>>>>>        WString wSubkeyName
9746>>>>>        tWinFileTime FileTime
9746>>>>>        tWinFileTime FileTime
9746>>>>>        
9746>>>>>        Get LongestSubkeyLength to iLongestSubkey
9747>>>>>        Move (Repeat(character(0), iLongestSubkey +1)) to wSubkeyName
9748>>>>>        
9748>>>>>        Get phCurrentKey to hKey
9749>>>>>        Repeat
9749>>>>>>
9749>>>>>            Move (iLongestSubkey +1) to dwSubkeyNameLength
9750>>>>>            
9750>>>>>            Move (RegEnumKeyExW(hKey, icValue, AddressOf(wSubkeyName), AddressOf(dwSubkeyNameLength), 0, 0, 0, AddressOf(FileTime))) to iError
9751>>>>>            If (iError =0) Begin
9753>>>>>                Increment icValue
9754>>>>>                Set Value of hoArray (Item_Count(hoArray)) to (CString(wSubkeyName))
9755>>>>>            End
9755>>>>>>
9755>>>>>        Until (iError)
9757>>>>>        Function_Return icValue
9758>>>>>        
9758>>>>>    End_Function
9759>>>>>    
9759>>>>>    Function GetValues Handle hoArray Returns Integer // count of Values
9761>>>>>        Integer iError
9761>>>>>        Integer icValue iLongestValue
9761>>>>>        Handle hKey
9761>>>>>        DWord dwValueNameLength
9761>>>>>        WString wValueName 
9761>>>>>        String sValueNameSize
9761>>>>>        Pointer lpsValueName
9761>>>>>        
9761>>>>>        Get LongestValueLength to iLongestValue
9762>>>>>        Move (Repeat(character(0), iLongestValue +1)) to wValueName
9763>>>>>        Move (AddressOf(wValueName)) to lpsValueName
9764>>>>>        
9764>>>>>        Get phCurrentKey to hKey
9765>>>>>        Repeat
9765>>>>>>
9765>>>>>            Move (iLongestValue +1) to dwValueNameLength
9766>>>>>            Move (RegEnumValueW(hKey, icValue, lpsValueName, AddressOf(dwValueNameLength), 0, 0, 0, 0)) to iError
9767>>>>>            If (iError =0) Begin
9769>>>>>                Increment icValue
9770>>>>>                Set Value of hoArray (Item_Count(hoArray)) to (CString(wValueName))
9771>>>>>            End
9771>>>>>>
9771>>>>>        Until (iError)
9773>>>>>        Function_Return icValue
9774>>>>>        
9774>>>>>    End_Function
9775>>>>>    
9775>>>>>End_Class
9776>>>Use cVersionInfo.pkg
Including file: cVersionInfo.pkg    (C:\Program Files\DataFlex 26.0\Pkg\cVersionInfo.pkg)
9776>>>>>Use VdfBase.pkg
9776>>>>>Use DLL.pkg
9776>>>>>Use tWinStructs.pkg
9776>>>>>Use WinKern.pkg
9776>>>>>
9776>>>>>Define VS_FF_DEBUG         for |CI$00000001
9776>>>>>Define VS_FF_PRERELEASE    for |CI$00000002
9776>>>>>Define VS_FF_PATCHED       for |CI$00000004
9776>>>>>Define VS_FF_PRIVATEBUILD  for |CI$00000008
9776>>>>>Define VS_FF_INFOINFERRED  for |CI$00000010
9776>>>>>Define VS_FF_SPECIALBUILD  for |CI$00000020
9776>>>>>
9776>>>>>// Note: String pointer lpFilename must refer to WString type.
9776>>>>>External_Function GetFileVersionInfoSizeW "GetFileVersionInfoSizeW" version.dll ;    Pointer lpFilename ;    Pointer lpdwHandle ;    Returns DWord
9777>>>>>    
9777>>>>>// Wrapper Function GetFileVersionInfoSize (when using strings)
9777>>>>>Function GetFileVersionInfoSize Global ;    Pointer aFilename ;    Pointer lpdwHandle ;    Returns DWord
9779>>>>>    
9779>>>>>    DWord  dwResult
9779>>>>>    UWide  uwFileName
9779>>>>>    UWide  uwFileName
9779>>>>>
9779>>>>>    Send StringToWide aFilename (&uwFileName)
9780>>>>>    
9780>>>>>    Move (GetFileVersionInfoSizeW (uwFileName.lpUText, lpdwHandle)) to dwResult        
9781>>>>>    Function_Return dwResult
9782>>>>>End_Function
9783>>>>>
9783>>>>>// Note: String pointers should be referring to WString items.
9783>>>>>External_Function GetFileVersionInfoW "GetFileVersionInfoW" version.dll ;    Pointer lpFilename ;    DWord   dwHandle ;    DWord   dwLen ;    Pointer lpData ;    Returns Integer
9784>>>>>    
9784>>>>>// Wrapper Function GetFileVersionInfo (when using strings)
9784>>>>>Function GetFileVersionInfo Global ;    Pointer aFilename ;    DWord   dwHandle ;    DWord   dwLen ;    Pointer pData ;    Returns Integer
9786>>>>>    
9786>>>>>    Integer iResult
9786>>>>>    UWide   uwFileName
9786>>>>>    UWide   uwFileName
9786>>>>>
9786>>>>>    Send StringToWide aFilename (&uwFileName)
9787>>>>>    
9787>>>>>    Move (GetFileVersionInfoW (uwFileName.lpUText, dwHandle, dwLen, pData)) to iResult
9788>>>>>    Function_Return iResult
9789>>>>>End_Function    
9790>>>>>
9790>>>>>// Note: String pointers should be referring to WString items.
9790>>>>>External_Function VerQueryValueW "VerQueryValueW" version.dll ;    Pointer pBlock ;    Pointer pSubBlock ;    Pointer paBuffer ;    Pointer puLen ;    Returns Integer
9791>>>>>
9791>>>>>// Wrapper Function VerQueryValue (when using strings)
9791>>>>>Function VerQueryValue Global ;    Pointer pBlock ;    Pointer pSubBlock ;    Pointer paBuffer ;    Pointer puLen ;    Returns Integer
9793>>>>>    
9793>>>>>    Integer iResult
9793>>>>>    UWide   uwSubBlock
9793>>>>>    UWide   uwSubBlock
9793>>>>>    
9793>>>>>    Send StringToWide pSubBlock (&uwSubBlock)
9794>>>>>    
9794>>>>>    Move (VerQueryValueW (pBlock, uwSubBlock.lpUText, paBuffer, puLen)) to iResult        
9795>>>>>    
9795>>>>>    Function_Return iResult
9796>>>>>End_Function
9797>>>>>
9797>>>>>
9797>>>>>Class cVersionInfo is a cObject
9798>>>>>    Procedure Construct_Object
9800>>>>>        Forward Send Construct_Object
9802>>>>>        
9802>>>>>        
9802>>>>>        Property Integer piVersionMajor
9803>>>>>        Property Integer piVersionMinor
9804>>>>>        Property Integer piVersionRelease
9805>>>>>        Property Integer piVersionBuild
9806>>>>>        
9806>>>>>        Property Boolean pbIncluded
9807>>>>>        Property Boolean pbSpecialBuild
9808>>>>>        Property Boolean pbPrivateBuild
9809>>>>>        
9809>>>>>    End_Procedure
9810>>>>>    
9810>>>>>    Procedure DoCreate WString sFileName
9812>>>>>        DWord dwHandle
9812>>>>>        Integer iInfoSize iVerSize iSuccess iVersion iVoid iFlags
9812>>>>>        WString sData
9812>>>>>        tWinVs_FixedFileInfo VsFixedFileInfo
9812>>>>>        tWinVs_FixedFileInfo VsFixedFileInfo
9812>>>>>        WString sSubBlock
9812>>>>>        Pointer pVsFixedFileInfo
9812>>>>>        
9812>>>>>        Move 0 to pVsFixedFileInfo
9813>>>>>        Move 0 to dwHandle
9814>>>>>        Move 0 to iVerSize
9815>>>>>        
9815>>>>>        Move (GetFileVersionInfoSizeW(AddressOf(sFilename), AddressOf(dwHandle))) to iInfoSize
9816>>>>>        Set pbIncluded to (iInfoSize <>0)
9817>>>>>        
9817>>>>>        If (pbIncluded(Self)) Begin
9819>>>>>            Move (Repeat(Character(0), iInfoSize)) to sData
9820>>>>>            Move (GetFileVersionInfoW(AddressOf(sFilename), 0, iInfoSize, AddressOf(sData))) to iSuccess
9821>>>>>            
9821>>>>>            If (iSuccess <>0) Begin
9823>>>>>                Move "\" to sSubBlock
9824>>>>>                If (VerQueryValueW(AddressOf(sData), AddressOf(sSubBlock), AddressOf(pVsFixedFileInfo), AddressOf(iVerSize))) Begin
9826>>>>>                    Move (memcopy(AddressOf(VsFixedFileInfo), pVsFixedFileInfo, iVerSize)) to iVoid // copy the structure
9827>>>>>                    
9827>>>>>                    Move VsFixedFileInfo.dwFileVersionMS to iVersion
9828>>>>>                    Set piVersionMajor to (Hi(iVersion))
9829>>>>>                    Set piVersionMinor to (Low(iVersion))
9830>>>>>                    
9830>>>>>                    Move VsFixedFileInfo.dwFileVersionLS to iVersion
9831>>>>>                    Set piVersionRelease to (Hi(iVersion))
9832>>>>>                    Set piVersionBuild   to (Low(iVersion))
9833>>>>>                    
9833>>>>>                    Move VsFixedFileInfo.dwFileFlags to iFlags
9834>>>>>                    Set pbSpecialBuild    to (iFlags iand VS_FF_SPECIALBUILD)
9835>>>>>                    Set pbPrivateBuild    to (iFlags iand VS_FF_PRIVATEBUILD)
9836>>>>>                End
9836>>>>>>
9836>>>>>            End
9836>>>>>>
9836>>>>>            
9836>>>>>        End
9836>>>>>>
9836>>>>>    End_Procedure
9837>>>>>    
9837>>>>>End_Class
9838>>>Use GlobalFunctionsProcedures.pkg
9838>>>Use tWinStructs.pkg
9838>>>Use HelpSystemConstants.pkg // constants used by help system (not used by web)
9838>>>
9838>>>Register_Function phoWorkspace Returns Handle
9838>>>Register_Function phoCommandLine Returns Handle
9838>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
9838>>>Register_Function GetApplicationName Returns String
9838>>>Register_Function GetApplicationFileName Returns String
9838>>>
9838>>>Register_Function Statusbar_State Returns Integer
9838>>>Register_Function Toolbar_State Returns Integer
9838>>>Register_Procedure Set Statusbar_State
9838>>>Register_Procedure Set Toolbar_State
9838>>>
9838>>>
9838>>>Class cApplication is a cObject
9839>>>    Procedure Construct_Object
9841>>>        Forward Send Construct_Object
9843>>>        
9843>>>        Move Self to ghoApplication
9844>>>        
9844>>>        Property Handle phoVersionInfo
9845>>>        Property Handle phoWorkspace
9846>>>        Property Handle phoCommandLine
9847>>>        Property Handle phoMainPanel       // main panel will set this for us.
9848>>>        Property String psHelpFile         // type of file is determined by peHelpType
9849>>>        Property Integer peHelpType htWinHelp // htNoHelp htHtmlHelp htWinHelp
9850>>>        
9850>>>        Property String psCompany "Data Access Worldwide"
9851>>>        Property String psProduct "DataFlex Applications"
9852>>>        Property String psVersion C_DFVersion
9853>>>        Property String psProgram (Module_Name(desktop))
9854>>>        
9854>>>        // set to '' to stop the auto open workspace behavior
9854>>>        Property String psAutoOpenWorkspace 'Config.ws'
9855>>>        
9855>>>        
9855>>>        Property Boolean pbPreserveEnvironment True
9856>>>        
9856>>>        Object oCommandLine is a cCommandLine
9858>>>            Delegate Set phoCommandLine to Self
9860>>>        End_Object
9861>>>        
9861>>>        Object oWorkspace is a cWorkspace
9863>>>            Delegate Set phoWorkspace to Self
9865>>>        End_Object
9866>>>        
9866>>>        Object oVersionInfo is a cVersionInfo
9868>>>            Delegate Set phoVersionInfo to Self
9870>>>            Send DoCreate (GetApplicationFileName(parent(Self)))
9871>>>        End_Object
9872>>>        
9872>>>        Set pbUseWindowsFont to True
9873>>>        
9873>>>    End_Procedure
9874>>>    
9874>>>    Procedure Destroy_Object
9876>>>        If (ghoApplication=Self) Begin
9878>>>            Move 0 to ghoApplication
9879>>>        End
9879>>>>
9879>>>        Forward Send Destroy_Object
9881>>>    End_Procedure
9882>>>    
9882>>>    // Determines if the Enter key should act like the Tab key (and send msg_Next)
9882>>>    // The use of a global variable, gbKEnterNext, makes this an application-wide property
9882>>>    Procedure Set pbEnterKeyAsTabKey Boolean bNext
9884>>>        Move bNext to gbKEnterNext
9885>>>    End_Procedure
9886>>>    
9886>>>    Function pbEnterKeyAsTabKey Returns Boolean
9888>>>        Function_Return gbKEnterNext
9889>>>    End_Function
9890>>>    
9890>>>    Procedure DoLoadEnvironment Handle hoContainer Boolean bProgram
9892>>>// not used with webapp
9892>>>        Handle hoRegistry hoCommandBars
9892>>>        Handle hMonitor
9892>>>        Integer iError cxy
9892>>>        tWinWindowPlacement WindowPlacement
9892>>>        tWinWindowPlacement WindowPlacement
9892>>>        String sKey
9892>>>        Boolean bSuccess
9892>>>        String sObjectName
9892>>>        
9892>>>        If (pbPreserveEnvironment(Self)) Begin
9894>>>            Get Create U_cRegistry to hoRegistry
9895>>>            Set pfAccessRights of hoRegistry to KEY_READ
9896>>>            
9896>>>            Get RegistryKeyString to sKey
9897>>>            
9897>>>            If (bProgram = False) Begin
9899>>>                Move (sKey +"\WINDOWS") to sKey
9900>>>                Get Object_Label of hoContainer to sObjectName  // just get the local name
9901>>>                Move (sKey +"\" +sObjectName) to sKey
9902>>>            End
9902>>>>
9902>>>            Else ;                Move (sKey + "\Preferences") to sKey
9904>>>            
9904>>>            Get OpenKey of hoRegistry sKey to bSuccess
9905>>>            
9905>>>            If bSuccess Begin
9907>>>                If (ValueExists(hoRegistry, 'Placement')) Begin
9909>>>                    Get ReadBinary of hoRegistry "Placement" (AddressOf(WindowPlacement)) (SizeOfType(tWinWindowPlacement)) to bSuccess
9910>>>                    If bSuccess Begin
9912>>>                        // Do not restore size if the window is not resizable
9912>>>                        If (Border_Style(hoContainer) <> BORDER_THICK) Begin
9914>>>                            // restore always works with outer size
9914>>>                            Get GuiWindowSize     of hoContainer to cxy
9915>>>                            Move (WindowPlacement.NormalPosition.left + Low(cxy)) to WindowPlacement.NormalPosition.right
9916>>>                            Move (WindowPlacement.NormalPosition.top + Hi(cxy)) to WindowPlacement.NormalPosition.bottom
9917>>>                        End
9917>>>>
9917>>>                        
9917>>>                        // Test that the main window's placement location will appear on some connected monitor. If none
9917>>>                        // of the main window is visible then set the location to 0,0 and adjust the size....
9917>>>                        If (bProgram) Begin
9919>>>                            // Test the top left point
9919>>>                            Move (MonitorFromPoint(WindowPlacement.NormalPosition.left, WindowPlacement.NormalPosition.top, MONITOR_DEFAULTONNULL)) to hMonitor
9920>>>                            
9920>>>                            If (hMonitor = 0) Begin
9922>>>                                // test the bottom right point
9922>>>                                Move (MonitorFromPoint(WindowPlacement.NormalPosition.right, WindowPlacement.NormalPosition.bottom, MONITOR_DEFAULTONNULL)) to hMonitor
9923>>>                            End
9923>>>>
9923>>>                            
9923>>>                            // hMonitor = 0 means that the window location is not in any current monitor (probably the monitor layout has changed)
9923>>>                            // or that the window begins and ends outside all monitors (even though it may span across some monitor). We will adjust!
9923>>>                            If (hMonitor = 0) Begin
9925>>>                                Send ResetWindowPos (&WindowPlacement.NormalPosition)
9926>>>                            End
9926>>>>
9926>>>                        End
9926>>>>
9926>>>                        
9926>>>                        // Set the placement
9926>>>                        Move (SetWindowPlacement(Window_Handle(hoContainer), AddressOf(WindowPlacement))) to bSuccess
9927>>>                    End
9927>>>>
9927>>>                End
9927>>>>
9927>>>                If bProgram Begin
9929>>>                    Get phoCommandBars of hoContainer to hoCommandBars
9930>>>                    If not hoCommandBars Begin
9932>>>                        If (ValueExists(hoRegistry, 'IsStatusBarVisible')) ;                            Set Statusbar_State of hoContainer to (ReadDword(hoRegistry, 'IsStatusBarVisible'))
9935>>>                        If (ValueExists(hoRegistry, 'IsToolBarVisible'))   ;                            Set Toolbar_State   of hoContainer to (ReadDword(hoRegistry, 'IsToolBarVisible'))
9938>>>                    End
9938>>>>
9938>>>                End
9938>>>>
9938>>>                
9938>>>                Send CloseKey of hoRegistry
9939>>>            End
9939>>>>
9939>>>            
9939>>>            Send Destroy of hoRegistry
9940>>>        End
9940>>>>
9940>>>    End_Procedure
9941>>>    
9941>>>    Procedure DoSaveEnvironment Handle hoContainer Boolean bProgram
9943>>>// not used with webapp
9943>>>        Handle hoRegistry
9943>>>        Integer iError
9943>>>        tWinWindowPlacement WindowPlacement
9943>>>        tWinWindowPlacement WindowPlacement
9943>>>        String sKey
9943>>>        Boolean bSuccess
9943>>>        Integer eShowCmd
9943>>>        String sObjectName
9943>>>        
9943>>>        If (pbPreserveEnvironment(Self)) Begin
9945>>>            Get Create U_cRegistry to hoRegistry
9946>>>            Get RegistryKeyString to sKey
9947>>>            
9947>>>            If (bProgram = False) Begin
9949>>>                Move (sKey +"\WINDOWS") to sKey
9950>>>                Get Object_Label of hoContainer to sObjectName  // just get the local name
9951>>>                Move (sKey +"\" +sObjectName) to sKey
9952>>>            End
9952>>>>
9952>>>            Else ;                Move (sKey +"\Preferences") to sKey
9954>>>            
9954>>>            Get CreateKey of hoRegistry sKey to iError
9955>>>            If (iError = 0) Begin
9957>>>                Move (SizeOfType(tWinWindowPlacement)) to WindowPlacement.length
9958>>>                Move (GetWindowPlacement(Window_Handle(hoContainer), AddressOf(WindowPlacement))) to bSuccess
9959>>>                If bSuccess Begin
9961>>>                    // if minimized, assume restored, as we don't want to restart minimized!
9961>>>                    If (WindowPlacement.showCmd = SW_SHOWMINIMIZED) Begin
9963>>>                        Move SW_SHOWNORMAL to WindowPlacement.showCmd
9964>>>                    End
9964>>>>
9964>>>                    Send WriteBinary of hoRegistry "Placement" (AddressOf(WindowPlacement)) WindowPlacement.length
9965>>>                End
9965>>>>
9965>>>                
9965>>>                If bProgram Begin
9967>>>                    Send WriteInteger of hoRegistry 'IsStatusBarVisible' (Statusbar_State(hoContainer))
9968>>>                    Send WriteInteger of hoRegistry 'IsToolBarVisible'   (Toolbar_State(hoContainer))
9969>>>                End
9969>>>>
9969>>>                
9969>>>                
9969>>>                Send CloseKey of hoRegistry
9970>>>            End
9970>>>>
9970>>>            
9970>>>            Send Destroy of hoRegistry
9971>>>        End
9971>>>>
9971>>>    End_Procedure
9972>>>    
9972>>>    
9972>>>    Procedure ResetWindowPos tWinRect ByRef WindowPos
9974>>>        Integer ixySize ixSize iySize
9974>>>        Integer ixOffset iyOffset
9974>>>        
9974>>>        // first calculate the offset needed to move onto the main monitor at 0,0
9974>>>        Move (0 - WindowPos.left) to ixOffset
9975>>>        Move (0 - WindowPos.top) to iyOffset
9976>>>        
9976>>>        Move 0 to WindowPos.left
9977>>>        Move 0 to WindowPos.top
9978>>>        
9978>>>        Move (WindowPos.right + ixOffset) to WindowPos.right
9979>>>        Move (WindowPos.bottom + iyOffset) to WindowPos.bottom
9980>>>        
9980>>>        // also make sure that the size of the window is <= the size of the main monitor
9980>>>        Move (GUIScreen_Size(1)) to ixySize    // parameter of 1 means return "available" screen size
9981>>>        Move (low(ixySize))      to ixSize
9982>>>        Move (hi(ixySize))       to iySize
9983>>>        
9983>>>        Move (ixSize min WindowPos.right) to WindowPos.right
9984>>>        Move (iySize min WindowPos.bottom) to WindowPos.bottom
9985>>>    End_Procedure
9986>>>    
9986>>>    
9986>>>    Function RegistryKeyString Returns String
9988>>>        String sCompany sProduct sVersion sProgram
9988>>>        
9988>>>        Get psCompany to sCompany
9989>>>        Get psProduct to sProduct
9990>>>        Get psVersion to sVersion
9991>>>        Get psProgram to sProgram
9992>>>        
9992>>>        If (sCompany = "") ;            Move "Data Access Worldwide" to sCompany
9995>>>        If (sProduct = "") ;            Move "DataFlex Applications" to sProduct
9998>>>        If (sVersion = "") ;            Move C_DFVersion             to sVersion
10001>>>        If (sProgram ="") ;            Move (Module_Name(desktop))   to sProgram
10004>>>        
10004>>>        Function_Return ("SOFTWARE\" +sCompany +"\" +sProduct +"\" +sVersion +"\" +sProgram)
10005>>>    End_Function
10006>>>    
10006>>>    Procedure WriteString String sSubKey String sValueName String sValueData
10008>>>        String sKey
10008>>>        Handle hoRegistry
10008>>>        Integer iError
10008>>>        
10008>>>        Get Create U_cRegistry to hoRegistry
10009>>>        Get RegistryKeyString to sKey
10010>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
10013>>>        Get CreateKey of hoRegistry sKey to iError
10014>>>        If (iError = 0) Begin
10016>>>            Send WriteString of hoRegistry sValueName sValueData
10017>>>            Send CloseKey of hoRegistry
10018>>>        End
10018>>>>
10018>>>        
10018>>>        Send Destroy of hoRegistry
10019>>>    End_Procedure
10020>>>    
10020>>>    Procedure WriteInteger String sSubKey String sValueName Integer iValueData
10022>>>        String sKey
10022>>>        Handle hoRegistry
10022>>>        Integer iError
10022>>>        
10022>>>        Get Create U_cRegistry to hoRegistry
10023>>>        Get RegistryKeyString to sKey
10024>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
10027>>>        Get CreateKey of hoRegistry sKey to iError
10028>>>        If (iError = 0) Begin
10030>>>            Send WriteInteger of hoRegistry sValueName iValueData
10031>>>            Send CloseKey of hoRegistry
10032>>>        End
10032>>>>
10032>>>        
10032>>>        Send Destroy of hoRegistry
10033>>>    End_Procedure
10034>>>    
10034>>>    // WriteDword is obsolete. Please use WriteInteger or WriteUInt, depending on whether you use a signed or unsigned value.
10034>>>    Procedure WriteDword String sSubKey String sValueName Integer iValueData
10036>>>        Send WriteInteger of Self sSubKey sValueName iValueData 
10037>>>    End_Procedure
10038>>>    
10038>>>    Procedure WriteUInteger String sSubKey String sValueName UInteger uValueData
10040>>>        String sKey
10040>>>        Handle hoRegistry
10040>>>        Integer iError
10040>>>        
10040>>>        Get Create U_cRegistry to hoRegistry
10041>>>        Get RegistryKeyString to sKey
10042>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
10045>>>        Get CreateKey of hoRegistry sKey to iError
10046>>>        If (iError = 0) Begin
10048>>>            Send WriteUInt of hoRegistry sValueName uValueData
10049>>>            Send CloseKey of hoRegistry
10050>>>        End
10050>>>>
10050>>>        
10050>>>        Send Destroy of hoRegistry
10051>>>    End_Procedure
10052>>>
10052>>>    Procedure WriteBinary String sSubKey String sValueName Pointer pValueData Integer iDataLength
10054>>>        String sKey
10054>>>        Handle hoRegistry
10054>>>        Integer iError
10054>>>        
10054>>>        Get Create U_cRegistry to hoRegistry
10055>>>        Get RegistryKeyString to sKey
10056>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
10059>>>        Get CreateKey of hoRegistry sKey to iError
10060>>>        If (iError = 0) Begin
10062>>>            Send WriteBinary of hoRegistry sValueName pValueData iDataLength
10063>>>            Send CloseKey of hoRegistry
10064>>>        End
10064>>>>
10064>>>        
10064>>>        Send Destroy of hoRegistry
10065>>>    End_Procedure
10066>>>    
10066>>>    // returns true if both sub-key and value exists.
10066>>>    Function ValueExists String sSubKey String sValueName Returns Boolean
10068>>>        String sKey
10068>>>        Handle hoRegistry
10068>>>        Boolean bOK
10068>>>        Get Create U_cRegistry to hoRegistry
10069>>>        Get RegistryKeyString to sKey
10070>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
10073>>>        Get OpenKey of hoRegistry sKey to bOk
10074>>>        If (bOK) Begin
10076>>>            Move (ValueExists(hoRegistry, sValueName)) to bOk
10077>>>            Send CloseKey of hoRegistry
10078>>>        End
10078>>>>
10078>>>        Send Destroy of hoRegistry
10079>>>        Function_Return bOk
10080>>>    End_Function
10081>>>    
10081>>>    Function ReadString String sSubKey String sValueName String sDefault Returns String
10083>>>        String sKey sData
10083>>>        Handle hoRegistry
10083>>>        Boolean bOK
10083>>>        
10083>>>        Move sDefault to sData
10084>>>        Get Create U_cRegistry to hoRegistry
10085>>>        Get RegistryKeyString to sKey
10086>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
10089>>>        Get OpenKey of hoRegistry sKey to bOk
10090>>>        If (bOK) Begin
10092>>>            If (ValueExists(hoRegistry, sValueName)) ;                Get ReadString of hoRegistry sValueName to sData
10095>>>            Send CloseKey of hoRegistry
10096>>>        End
10096>>>>
10096>>>        
10096>>>        Send Destroy of hoRegistry
10097>>>        Function_Return sData
10098>>>    End_Function
10099>>>    
10099>>>    Function ReadInteger String sSubKey String sValueName Integer iDefault Returns Integer
10101>>>        String sKey
10101>>>        Integer iData
10101>>>        Handle hoRegistry
10101>>>        Boolean bOK
10101>>>        
10101>>>        Move iDefault to iData
10102>>>        Get Create U_cRegistry to hoRegistry
10103>>>        Get RegistryKeyString to sKey
10104>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
10107>>>        Get OpenKey of hoRegistry sKey to bOk
10108>>>        If bOK Begin
10110>>>            If (ValueExists(hoRegistry, sValueName)) ;                Get ReadInteger of hoRegistry sValueName to iData
10113>>>            Send CloseKey of hoRegistry
10114>>>        End
10114>>>>
10114>>>        
10114>>>        Send Destroy of hoRegistry
10115>>>        Function_Return iData
10116>>>    End_Function
10117>>>
10117>>>    // ReadDword is obsolete. Please use ReadInteger or ReadUInt, depending on whether you expect a signed or unsigned value.
10117>>>    Function ReadDword String sSubKey String sValueName Integer iDefault Returns Integer
10119>>>        Function_Return (ReadInteger(Self, sSubKey, sValueName, iDefault))
10120>>>    End_Function
10121>>>    
10121>>>    Function ReadUInt String sSubKey String sValueName UInteger uDefault Returns UInteger
10123>>>        String sKey
10123>>>        UInteger uData
10123>>>        Handle hoRegistry
10123>>>        Boolean bOK
10123>>>        
10123>>>        Move uDefault to uData
10124>>>        Get Create U_cRegistry to hoRegistry
10125>>>        Get RegistryKeyString to sKey
10126>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
10129>>>        Get OpenKey of hoRegistry sKey to bOk
10130>>>        If bOK Begin
10132>>>            If (ValueExists(hoRegistry, sValueName)) ;                Get ReadUInt of hoRegistry sValueName to uData
10135>>>            Send CloseKey of hoRegistry
10136>>>        End
10136>>>>
10136>>>        
10136>>>        Send Destroy of hoRegistry
10137>>>        Function_Return uData
10138>>>    End_Function
10139>>>    
10139>>>    Function ReadBinary String sSubKey String sValueName Pointer pValueData Integer iDataLength Returns Boolean
10141>>>        String sKey
10141>>>        Handle hoRegistry
10141>>>        Boolean bOK bSuccess
10141>>>        
10141>>>        Get Create U_cRegistry to hoRegistry
10142>>>        Get RegistryKeyString to sKey
10143>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
10146>>>        Get OpenKey of hoRegistry sKey to bOk
10147>>>        If bOK Begin
10149>>>            Get ReadBinary of hoRegistry sValueName pValueData iDataLength to bSuccess
10150>>>            Send CloseKey of hoRegistry
10151>>>        End
10151>>>>
10151>>>        
10151>>>        Send Destroy of hoRegistry
10152>>>        Function_Return bSuccess
10153>>>    End_Function
10154>>>    
10154>>>    Procedure DoOpenWorkspace String sWorkspace
10156>>>        // Tries to open in this order:
10156>>>        // 1) if absolute path, use that; otherwise
10156>>>        // 2) try to open in the path of the EXE; otherwise
10156>>>        // 3) load it via the Registered list
10156>>>        
10156>>>        Integer eOpened
10156>>>        String sError sWSFile
10156>>>        Handle hoWorkspace
10156>>>        Boolean bChangingWorkspace
10156>>>        
10156>>>        // As soon as an open is attempted, the application's object psAutoOpenWorkspace property
10156>>>        // is cleared. This way any attempt to manually open a workspace during its construction,
10156>>>        // which includes OnCreate, will stop the object from attempting to automatically open the
10156>>>        // workspace. This was added to make psAutoOpenWorkspace compatible with older applications.
10156>>>        // Typically these application will open a workspace in OnCreate. If this happens we assume
10156>>>        // that there should be no automatic opening of a worskpace.
10156>>>        Set psAutoOpenWorkspace to ""
10157>>>        
10157>>>        Get phoWorkspace to hoWorkspace
10158>>>        
10158>>>        Get pbWorkspaceOpened of hoWorkspace to bChangingWorkspace
10159>>>        If (bChangingWorkspace and ghoConnection) Begin
10161>>>            Send AutoDisconnect
10162>>>        End
10162>>>>
10162>>>        
10162>>>        Get OpenWorkspaceFile of hoWorkspace sWorkspace to eOpened
10163>>>        If (eOpened = wsWorkspaceFileNotFound) Begin
10165>>>            If (IsRegistered(hoWorkspace, sWorkspace) =True) Begin
10167>>>                Get OpenWorkspace of hoWorkspace sWorkspace to eOpened
10168>>>            End
10168>>>>
10168>>>        End
10168>>>>
10168>>>        If (eOpened <> wsWorkspaceOpened) Begin
10170>>>            Get OpenWorkspaceErrorMessage of hoWorkspace eOpened to sError
10171>>>            Get psWorkspaceWSFile of hoWorkspace to sWSFile
10172>>>            Error DFERR_CAPPLICATION (SFormat(C_$TheProgramCannotRun, sWorkspace) + ":\n\n" + If(sWSFile<>"",sWSfile+"\n\n","") +sError)
10173>>>>
10173>>>            Abort
10174>>>>
10174>>>        End
10174>>>>
10174>>>        Else Begin
10175>>>            Send AutoConnect
10176>>>            Send OnWorkspaceOpened
10177>>>        End
10177>>>>
10177>>>    End_Procedure
10178>>>    
10178>>>    Procedure AutoConnect
10180>>>        If (ghoConnection) Begin
10182>>>            Send AutoConnect of ghoConnection
10183>>>        End
10183>>>>
10183>>>    End_Procedure
10184>>>    
10184>>>    Procedure AutoDisconnect
10186>>>        If (ghoConnection) Begin
10188>>>            Send AutoDisconnect of ghoConnection
10189>>>        End
10189>>>>
10189>>>    End_Procedure
10190>>>    
10190>>>    // send after a workspace is successfully opened and connected
10190>>>    Procedure OnWorkspaceOpened
10192>>>    End_Procedure
10193>>>    
10193>>>    Procedure OnCreate
10195>>>        // Event called when the Application object is ready to be used
10195>>>        // to open a Workspace, etc.
10195>>>    End_Procedure
10196>>>    
10196>>>    Procedure End_Construct_Object
10198>>>        String sName
10198>>>        Forward Send End_Construct_Object
10200>>>        Send OnCreate
10201>>>        // note that psAutoOpenWorkspace will get cleared of OnCreate attempts to open a workspace
10201>>>        Get psAutoOpenWorkspace to sName
10202>>>        If (sName<>"") Begin
10204>>>            Send DoOpenWorkspace sName
10205>>>        End
10205>>>>
10205>>>    End_Procedure
10206>>>    
10206>>>    Function GetApplicationFileName Returns String
10208>>>        // Returns the filename from Windows
10208>>>        Integer iNumChars
10208>>>        WString wFilename
10208>>>                
10208>>>        Move (Repeat(Character(0), 1024)) to wFilename
10209>>>        Move (GetModuleFileNameW(0, AddressOf(wFilename), 1024)) to iNumChars
10210>>>        
10210>>>        Function_Return (CString(wFilename))
10211>>>    End_Function
10212>>>    
10212>>>    Function GetApplicationPath Returns String
10214>>>        // Returns the path of the Application (no trailing "\")
10214>>>        WString wApplicationFileName 
10214>>>        String sPath
10214>>>        Boolean bRemoved
10214>>>        
10214>>>        Get GetApplicationFileName  to wApplicationFileName
10215>>>        Move (PathRemoveFileSpecW(AddressOf(wApplicationFileName))) to bRemoved
10216>>>        Move (CString(wApplicationFileName)) to sPath
10217>>>        
10217>>>        If (Right(sPath, 1) ="\") ;            Move (Left(sPath, Length(sPath) -1)) to sPath
10220>>>        Function_Return sPath
10221>>>    End_Function
10222>>>    
10222>>>    Function GetApplicationName Returns String
10224>>>        // Returns the name of the Application (without its Path or Extension)
10224>>>        String sApplicationFileName 
10224>>>        WString wApplicationName
10224>>>        Boolean bRemoved
10224>>>        Integer iVoid
10224>>>        
10224>>>        Get GetApplicationFileName to sApplicationFileName
10225>>>        Move (ExtractFileName(sApplicationFileName)) to wApplicationName
10226>>>        Move (PathRemoveExtensionW(AddressOf(wApplicationName))) to iVoid
10227>>>        Function_Return (CString(wApplicationName))
10228>>>    End_Function
10229>>>    
10229>>>    Function DFRootPath Returns String
10231>>>        String sRoot
10231>>>        Get_Profile_String "Defaults" "VDFRootDir" to sRoot
10234>>>        // Ensure it does not contain a trailing "\"
10234>>>        If (Right(sRoot,1) = "\") Begin
10236>>>            Move (Left(sRoot, Length(sRoot)-1)) to sRoot
10237>>>        End
10237>>>>
10237>>>        Function_Return sRoot
10238>>>    End_Function
10239>>>    
10239>>>    Function DFBinPath Returns String
10241>>>        String sRoot
10241>>>        Get DFRootPath to sRoot
10242>>>        If (sRoot<>"") Begin
10244>>>            Move (sRoot+"\bin") to sRoot
10245>>>        End
10245>>>>
10245>>>        Else Begin
10246>>>            // if the root from the registry (vdfrootdir) is empty, we will assume that the
10246>>>            // bin path must be the same as the application path.
10246>>>            Get GetApplicationPath to sRoot
10247>>>        End
10247>>>>
10247>>>        Function_Return sRoot
10248>>>    End_Function
10249>>>    
10249>>>    // this just directs to the desktop property. If you are using an application object you are
10249>>>    // encouraged to set this here.
10249>>>    Procedure Set pbUseWindowsFont Boolean bUseWindowsFont
10251>>>        Set pbUseWindowsFont of Desktop to bUseWindowsFont
10252>>>    End_Procedure
10253>>>    
10253>>>    Function pbUseWindowsFont Returns Boolean
10255>>>        Boolean bUseWindowsFont
10255>>>        Get pbUseWindowsFont of Desktop to bUseWindowsFont
10256>>>        Function_Return bUseWindowsFont
10257>>>    End_Function
10258>>>    
10258>>>    // this just directs to the desktop property. If you are using an application object you are
10258>>>    // encouraged to set this here.
10258>>>    Procedure Set pbLegacyDialogRatio Boolean bLegacy
10260>>>        Set pbLegacyDialogRatio of Desktop to bLegacy
10261>>>    End_Procedure
10262>>>    
10262>>>    Function pbLegacyDialogRatio Returns Boolean
10264>>>        Boolean bLegacy
10264>>>        Get pbLegacyDialogRatio of Desktop to bLegacy
10265>>>        Function_Return bLegacy
10266>>>    End_Function
10267>>>End_Class
10268>>>
10268>>>
10268>Use Thriftly.pkg
Including file: Thriftly.pkg    (C:\Users\marce\OneDrive\Documentos\Thriftly Developer\Dataflex\Library_x64\AppSrc\Thriftly.pkg)
10268>>>Use UI
10268>>>Use Thriftly.Interface.pkg
Including file: Thriftly.Interface.pkg    (C:\Users\marce\OneDrive\Documentos\Thriftly Developer\Dataflex\Library_x64\AppSrc\Thriftly.Interface.pkg)
10268>>>>>// DataFlex COM proxy classes generated from C:\Program Files (x86)\Thriftly Developer\bin\Thriftly.Interface.dll
10268>>>>>Use FlexCom20.pkg
Including file: FlexCOM20.pkg    (C:\Program Files\DataFlex 26.0\Pkg\FlexCOM20.pkg)
10268>>>>>>>// Full Flexcom support for automation (cComAutomationObject),
10268>>>>>>>// activeX (cComActiveXControl and document objects (cComDocumentObject)
10268>>>>>>>Use FlexCOM20_Base.pkg // defines basic flexcom symbols and class cComAutomationObject
Including file: FlexCOM20_Base.pkg    (C:\Program Files\DataFlex 26.0\Pkg\FlexCOM20_Base.pkg)
10268>>>>>>>>>// Flexcom support for automation (cComAutomationObject).
10268>>>>>>>>>// If you want activeX and document objects use FlexCom20.pkg
10268>>>>>>>>>Use VdfBase.pkg
10268>>>>>>>>>Use ComTypes.pkg
Including file: ComTypes.pkg    (C:\Program Files\DataFlex 26.0\Pkg\ComTypes.pkg)
10268>>>>>>>>>>>Use Variant.pkg
10268>>>>>>>>>>>
10268>>>>>>>>>>>
10268>>>>>>>>>
10268>>>>>>>>>
10268>>>>>>>>>
10268>>>>>>>>>//Enumerations for the peAutoCreate property
10268>>>>>>>>>//acNoAutoCreate - Do not automatically instantiate the COM object upon VDF object creation.
10268>>>>>>>>>//You must manually instantiate the COM object using CreateComObject. This is the default
10268>>>>>>>>>//for cComAutomation.
10268>>>>>>>>>Define acNoAutoCreate for 0
10268>>>>>>>>>//acAutoCreate - Automatically instantiate the COM object upon VDF object creation.
10268>>>>>>>>>//You won't need to manually instantiate the COM object. This is the default
10268>>>>>>>>>//for cComActiveXControl
10268>>>>>>>>>Define acAutoCreate for 1
10268>>>>>>>>>//acDeferredAutoCreate - Automatically instantiate the COM object during Page_Object,
10268>>>>>>>>>//and automatically destroy the COM object during Page_Delete. Use this setting only
10268>>>>>>>>>//if acAutoCreate causes problems.
10268>>>>>>>>>Define acDeferredAutoCreate for 2
10268>>>>>>>>>
10268>>>>>>>>>Class cComAutomationObject is a DFComAutomationObject
10269>>>>>>>>>    Procedure Construct_Object
10271>>>>>>>>>        Forward Send Construct_Object
10273>>>>>>>>>        Send RegisterComEvents
10274>>>>>>>>>    End_Procedure
10275>>>>>>>>>    
10275>>>>>>>>>    // It is expected that the Com class will augment this with useful event definitions
10275>>>>>>>>>    Procedure RegisterComEvents
10277>>>>>>>>>    End_Procedure
10278>>>>>>>>>    
10278>>>>>>>>>    // Attach the DF object to com automation object via progId.
10278>>>>>>>>>    // returns: Boolean bSuccess if Ok, If not ok, pcComObject is set to null
10278>>>>>>>>>    Function AttachActiveObject Returns Boolean
10280>>>>>>>>>        String sProgId
10280>>>>>>>>>        Variant vComObject
10280>>>>>>>>>        Boolean bSuccess
10280>>>>>>>>>        Get psProgID to sProgId
10281>>>>>>>>>        Get ComActiveObject sProgId to vComObject
10282>>>>>>>>>        Set pvComObject to vComObject
10283>>>>>>>>>        Move (not(IsNullComObject(vComObject))) to bSuccess // success of variant is not null
10284>>>>>>>>>        Function_Return bSuccess
10285>>>>>>>>>    End_Function
10286>>>>>>>>>    
10286>>>>>>>>>    // returns true if the control is created.
10286>>>>>>>>>    Function IsComObjectCreated Returns Boolean
10288>>>>>>>>>        Variant vComObject
10288>>>>>>>>>        Get pvComObject to vComObject
10289>>>>>>>>>        Function_Return (not(IsNullComObject(vComObject)))
10290>>>>>>>>>    End_Function
10291>>>>>>>>>    
10291>>>>>>>>>End_Class
10292>>>>>>>>>
10292>>>>>>>>>
10292>>>>>>>
10292>>>>>>>Use Windows.pkg
10292>>>>>>>
10292>>>>>>>Class cComDocumentObject is a DFComDocumentObject
10293>>>>>>>
10293>>>>>>>
10293>>>>>>>    Procedure Construct_Object
10295>>>>>>>        Forward Send Construct_Object
10297>>>>>>>        Send RegisterComEvents
10298>>>>>>>        Send Define_Standard_Object_Mixin
10299>>>>>>>        Send Define_Shadow_Mixin
10300>>>>>>>    End_Procedure
10301>>>>>>>
10301>>>>>>>    Import_Class_Protocol Standard_Object_Mixin
10302>>>>>>>    Import_Class_Protocol Shadow_Mixin
10303>>>>>>>
10303>>>>>>>    
10303>>>>>>>    // It is expected that the Com class will augment this with useful event definitions
10303>>>>>>>    Procedure RegisterComEvents
10305>>>>>>>    End_Procedure
10306>>>>>>>    
10306>>>>>>>    // returns true if the control is created.
10306>>>>>>>    Function IsComObjectCreated Returns Boolean
10308>>>>>>>        Variant vComObject
10308>>>>>>>        Get pvComObject to vComObject
10309>>>>>>>        Function_Return (not(IsNullComObject(vComObject)))
10310>>>>>>>    End_Function
10311>>>>>>>
10311>>>>>>>
10311>>>>>>>End_Class
10312>>>>>>>
10312>>>>>>>Class cComActiveXControl is a DFComActiveXControl
10313>>>>>>>
10313>>>>>>>    Procedure Construct_Object
10315>>>>>>>        Forward Send Construct_Object
10317>>>>>>>        Send RegisterComEvents
10318>>>>>>>
10318>>>>>>>
10318>>>>>>>        Send Define_Standard_Object_Mixin
10319>>>>>>>        Send Define_Single_Item_Navigate_Mixin
10320>>>>>>>        Send Define_Dflabel_Mixin
10321>>>>>>>
10321>>>>>>>        // internal: set true object is notified that the OCX value has changed.
10321>>>>>>>        Property Boolean pbPrivateControlChanging False
10322>>>>>>>        // Class sets this true when making a local (externally triggered) change. This is
10322>>>>>>>        // set when a Set Value change is made to prevent recursion
10322>>>>>>>        Property Boolean pbPrivateControlRefresh False
10323>>>>>>>        
10323>>>>>>>        // added to eumlate a single item form support
10323>>>>>>>        Property Boolean pbPrivateItem_Changed_State False
10324>>>>>>>        
10324>>>>>>>        // This keeps track of value, even when control is not created
10324>>>>>>>        Property String psPrivateValue ''
10325>>>>>>>        
10325>>>>>>>        // If set true, then the control will attempt to bind the value property in the object to the
10325>>>>>>>        // comValue in the control. It will try to keep these values in synch at all times. This allows a
10325>>>>>>>        // control to be used as a Form style value control. the default is true. Even when true if the
10325>>>>>>>        // get/set ComValue methods are not set up to do anything, this will do nothing.
10325>>>>>>>        Property Boolean pbBindValue True
10326>>>>>>>        
10326>>>>>>>    End_Procedure
10327>>>>>>>    
10327>>>>>>>    // It is expected that the Com class will augment this with useful event definitions
10327>>>>>>>    Procedure RegisterComEvents
10329>>>>>>>    End_Procedure
10330>>>>>>>
10330>>>>>>>    
10330>>>>>>>    // returns true if the control is created.
10330>>>>>>>    Function IsComObjectCreated Returns Boolean
10332>>>>>>>        Variant vComObject
10332>>>>>>>        Get pvComObject to vComObject
10333>>>>>>>        Function_Return (not(IsNullComObject(vComObject)))
10334>>>>>>>    End_Function
10335>>>>>>>    
10335>>>>>>>
10335>>>>>>>    Import_Class_Protocol Standard_Object_Mixin
10336>>>>>>>    Import_Class_Protocol Single_Item_Navigate_Mixin
10337>>>>>>>    Import_Class_Protocol Dflabel_Mixin
10338>>>>>>>
10338>>>>>>>    // added to eumlate a single item form support
10338>>>>>>>    Function Item_Count Returns Integer
10340>>>>>>>        Function_Return 1
10341>>>>>>>    End_Function
10342>>>>>>>    
10342>>>>>>>    // added to eumlate a single item form support
10342>>>>>>>    Procedure Set Item_Changed_State Integer iItem Integer iState
10344>>>>>>>        Set pbPrivateItem_changed_state to iState
10345>>>>>>>        If (iState and changed_state(Self)=False) ;            Set changed_state to True
10348>>>>>>>    End_Procedure
10349>>>>>>>    
10349>>>>>>>    Function Item_Changed_State Integer iItem Returns Integer
10351>>>>>>>        Function_Return (pbPrivateItem_changed_state(Self))
10352>>>>>>>    End_Function
10353>>>>>>>    
10353>>>>>>>    
10353>>>>>>>    // augment to set the label's appearance
10353>>>>>>>    Procedure Shadow_Display
10355>>>>>>>        Forward Send Shadow_display
10357>>>>>>>        Send Label_Shadow_Display
10358>>>>>>>    End_Procedure
10359>>>>>>>    
10359>>>>>>>    // Created to simulate get/Set value.
10359>>>>>>>    Procedure Set Value Integer iItem String sVal
10361>>>>>>>        If not (pbPrivateControlChanging(Self)) ;            Send OnRefreshControl sVal
10364>>>>>>>        Set psPrivateValue to sVal
10365>>>>>>>        Send OnChange
10366>>>>>>>        //Set changed_state to True
10366>>>>>>>        Set item_changed_state 0 to True
10367>>>>>>>    End_Procedure
10368>>>>>>>    
10368>>>>>>>    Function Value Integer iItem Returns String
10370>>>>>>>        Function_Return (psPrivateValue(Self))
10371>>>>>>>        //function_return (Controlvalue(self))
10371>>>>>>>    End_Function
10372>>>>>>>    
10372>>>>>>>    Procedure OnChange
10374>>>>>>>    End_Procedure
10375>>>>>>>    
10375>>>>>>>    
10375>>>>>>>    // It is expected that the sub-class will provide functionality
10375>>>>>>>    // for these messages. This gets and sets the value of the actual
10375>>>>>>>    // window control. These should only be used to synchronize the window
10375>>>>>>>    // control and the DF side. Do not use for any other purpose.
10375>>>>>>>    Procedure Set ControlValue String sVal
10377>>>>>>>    End_Procedure
10378>>>>>>>    
10378>>>>>>>    Function ControlValue Returns String
10380>>>>>>>    End_Function
10381>>>>>>>    
10381>>>>>>>    Procedure OnCreate
10383>>>>>>>        // if we are binding value to comValue, do so upon creation
10383>>>>>>>        If (pbBindValue(Self)) ;            Set ControlValue to (Value(Self))
10386>>>>>>>        Forward Send OnCreate
10388>>>>>>>    End_Procedure
10389>>>>>>>    
10389>>>>>>>    // Notification that the control is about to be activated in place. The COM component is
10389>>>>>>>    // created but OnCreate is not yet fired (this happens after the InPlaceActivate).
10389>>>>>>>    Procedure OnBeforeInPlaceActivate
10391>>>>>>>        Forward Send OnBeforeInPlaceActivate
10393>>>>>>>    End_Procedure
10394>>>>>>>    
10394>>>>>>>    // Notification that the control's value has been changed
10394>>>>>>>    // externally by the program (via set value). Use to synchronize
10394>>>>>>>    // OCX control value.
10394>>>>>>>    Procedure OnRefreshControl String sVal
10396>>>>>>>        Boolean bOld
10396>>>>>>>        If (pbBindValue(Self) and pbPrivateControlChanging(Self)=0 and IsComObjectCreated(Self)) Begin
10398>>>>>>>            Get pbPrivateControlRefresh to bOld
10399>>>>>>>            Set pbPrivateControlRefresh to True
10400>>>>>>>            Set ControlValue to sval
10401>>>>>>>            Set pbPrivateControlRefresh to bOld
10402>>>>>>>        End
10402>>>>>>>>
10402>>>>>>>    End_Procedure
10403>>>>>>>    
10403>>>>>>>    // notification that the control has changed its value. Used to
10403>>>>>>>    // synchronize the object with the change.
10403>>>>>>>    Procedure OnControlValueChanged
10405>>>>>>>        String sVal
10405>>>>>>>        Boolean bOld
10405>>>>>>>        If (pbBindValue(Self) and pbPrivateControlRefresh(Self)=0) Begin
10407>>>>>>>            Get pbPrivateControlChanging to bOld
10408>>>>>>>            Set pbPrivateControlChanging to True
10409>>>>>>>            Get ControlValue to sVal
10410>>>>>>>            Set Value to sVal
10411>>>>>>>            Set Item_Changed_State 0 to True
10412>>>>>>>            Set pbPrivateControlChanging to bOld
10413>>>>>>>        End
10413>>>>>>>>
10413>>>>>>>    End_Procedure
10414>>>>>>>    
10414>>>>>>>    Procedure Delete_Data
10416>>>>>>>        Forward Send Delete_Data
10418>>>>>>>        Set Value to ''
10419>>>>>>>        Set Changed_state to False
10420>>>>>>>        Set Item_changed_state 0 to False
10421>>>>>>>    End_Procedure
10422>>>>>>>
10422>>>>>>>
10422>>>>>>>End_Class
10423>>>>>>>
10423>>>>>>>
10423>>>>>
10423>>>>>Define OLEEVO_TYPES for Integer
10423>>>>>    Define OLEEVO_SCALAR for 1
10423>>>>>    Define OLEEVO_STRUCT for 12
10423>>>>>    Define OLEEVO_MAP for 13
10423>>>>>    Define OLEEVO_SET for 14
10423>>>>>    Define OLEEVO_LIST for 15
10423>>>>>
10423>>>>>Define OLEEVO_VISIBILITY for Integer
10423>>>>>    Define OLEEVO_PUBLIC for 1
10423>>>>>    Define OLEEVO_PRIVATE for 2
10423>>>>>
10423>>>>>Define OLEEVO_FIELD_FLAGS for Integer
10423>>>>>    Define OLEEVO_FIELD_DEFAULT for 0
10423>>>>>    Define OLEEVO_FIELD_REQUIRED for 1
10423>>>>>
10423>>>>>Define OLEEVO_METHOD_FLAGS for Integer
10423>>>>>    Define OLEEVO_METHOD_DEFAULT for 0
10423>>>>>    Define OLEEVO_METHOD_ONEWAY for 1
10423>>>>>    Define OLEEVO_METHOD_AUTH for 2
10423>>>>>    Define OLEEVO_METHOD_UNSECURED for 4
10423>>>>>    Define OLEEVO_METHOD_LOGIN for 8
10423>>>>>
10423>>>>>Define OLEEVO_SCALARS for Integer
10423>>>>>    Define OLEEVO_BOOL for 2
10423>>>>>    Define OLEEVO_BYTE for 3
10423>>>>>    Define OLEEVO_I16 for 6
10423>>>>>    Define OLEEVO_I32 for 8
10423>>>>>    Define OLEEVO_I64 for 10
10423>>>>>    Define OLEEVO_DOUBLE for 4
10423>>>>>    Define OLEEVO_STRING for 11
10423>>>>>    Define OLEEVO_DATE for 1001
10423>>>>>    Define OLEEVO_DATETIME for 1002
10423>>>>>    Define OLEEVO_BINARY for 1003
10423>>>>>    Define OLEEVO_DECIMAL for 1004
10423>>>>>
10423>>>>>Define OLEEVO_MARSHALING_MODES for Integer
10423>>>>>    Define OLEEVO_RECORDS_AND_ARRAYS for 17
10423>>>>>    Define OLEEVO_OBJECTS_AND_COLLECTIONS for 34
10423>>>>>
10423>>>>>Define OLEEVO_TRANSPORTS for Integer
10423>>>>>    Define OLEEVO_TRANSPORT_FRAMED for 1
10423>>>>>    Define OLEEVO_TRANSPORT_HTTP for 2
10423>>>>>    Define OLEEVO_TRANSPORT_GRPC for 3
10423>>>>>
10423>>>>>Define OLEEVO_PROTOCOLS for Integer
10423>>>>>    Define OLEEVO_THRIFT_BINARY for 1
10423>>>>>    Define OLEEVO_THRIFT_COMPACT for 2
10423>>>>>    Define OLEEVO_JSON_RPC for 3
10423>>>>>    Define OLEEVO_SOAP for 4
10423>>>>>    Define OLEEVO_JSON_REST for 5
10423>>>>>    Define OLEEVO_PROTOBUF for 6
10423>>>>>
10423>>>>>Define OLEEVO_ENCODINGS for Integer
10423>>>>>    Define OLEEVO_ENCODING_UTF8 for 1
10423>>>>>    Define OLEEVO_ENCODING_ANSI for 2
10423>>>>>
10423>>>>>//Struct GUID
10423>>>>>    //UInteger Data1
10423>>>>>    //UShort Data2
10423>>>>>    //UShort Data3
10423>>>>>    // Data4  // Bad type member
10423>>>>>//End_Struct
10423>>>>>
10423>>>>>// CLSID: {DF66E45F-43E0-4EE0-B28B-C7750F3C1C10}
10423>>>>>Class cComIEvoInterface is a Mixin
10424>>>>>
10424>>>>>    Function ComNewType Returns Variant
10426>>>>>        Handle hDispatchDriver
10426>>>>>        Variant retVal
10426>>>>>        Get phDispatchDriver to hDispatchDriver
10427>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_DISPATCH to retVal
10428>>>>>        Function_Return retVal
10429>>>>>    End_Function
10430>>>>>
10430>>>>>    Function ComNewStruct Returns Variant
10432>>>>>        Handle hDispatchDriver
10432>>>>>        Variant retVal
10432>>>>>        Get phDispatchDriver to hDispatchDriver
10433>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_DISPATCH to retVal
10434>>>>>        Function_Return retVal
10435>>>>>    End_Function
10436>>>>>
10436>>>>>    Function ComNewService Returns Variant
10438>>>>>        Handle hDispatchDriver
10438>>>>>        Variant retVal
10438>>>>>        Get phDispatchDriver to hDispatchDriver
10439>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_DISPATCH to retVal
10440>>>>>        Function_Return retVal
10441>>>>>    End_Function
10442>>>>>End_Class
10443>>>>>
10443>>>>>// CoClass
10443>>>>>// CLSID: {4212868E-6850-4E20-BDCE-22EA2BAAA0E8}
10443>>>>>Class cComEvoInterface is a cComAutomationObject
10444>>>>>    Import_Class_Protocol cComIEvoInterface
10445>>>>>
10445>>>>>    Procedure Construct_Object
10447>>>>>        Forward Send Construct_Object
10449>>>>>        Set psProgID to "{4212868E-6850-4E20-BDCE-22EA2BAAA0E8}"
10450>>>>>        Set peAutoCreate to acNoAutoCreate
10451>>>>>    End_Procedure
10452>>>>>End_Class
10453>>>>>
10453>>>>>// CLSID: {A809FD17-49C0-4F9C-8007-38D17E38D19D}
10453>>>>>Class cComIEvoServiceRuntime is a Mixin
10454>>>>>
10454>>>>>    Function ComService Returns Variant
10456>>>>>        Handle hDispatchDriver
10456>>>>>        Variant retVal
10456>>>>>        Get phDispatchDriver to hDispatchDriver
10457>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_DISPATCH to retVal
10458>>>>>        Function_Return retVal
10459>>>>>    End_Function
10460>>>>>
10460>>>>>    Procedure Set ComService Variant value
10462>>>>>        Handle hDispatchDriver
10462>>>>>        Get phDispatchDriver to hDispatchDriver
10463>>>>>        Send PrepareParams to hDispatchDriver 1
10464>>>>>        Set ComProperty of hDispatchDriver 1 OLE_VT_DISPATCH to value
10465>>>>>    End_Procedure
10466>>>>>
10466>>>>>    Function ComRuntime Returns Variant
10468>>>>>        Handle hDispatchDriver
10468>>>>>        Variant retVal
10468>>>>>        Get phDispatchDriver to hDispatchDriver
10469>>>>>        Get InvokeComMethod of hDispatchDriver 5 OLE_VT_DISPATCH to retVal
10470>>>>>        Function_Return retVal
10471>>>>>    End_Function
10472>>>>>
10472>>>>>    Function ComWrap Returns Variant
10474>>>>>        Handle hDispatchDriver
10474>>>>>        Variant retVal
10474>>>>>        Get phDispatchDriver to hDispatchDriver
10475>>>>>        Get InvokeComMethod of hDispatchDriver 6 OLE_VT_DISPATCH to retVal
10476>>>>>        Function_Return retVal
10477>>>>>    End_Function
10478>>>>>End_Class
10479>>>>>
10479>>>>>// CLSID: {4C009192-DF3D-4403-BF21-C027A8FD9702}
10479>>>>>Class cCom_EvoRuntimeEvents is a Mixin
10480>>>>>
10480>>>>>    Procedure RegisterComEvents
10482>>>>>    End_Procedure
10483>>>>>End_Class
10484>>>>>
10484>>>>>// CoClass
10484>>>>>// CLSID: {24CBD848-6CEF-4E8F-B714-7A0B23976272}
10484>>>>>Class cComEvoServiceRuntime is a cComAutomationObject
10485>>>>>    Import_Class_Protocol cComIEvoServiceRuntime
10486>>>>>    Import_Class_Protocol cCom_EvoRuntimeEvents
10487>>>>>
10487>>>>>    Procedure Construct_Object
10489>>>>>        Forward Send Construct_Object
10491>>>>>        Set psProgID to "{24CBD848-6CEF-4E8F-B714-7A0B23976272}"
10492>>>>>        Set psEventId to "{4C009192-DF3D-4403-BF21-C027A8FD9702}"
10493>>>>>        Set peAutoCreate to acNoAutoCreate
10494>>>>>    End_Procedure
10495>>>>>End_Class
10496>>>>>
10496>>>>>// CLSID: {136F28D3-20DD-4771-BD36-264D75CEA2B4}
10496>>>>>Class cComIEvoSimpleServer is a Mixin
10497>>>>>
10497>>>>>    Procedure ComStart Variant llServices OLEEVO_MARSHALING_MODES llmode
10499>>>>>        Handle hDispatchDriver
10499>>>>>        Get phDispatchDriver to hDispatchDriver
10500>>>>>        Send PrepareParams to hDispatchDriver 2
10501>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llServices
10502>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llmode
10503>>>>>        Send InvokeComMethod to hDispatchDriver 1 OLE_VT_VOID
10504>>>>>    End_Procedure
10505>>>>>
10505>>>>>    Procedure ComStop
10507>>>>>        Handle hDispatchDriver
10507>>>>>        Get phDispatchDriver to hDispatchDriver
10508>>>>>        Send InvokeComMethod to hDispatchDriver 2 OLE_VT_VOID
10509>>>>>    End_Procedure
10510>>>>>
10510>>>>>    Function ComIsConnected Returns Boolean
10512>>>>>        Handle hDispatchDriver
10512>>>>>        Boolean retVal
10512>>>>>        Get phDispatchDriver to hDispatchDriver
10513>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_BOOL to retVal
10514>>>>>        Function_Return retVal
10515>>>>>    End_Function
10516>>>>>
10516>>>>>    Function ComSettings Returns Variant
10518>>>>>        Handle hDispatchDriver
10518>>>>>        Variant retVal
10518>>>>>        Get phDispatchDriver to hDispatchDriver
10519>>>>>        Get InvokeComMethod of hDispatchDriver 4 OLE_VT_DISPATCH to retVal
10520>>>>>        Function_Return retVal
10521>>>>>    End_Function
10522>>>>>End_Class
10523>>>>>
10523>>>>>// CoClass
10523>>>>>// CLSID: {D546307E-2E2A-4B98-B230-4BD658C20C90}
10523>>>>>Class cComEvoSimpleServer is a cComAutomationObject
10524>>>>>    Import_Class_Protocol cComIEvoSimpleServer
10525>>>>>
10525>>>>>    Procedure Construct_Object
10527>>>>>        Forward Send Construct_Object
10529>>>>>        Set psProgID to "{D546307E-2E2A-4B98-B230-4BD658C20C90}"
10530>>>>>        Set peAutoCreate to acNoAutoCreate
10531>>>>>    End_Procedure
10532>>>>>End_Class
10533>>>>>
10533>>>>>// CLSID: {3942D3E7-4EE5-4BAE-9FAD-02938CC05E44}
10533>>>>>Class cComIEvoConsoleConnection is a Mixin
10534>>>>>
10534>>>>>    Procedure ComConnect Variant llServices OLEEVO_MARSHALING_MODES llmode
10536>>>>>        Handle hDispatchDriver
10536>>>>>        Get phDispatchDriver to hDispatchDriver
10537>>>>>        Send PrepareParams to hDispatchDriver 2
10538>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llServices
10539>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llmode
10540>>>>>        Send InvokeComMethod to hDispatchDriver 1 OLE_VT_VOID
10541>>>>>    End_Procedure
10542>>>>>
10542>>>>>    Procedure ComDisconnect
10544>>>>>        Handle hDispatchDriver
10544>>>>>        Get phDispatchDriver to hDispatchDriver
10545>>>>>        Send InvokeComMethod to hDispatchDriver 2 OLE_VT_VOID
10546>>>>>    End_Procedure
10547>>>>>
10547>>>>>    Function ComIsConnected Returns Boolean
10549>>>>>        Handle hDispatchDriver
10549>>>>>        Boolean retVal
10549>>>>>        Get phDispatchDriver to hDispatchDriver
10550>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_BOOL to retVal
10551>>>>>        Function_Return retVal
10552>>>>>    End_Function
10553>>>>>End_Class
10554>>>>>
10554>>>>>// CoClass
10554>>>>>// CLSID: {50065F68-C59A-42A9-A1A8-6F3AAE9F3D26}
10554>>>>>Class cComEvoConsoleConnection is a cComAutomationObject
10555>>>>>    Import_Class_Protocol cComIEvoConsoleConnection
10556>>>>>
10556>>>>>    Procedure Construct_Object
10558>>>>>        Forward Send Construct_Object
10560>>>>>        Set psProgID to "{50065F68-C59A-42A9-A1A8-6F3AAE9F3D26}"
10561>>>>>        Set peAutoCreate to acNoAutoCreate
10562>>>>>    End_Procedure
10563>>>>>End_Class
10564>>>>>
10564>>>>>// CLSID: {EA0D8C17-9891-444D-B55E-BA86E7DF6E7F}
10564>>>>>Class cComIEvoDispatchConnection is a Mixin
10565>>>>>
10565>>>>>    Procedure ComConnect Variant llServices OLEEVO_MARSHALING_MODES llmode
10567>>>>>        Handle hDispatchDriver
10567>>>>>        Get phDispatchDriver to hDispatchDriver
10568>>>>>        Send PrepareParams to hDispatchDriver 2
10569>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llServices
10570>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llmode
10571>>>>>        Send InvokeComMethod to hDispatchDriver 1 OLE_VT_VOID
10572>>>>>    End_Procedure
10573>>>>>
10573>>>>>    Procedure ComDisconnect
10575>>>>>        Handle hDispatchDriver
10575>>>>>        Get phDispatchDriver to hDispatchDriver
10576>>>>>        Send InvokeComMethod to hDispatchDriver 2 OLE_VT_VOID
10577>>>>>    End_Procedure
10578>>>>>
10578>>>>>    Function ComIsConnected Returns Boolean
10580>>>>>        Handle hDispatchDriver
10580>>>>>        Boolean retVal
10580>>>>>        Get phDispatchDriver to hDispatchDriver
10581>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_BOOL to retVal
10582>>>>>        Function_Return retVal
10583>>>>>    End_Function
10584>>>>>End_Class
10585>>>>>
10585>>>>>// CoClass
10585>>>>>// CLSID: {4F31F80B-4D0A-4B3D-92BA-EAAD74D6016D}
10585>>>>>Class cComEvoDispatchConnection is a cComAutomationObject
10586>>>>>    Import_Class_Protocol cComIEvoDispatchConnection
10587>>>>>
10587>>>>>    Procedure Construct_Object
10589>>>>>        Forward Send Construct_Object
10591>>>>>        Set psProgID to "{4F31F80B-4D0A-4B3D-92BA-EAAD74D6016D}"
10592>>>>>        Set peAutoCreate to acNoAutoCreate
10593>>>>>    End_Procedure
10594>>>>>End_Class
10595>>>>>
10595>>>>>// CLSID: {271B9DDD-07BC-4F84-9EAF-B1E77C3C8E4E}
10595>>>>>Class cComIEvoField is a cComAutomationObject
10596>>>>>
10596>>>>>    Function ComId Returns Integer
10598>>>>>        Handle hDispatchDriver
10598>>>>>        Integer retVal
10598>>>>>        Get phDispatchDriver to hDispatchDriver
10599>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_I4 to retVal
10600>>>>>        Function_Return retVal
10601>>>>>    End_Function
10602>>>>>
10602>>>>>    Function ComName Returns String
10604>>>>>        Handle hDispatchDriver
10604>>>>>        String retVal
10604>>>>>        Get phDispatchDriver to hDispatchDriver
10605>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_BSTR to retVal
10606>>>>>        Function_Return retVal
10607>>>>>    End_Function
10608>>>>>
10608>>>>>    Function ComType Returns Variant
10610>>>>>        Handle hDispatchDriver
10610>>>>>        Variant retVal
10610>>>>>        Get phDispatchDriver to hDispatchDriver
10611>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_DISPATCH to retVal
10612>>>>>        Function_Return retVal
10613>>>>>    End_Function
10614>>>>>
10614>>>>>    Function ComFlags Returns Integer
10616>>>>>        Handle hDispatchDriver
10616>>>>>        Integer retVal
10616>>>>>        Get phDispatchDriver to hDispatchDriver
10617>>>>>        Get InvokeComMethod of hDispatchDriver 4 OLE_VT_I4 to retVal
10618>>>>>        Function_Return retVal
10619>>>>>    End_Function
10620>>>>>
10620>>>>>    Function ComVisibility Returns OLEEVO_VISIBILITY
10622>>>>>        Handle hDispatchDriver
10622>>>>>        OLEEVO_VISIBILITY retVal
10622>>>>>        Get phDispatchDriver to hDispatchDriver
10623>>>>>        Get InvokeComMethod of hDispatchDriver 5 OLE_VT_I4 to retVal
10624>>>>>        Function_Return retVal
10625>>>>>    End_Function
10626>>>>>
10626>>>>>    Function ComDescription Returns String
10628>>>>>        Handle hDispatchDriver
10628>>>>>        String retVal
10628>>>>>        Get phDispatchDriver to hDispatchDriver
10629>>>>>        Get InvokeComMethod of hDispatchDriver 6 OLE_VT_BSTR to retVal
10630>>>>>        Function_Return retVal
10631>>>>>    End_Function
10632>>>>>End_Class
10633>>>>>
10633>>>>>// CLSID: {17B03014-738F-468A-B9B3-E30B57C093EE}
10633>>>>>Class cComIEvoType is a cComAutomationObject
10634>>>>>
10634>>>>>    Function ComKind Returns OLEEVO_TYPES
10636>>>>>        Handle hDispatchDriver
10636>>>>>        OLEEVO_TYPES retVal
10636>>>>>        Get phDispatchDriver to hDispatchDriver
10637>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_I4 to retVal
10638>>>>>        Function_Return retVal
10639>>>>>    End_Function
10640>>>>>End_Class
10641>>>>>
10641>>>>>// CLSID: {7380FAA1-C93A-4124-9A0B-A59432F77329}
10641>>>>>Class cComIEvoPrivateField is a cComAutomationObject
10642>>>>>
10642>>>>>    Function ComId Returns Integer
10644>>>>>        Handle hDispatchDriver
10644>>>>>        Integer retVal
10644>>>>>        Get phDispatchDriver to hDispatchDriver
10645>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_I4 to retVal
10646>>>>>        Function_Return retVal
10647>>>>>    End_Function
10648>>>>>
10648>>>>>    Function ComName Returns String
10650>>>>>        Handle hDispatchDriver
10650>>>>>        String retVal
10650>>>>>        Get phDispatchDriver to hDispatchDriver
10651>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_BSTR to retVal
10652>>>>>        Function_Return retVal
10653>>>>>    End_Function
10654>>>>>
10654>>>>>    Function ComType Returns Variant
10656>>>>>        Handle hDispatchDriver
10656>>>>>        Variant retVal
10656>>>>>        Get phDispatchDriver to hDispatchDriver
10657>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_DISPATCH to retVal
10658>>>>>        Function_Return retVal
10659>>>>>    End_Function
10660>>>>>
10660>>>>>    Function ComFlags Returns Integer
10662>>>>>        Handle hDispatchDriver
10662>>>>>        Integer retVal
10662>>>>>        Get phDispatchDriver to hDispatchDriver
10663>>>>>        Get InvokeComMethod of hDispatchDriver 4 OLE_VT_I4 to retVal
10664>>>>>        Function_Return retVal
10665>>>>>    End_Function
10666>>>>>
10666>>>>>    Function ComVisibility Returns OLEEVO_VISIBILITY
10668>>>>>        Handle hDispatchDriver
10668>>>>>        OLEEVO_VISIBILITY retVal
10668>>>>>        Get phDispatchDriver to hDispatchDriver
10669>>>>>        Get InvokeComMethod of hDispatchDriver 5 OLE_VT_I4 to retVal
10670>>>>>        Function_Return retVal
10671>>>>>    End_Function
10672>>>>>
10672>>>>>    Function ComDescription Returns String
10674>>>>>        Handle hDispatchDriver
10674>>>>>        String retVal
10674>>>>>        Get phDispatchDriver to hDispatchDriver
10675>>>>>        Get InvokeComMethod of hDispatchDriver 6 OLE_VT_BSTR to retVal
10676>>>>>        Function_Return retVal
10677>>>>>    End_Function
10678>>>>>
10678>>>>>    Function ComValue Returns Variant
10680>>>>>        Handle hDispatchDriver
10680>>>>>        Variant retVal
10680>>>>>        Get phDispatchDriver to hDispatchDriver
10681>>>>>        Get InvokeComMethod of hDispatchDriver 7 OLE_VT_VARIANT to retVal
10682>>>>>        Function_Return retVal
10683>>>>>    End_Function
10684>>>>>End_Class
10685>>>>>
10685>>>>>// CLSID: {C23CD75F-B006-4443-B4C1-DBC26DB1A9AE}
10685>>>>>Class cComIEvoPrototype is a cComAutomationObject
10686>>>>>
10686>>>>>    Function ComParameters Returns Variant
10688>>>>>        Handle hDispatchDriver
10688>>>>>        Variant retVal
10688>>>>>        Get phDispatchDriver to hDispatchDriver
10689>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_DISPATCH to retVal
10690>>>>>        Function_Return retVal
10691>>>>>    End_Function
10692>>>>>End_Class
10693>>>>>
10693>>>>>// CLSID: {6CD5F06D-2869-4E19-A3AC-ECF24258DFCF}
10693>>>>>Class cComIEvoCollection is a cComAutomationObject
10694>>>>>
10694>>>>>    Function Com_NewEnum Returns Variant
10696>>>>>        Handle hDispatchDriver
10696>>>>>        Variant retVal
10696>>>>>        Get phDispatchDriver to hDispatchDriver
10697>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
10698>>>>>        Function_Return retVal
10699>>>>>    End_Function
10700>>>>>
10700>>>>>    Function ComItem Integer llIndex Returns Variant
10702>>>>>        Handle hDispatchDriver
10702>>>>>        Variant retVal
10702>>>>>        Get phDispatchDriver to hDispatchDriver
10703>>>>>        Send PrepareParams to hDispatchDriver 1
10704>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
10705>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_VARIANT to retVal
10706>>>>>        Function_Return retVal
10707>>>>>    End_Function
10708>>>>>
10708>>>>>    Function ComCount Returns Integer
10710>>>>>        Handle hDispatchDriver
10710>>>>>        Integer retVal
10710>>>>>        Get phDispatchDriver to hDispatchDriver
10711>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_I4 to retVal
10712>>>>>        Function_Return retVal
10713>>>>>    End_Function
10714>>>>>End_Class
10715>>>>>
10715>>>>>// CLSID: {9389C2C9-E2C2-4666-BA4A-262066ED3A39}
10715>>>>>Class cComIEvoMethod is a cComAutomationObject
10716>>>>>
10716>>>>>    Function ComParameters Returns Variant
10718>>>>>        Handle hDispatchDriver
10718>>>>>        Variant retVal
10718>>>>>        Get phDispatchDriver to hDispatchDriver
10719>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_DISPATCH to retVal
10720>>>>>        Function_Return retVal
10721>>>>>    End_Function
10722>>>>>
10722>>>>>    Function ComId Returns Integer
10724>>>>>        Handle hDispatchDriver
10724>>>>>        Integer retVal
10724>>>>>        Get phDispatchDriver to hDispatchDriver
10725>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_I4 to retVal
10726>>>>>        Function_Return retVal
10727>>>>>    End_Function
10728>>>>>
10728>>>>>    Function ComName Returns String
10730>>>>>        Handle hDispatchDriver
10730>>>>>        String retVal
10730>>>>>        Get phDispatchDriver to hDispatchDriver
10731>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_BSTR to retVal
10732>>>>>        Function_Return retVal
10733>>>>>    End_Function
10734>>>>>
10734>>>>>    Function ComReturns Returns Variant
10736>>>>>        Handle hDispatchDriver
10736>>>>>        Variant retVal
10736>>>>>        Get phDispatchDriver to hDispatchDriver
10737>>>>>        Get InvokeComMethod of hDispatchDriver 4 OLE_VT_DISPATCH to retVal
10738>>>>>        Function_Return retVal
10739>>>>>    End_Function
10740>>>>>
10740>>>>>    Function ComFlags Returns Integer
10742>>>>>        Handle hDispatchDriver
10742>>>>>        Integer retVal
10742>>>>>        Get phDispatchDriver to hDispatchDriver
10743>>>>>        Get InvokeComMethod of hDispatchDriver 5 OLE_VT_I4 to retVal
10744>>>>>        Function_Return retVal
10745>>>>>    End_Function
10746>>>>>
10746>>>>>    Function ComDescription Returns String
10748>>>>>        Handle hDispatchDriver
10748>>>>>        String retVal
10748>>>>>        Get phDispatchDriver to hDispatchDriver
10749>>>>>        Get InvokeComMethod of hDispatchDriver 6 OLE_VT_BSTR to retVal
10750>>>>>        Function_Return retVal
10751>>>>>    End_Function
10752>>>>>
10752>>>>>    Function ComRetvalDescription Returns String
10754>>>>>        Handle hDispatchDriver
10754>>>>>        String retVal
10754>>>>>        Get phDispatchDriver to hDispatchDriver
10755>>>>>        Get InvokeComMethod of hDispatchDriver 7 OLE_VT_BSTR to retVal
10756>>>>>        Function_Return retVal
10757>>>>>    End_Function
10758>>>>>End_Class
10759>>>>>
10759>>>>>// CLSID: {61E15563-D124-4D49-A867-00025F36D9C0}
10759>>>>>Class cComIEvoMutableCollection is a cComAutomationObject
10760>>>>>
10760>>>>>    Function Com_NewEnum Returns Variant
10762>>>>>        Handle hDispatchDriver
10762>>>>>        Variant retVal
10762>>>>>        Get phDispatchDriver to hDispatchDriver
10763>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
10764>>>>>        Function_Return retVal
10765>>>>>    End_Function
10766>>>>>
10766>>>>>    Function ComItem Integer llIndex Returns Variant
10768>>>>>        Handle hDispatchDriver
10768>>>>>        Variant retVal
10768>>>>>        Get phDispatchDriver to hDispatchDriver
10769>>>>>        Send PrepareParams to hDispatchDriver 1
10770>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
10771>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_VARIANT to retVal
10772>>>>>        Function_Return retVal
10773>>>>>    End_Function
10774>>>>>
10774>>>>>    Function ComCount Returns Integer
10776>>>>>        Handle hDispatchDriver
10776>>>>>        Integer retVal
10776>>>>>        Get phDispatchDriver to hDispatchDriver
10777>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_I4 to retVal
10778>>>>>        Function_Return retVal
10779>>>>>    End_Function
10780>>>>>
10780>>>>>    Procedure ComAdd Variant llValue
10782>>>>>        Handle hDispatchDriver
10782>>>>>        Get phDispatchDriver to hDispatchDriver
10783>>>>>        Send PrepareParams to hDispatchDriver 1
10784>>>>>        Send DefineParam to hDispatchDriver OLE_VT_VARIANT llValue
10785>>>>>        Send InvokeComMethod to hDispatchDriver 2 OLE_VT_VOID
10786>>>>>    End_Procedure
10787>>>>>
10787>>>>>    Procedure ComRemove Integer llIndex
10789>>>>>        Handle hDispatchDriver
10789>>>>>        Get phDispatchDriver to hDispatchDriver
10790>>>>>        Send PrepareParams to hDispatchDriver 1
10791>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
10792>>>>>        Send InvokeComMethod to hDispatchDriver 3 OLE_VT_VOID
10793>>>>>    End_Procedure
10794>>>>>
10794>>>>>    Procedure ComClear
10796>>>>>        Handle hDispatchDriver
10796>>>>>        Get phDispatchDriver to hDispatchDriver
10797>>>>>        Send InvokeComMethod to hDispatchDriver 4 OLE_VT_VOID
10798>>>>>    End_Procedure
10799>>>>>
10799>>>>>    Procedure ComReserve Integer llSize
10801>>>>>        Handle hDispatchDriver
10801>>>>>        Get phDispatchDriver to hDispatchDriver
10802>>>>>        Send PrepareParams to hDispatchDriver 1
10803>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llSize
10804>>>>>        Send InvokeComMethod to hDispatchDriver 5 OLE_VT_VOID
10805>>>>>    End_Procedure
10806>>>>>
10806>>>>>    Function ComAddNew Returns Variant
10808>>>>>        Handle hDispatchDriver
10808>>>>>        Variant retVal
10808>>>>>        Get phDispatchDriver to hDispatchDriver
10809>>>>>        Get InvokeComMethod of hDispatchDriver 6 OLE_VT_VARIANT to retVal
10810>>>>>        Function_Return retVal
10811>>>>>    End_Function
10812>>>>>End_Class
10813>>>>>
10813>>>>>// CLSID: {F6F51E9B-6254-47F7-9603-8287D3871691}
10813>>>>>Class cComIEvoTypeBuilder is a cComAutomationObject
10814>>>>>
10814>>>>>    Function ComCreateBool Returns Variant
10816>>>>>        Handle hDispatchDriver
10816>>>>>        Variant retVal
10816>>>>>        Get phDispatchDriver to hDispatchDriver
10817>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_DISPATCH to retVal
10818>>>>>        Function_Return retVal
10819>>>>>    End_Function
10820>>>>>
10820>>>>>    Function ComCreateByte Returns Variant
10822>>>>>        Handle hDispatchDriver
10822>>>>>        Variant retVal
10822>>>>>        Get phDispatchDriver to hDispatchDriver
10823>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_DISPATCH to retVal
10824>>>>>        Function_Return retVal
10825>>>>>    End_Function
10826>>>>>
10826>>>>>    Function ComCreateInt16 Returns Variant
10828>>>>>        Handle hDispatchDriver
10828>>>>>        Variant retVal
10828>>>>>        Get phDispatchDriver to hDispatchDriver
10829>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_DISPATCH to retVal
10830>>>>>        Function_Return retVal
10831>>>>>    End_Function
10832>>>>>
10832>>>>>    Function ComCreateInt32 Returns Variant
10834>>>>>        Handle hDispatchDriver
10834>>>>>        Variant retVal
10834>>>>>        Get phDispatchDriver to hDispatchDriver
10835>>>>>        Get InvokeComMethod of hDispatchDriver 4 OLE_VT_DISPATCH to retVal
10836>>>>>        Function_Return retVal
10837>>>>>    End_Function
10838>>>>>
10838>>>>>    Function ComCreateInt64 Returns Variant
10840>>>>>        Handle hDispatchDriver
10840>>>>>        Variant retVal
10840>>>>>        Get phDispatchDriver to hDispatchDriver
10841>>>>>        Get InvokeComMethod of hDispatchDriver 5 OLE_VT_DISPATCH to retVal
10842>>>>>        Function_Return retVal
10843>>>>>    End_Function
10844>>>>>
10844>>>>>    Function ComCreateDouble Returns Variant
10846>>>>>        Handle hDispatchDriver
10846>>>>>        Variant retVal
10846>>>>>        Get phDispatchDriver to hDispatchDriver
10847>>>>>        Get InvokeComMethod of hDispatchDriver 6 OLE_VT_DISPATCH to retVal
10848>>>>>        Function_Return retVal
10849>>>>>    End_Function
10850>>>>>
10850>>>>>    Function ComCreateString Returns Variant
10852>>>>>        Handle hDispatchDriver
10852>>>>>        Variant retVal
10852>>>>>        Get phDispatchDriver to hDispatchDriver
10853>>>>>        Get InvokeComMethod of hDispatchDriver 7 OLE_VT_DISPATCH to retVal
10854>>>>>        Function_Return retVal
10855>>>>>    End_Function
10856>>>>>
10856>>>>>    Function ComCreateMap Variant llKeyType Variant llValueType Returns Variant
10858>>>>>        Handle hDispatchDriver
10858>>>>>        Variant retVal
10858>>>>>        Get phDispatchDriver to hDispatchDriver
10859>>>>>        Send PrepareParams to hDispatchDriver 2
10860>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llKeyType
10861>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llValueType
10862>>>>>        Get InvokeComMethod of hDispatchDriver 8 OLE_VT_DISPATCH to retVal
10863>>>>>        Function_Return retVal
10864>>>>>    End_Function
10865>>>>>
10865>>>>>    Function ComCreateSet Variant llContainedType Returns Variant
10867>>>>>        Handle hDispatchDriver
10867>>>>>        Variant retVal
10867>>>>>        Get phDispatchDriver to hDispatchDriver
10868>>>>>        Send PrepareParams to hDispatchDriver 1
10869>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llContainedType
10870>>>>>        Get InvokeComMethod of hDispatchDriver 9 OLE_VT_DISPATCH to retVal
10871>>>>>        Function_Return retVal
10872>>>>>    End_Function
10873>>>>>
10873>>>>>    Function ComCreateList Variant llContainedType Returns Variant
10875>>>>>        Handle hDispatchDriver
10875>>>>>        Variant retVal
10875>>>>>        Get phDispatchDriver to hDispatchDriver
10876>>>>>        Send PrepareParams to hDispatchDriver 1
10877>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llContainedType
10878>>>>>        Get InvokeComMethod of hDispatchDriver 10 OLE_VT_DISPATCH to retVal
10879>>>>>        Function_Return retVal
10880>>>>>    End_Function
10881>>>>>
10881>>>>>    Function ComCreateDate Returns Variant
10883>>>>>        Handle hDispatchDriver
10883>>>>>        Variant retVal
10883>>>>>        Get phDispatchDriver to hDispatchDriver
10884>>>>>        Get InvokeComMethod of hDispatchDriver 11 OLE_VT_DISPATCH to retVal
10885>>>>>        Function_Return retVal
10886>>>>>    End_Function
10887>>>>>
10887>>>>>    Function ComCreateDateTime Returns Variant
10889>>>>>        Handle hDispatchDriver
10889>>>>>        Variant retVal
10889>>>>>        Get phDispatchDriver to hDispatchDriver
10890>>>>>        Get InvokeComMethod of hDispatchDriver 12 OLE_VT_DISPATCH to retVal
10891>>>>>        Function_Return retVal
10892>>>>>    End_Function
10893>>>>>
10893>>>>>    Function ComCreateBinary Returns Variant
10895>>>>>        Handle hDispatchDriver
10895>>>>>        Variant retVal
10895>>>>>        Get phDispatchDriver to hDispatchDriver
10896>>>>>        Get InvokeComMethod of hDispatchDriver 13 OLE_VT_DISPATCH to retVal
10897>>>>>        Function_Return retVal
10898>>>>>    End_Function
10899>>>>>
10899>>>>>    Function ComCreateDecimal Returns Variant
10901>>>>>        Handle hDispatchDriver
10901>>>>>        Variant retVal
10901>>>>>        Get phDispatchDriver to hDispatchDriver
10902>>>>>        Get InvokeComMethod of hDispatchDriver 14 OLE_VT_DISPATCH to retVal
10903>>>>>        Function_Return retVal
10904>>>>>    End_Function
10905>>>>>End_Class
10906>>>>>
10906>>>>>// CLSID: {7604CA2D-8AF5-4895-9AA2-5677115A75D6}
10906>>>>>Class cComIEvoScalar is a cComAutomationObject
10907>>>>>
10907>>>>>    Function ComKind Returns OLEEVO_TYPES
10909>>>>>        Handle hDispatchDriver
10909>>>>>        OLEEVO_TYPES retVal
10909>>>>>        Get phDispatchDriver to hDispatchDriver
10910>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_I4 to retVal
10911>>>>>        Function_Return retVal
10912>>>>>    End_Function
10913>>>>>
10913>>>>>    Function ComType Returns OLEEVO_SCALARS
10915>>>>>        Handle hDispatchDriver
10915>>>>>        OLEEVO_SCALARS retVal
10915>>>>>        Get phDispatchDriver to hDispatchDriver
10916>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_I4 to retVal
10917>>>>>        Function_Return retVal
10918>>>>>    End_Function
10919>>>>>End_Class
10920>>>>>
10920>>>>>// CLSID: {0225D5B3-F610-47D2-BD3E-03A4C5CBD1D8}
10920>>>>>Class cComIEvoMap is a cComAutomationObject
10921>>>>>
10921>>>>>    Function ComKind Returns OLEEVO_TYPES
10923>>>>>        Handle hDispatchDriver
10923>>>>>        OLEEVO_TYPES retVal
10923>>>>>        Get phDispatchDriver to hDispatchDriver
10924>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_I4 to retVal
10925>>>>>        Function_Return retVal
10926>>>>>    End_Function
10927>>>>>
10927>>>>>    Function ComKeyType Returns Variant
10929>>>>>        Handle hDispatchDriver
10929>>>>>        Variant retVal
10929>>>>>        Get phDispatchDriver to hDispatchDriver
10930>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_DISPATCH to retVal
10931>>>>>        Function_Return retVal
10932>>>>>    End_Function
10933>>>>>
10933>>>>>    Function ComValueType Returns Variant
10935>>>>>        Handle hDispatchDriver
10935>>>>>        Variant retVal
10935>>>>>        Get phDispatchDriver to hDispatchDriver
10936>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_DISPATCH to retVal
10937>>>>>        Function_Return retVal
10938>>>>>    End_Function
10939>>>>>End_Class
10940>>>>>
10940>>>>>// CLSID: {B090843B-D9AB-4A44-85B4-B878F0855F16}
10940>>>>>Class cComIEvoList is a cComAutomationObject
10941>>>>>
10941>>>>>    Function ComKind Returns OLEEVO_TYPES
10943>>>>>        Handle hDispatchDriver
10943>>>>>        OLEEVO_TYPES retVal
10943>>>>>        Get phDispatchDriver to hDispatchDriver
10944>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_I4 to retVal
10945>>>>>        Function_Return retVal
10946>>>>>    End_Function
10947>>>>>
10947>>>>>    Function ComContainedType Returns Variant
10949>>>>>        Handle hDispatchDriver
10949>>>>>        Variant retVal
10949>>>>>        Get phDispatchDriver to hDispatchDriver
10950>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_DISPATCH to retVal
10951>>>>>        Function_Return retVal
10952>>>>>    End_Function
10953>>>>>End_Class
10954>>>>>
10954>>>>>// CLSID: {13BD6B34-E357-47F7-AF41-58234C57242C}
10954>>>>>Class cComIEvoStructBuilder is a cComAutomationObject
10955>>>>>
10955>>>>>    Procedure ComAddField Integer llId String llName String llDescription Variant llType Integer llFlags
10957>>>>>        Handle hDispatchDriver
10957>>>>>        Get phDispatchDriver to hDispatchDriver
10958>>>>>        Send PrepareParams to hDispatchDriver 5
10959>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llId
10960>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llName
10961>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llDescription
10962>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llType
10963>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llFlags
10964>>>>>        Send InvokeComMethod to hDispatchDriver 1 OLE_VT_VOID
10965>>>>>    End_Procedure
10966>>>>>
10966>>>>>    Function ComCreateStruct String llName String llDescription Returns Variant
10968>>>>>        Handle hDispatchDriver
10968>>>>>        Variant retVal
10968>>>>>        Get phDispatchDriver to hDispatchDriver
10969>>>>>        Send PrepareParams to hDispatchDriver 2
10970>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llName
10971>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llDescription
10972>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_DISPATCH to retVal
10973>>>>>        Function_Return retVal
10974>>>>>    End_Function
10975>>>>>
10975>>>>>    Function ComCreatePrototype Returns Variant
10977>>>>>        Handle hDispatchDriver
10977>>>>>        Variant retVal
10977>>>>>        Get phDispatchDriver to hDispatchDriver
10978>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_DISPATCH to retVal
10979>>>>>        Function_Return retVal
10980>>>>>    End_Function
10981>>>>>
10981>>>>>    Procedure ComAddPrivateField Integer llId String llName String llDescription Variant llType Variant llValue
10983>>>>>        Handle hDispatchDriver
10983>>>>>        Get phDispatchDriver to hDispatchDriver
10984>>>>>        Send PrepareParams to hDispatchDriver 5
10985>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llId
10986>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llName
10987>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llDescription
10988>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llType
10989>>>>>        Send DefineParam to hDispatchDriver OLE_VT_VARIANT llValue
10990>>>>>        Send InvokeComMethod to hDispatchDriver 4 OLE_VT_VOID
10991>>>>>    End_Procedure
10992>>>>>
10992>>>>>    // (Member is disabled because of invalid return type or parameter type)
10992>>>>>    //Function ComCreateStructWithGuid String llName String llDescription  llGuid Returns Variant
10992>>>>>        //Handle hDispatchDriver
10992>>>>>        //Variant retVal
10992>>>>>        //Get phDispatchDriver to hDispatchDriver
10992>>>>>        //Send PrepareParams to hDispatchDriver 3
10992>>>>>        //Send DefineParam to hDispatchDriver OLE_VT_BSTR llName
10992>>>>>        //Send DefineParam to hDispatchDriver OLE_VT_BSTR llDescription
10992>>>>>        //Send DefineParam to hDispatchDriver OLE_VT_RECORD llGuid
10992>>>>>        //Get InvokeComMethod of hDispatchDriver 5 OLE_VT_DISPATCH to retVal
10992>>>>>        //Function_Return retVal
10992>>>>>    //End_Function
10992>>>>>End_Class
10993>>>>>
10993>>>>>// CLSID: {9A2C4B19-8EB3-47B5-B4C2-86458EFEAD1F}
10993>>>>>Class cComIEvoStruct is a cComAutomationObject
10994>>>>>
10994>>>>>    Function ComKind Returns OLEEVO_TYPES
10996>>>>>        Handle hDispatchDriver
10996>>>>>        OLEEVO_TYPES retVal
10996>>>>>        Get phDispatchDriver to hDispatchDriver
10997>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_I4 to retVal
10998>>>>>        Function_Return retVal
10999>>>>>    End_Function
11000>>>>>
11000>>>>>    Function ComName Returns String
11002>>>>>        Handle hDispatchDriver
11002>>>>>        String retVal
11002>>>>>        Get phDispatchDriver to hDispatchDriver
11003>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_BSTR to retVal
11004>>>>>        Function_Return retVal
11005>>>>>    End_Function
11006>>>>>
11006>>>>>    Function ComFields Returns Variant
11008>>>>>        Handle hDispatchDriver
11008>>>>>        Variant retVal
11008>>>>>        Get phDispatchDriver to hDispatchDriver
11009>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_DISPATCH to retVal
11010>>>>>        Function_Return retVal
11011>>>>>    End_Function
11012>>>>>
11012>>>>>    // (Member is disabled because of invalid return type or parameter type)
11012>>>>>    //{ MethodType=Property DesignTime=False }
11012>>>>>    //Function ComGuid Returns 
11012>>>>>        //Handle hDispatchDriver
11012>>>>>        // retVal
11012>>>>>        //Get phDispatchDriver to hDispatchDriver
11012>>>>>        //Get InvokeComMethod of hDispatchDriver 4 OLE_VT_RECORD to retVal
11012>>>>>        //Function_Return retVal
11012>>>>>    //End_Function
11012>>>>>
11012>>>>>    Function ComDescription Returns String
11014>>>>>        Handle hDispatchDriver
11014>>>>>        String retVal
11014>>>>>        Get phDispatchDriver to hDispatchDriver
11015>>>>>        Get InvokeComMethod of hDispatchDriver 5 OLE_VT_BSTR to retVal
11016>>>>>        Function_Return retVal
11017>>>>>    End_Function
11018>>>>>End_Class
11019>>>>>
11019>>>>>// CLSID: {5E6345DE-3620-49EA-8DB5-A42936B8E791}
11019>>>>>Class cComIEvoServiceBuilder is a cComAutomationObject
11020>>>>>
11020>>>>>    Procedure ComAddFunction Integer llId String llName String llDescription Variant llReturnType String llRetvalDescription Variant llPrototype Integer llFlags
11022>>>>>        Handle hDispatchDriver
11022>>>>>        Get phDispatchDriver to hDispatchDriver
11023>>>>>        Send PrepareParams to hDispatchDriver 7
11024>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llId
11025>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llName
11026>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llDescription
11027>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llReturnType
11028>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llRetvalDescription
11029>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llPrototype
11030>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llFlags
11031>>>>>        Send InvokeComMethod to hDispatchDriver 1 OLE_VT_VOID
11032>>>>>    End_Procedure
11033>>>>>
11033>>>>>    Procedure ComAddProcedure Integer llId String llName String llDescription Variant llPrototype Integer llFlags
11035>>>>>        Handle hDispatchDriver
11035>>>>>        Get phDispatchDriver to hDispatchDriver
11036>>>>>        Send PrepareParams to hDispatchDriver 5
11037>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llId
11038>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llName
11039>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llDescription
11040>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llPrototype
11041>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llFlags
11042>>>>>        Send InvokeComMethod to hDispatchDriver 2 OLE_VT_VOID
11043>>>>>    End_Procedure
11044>>>>>
11044>>>>>    Function ComCreateService String llName String llDescription Variant llExtends Returns Variant
11046>>>>>        Handle hDispatchDriver
11046>>>>>        Variant retVal
11046>>>>>        Get phDispatchDriver to hDispatchDriver
11047>>>>>        Send PrepareParams to hDispatchDriver 3
11048>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llName
11049>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llDescription
11050>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llExtends
11051>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_DISPATCH to retVal
11052>>>>>        Function_Return retVal
11053>>>>>    End_Function
11054>>>>>
11054>>>>>    Function ComCreateServiceWithCustomExceptionData String llName String llDescription Variant llExceptionData Returns Variant
11056>>>>>        Handle hDispatchDriver
11056>>>>>        Variant retVal
11056>>>>>        Get phDispatchDriver to hDispatchDriver
11057>>>>>        Send PrepareParams to hDispatchDriver 3
11058>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llName
11059>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llDescription
11060>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llExceptionData
11061>>>>>        Get InvokeComMethod of hDispatchDriver 4 OLE_VT_DISPATCH to retVal
11062>>>>>        Function_Return retVal
11063>>>>>    End_Function
11064>>>>>End_Class
11065>>>>>
11065>>>>>// CLSID: {28B94B6D-98C8-4F28-B2C3-39D307D5E13E}
11065>>>>>Class cComIEvoService is a cComAutomationObject
11066>>>>>
11066>>>>>    Function ComName Returns String
11068>>>>>        Handle hDispatchDriver
11068>>>>>        String retVal
11068>>>>>        Get phDispatchDriver to hDispatchDriver
11069>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_BSTR to retVal
11070>>>>>        Function_Return retVal
11071>>>>>    End_Function
11072>>>>>
11072>>>>>    Function ComExtends Returns Variant
11074>>>>>        Handle hDispatchDriver
11074>>>>>        Variant retVal
11074>>>>>        Get phDispatchDriver to hDispatchDriver
11075>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_DISPATCH to retVal
11076>>>>>        Function_Return retVal
11077>>>>>    End_Function
11078>>>>>
11078>>>>>    Function ComMethods Returns Variant
11080>>>>>        Handle hDispatchDriver
11080>>>>>        Variant retVal
11080>>>>>        Get phDispatchDriver to hDispatchDriver
11081>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_DISPATCH to retVal
11082>>>>>        Function_Return retVal
11083>>>>>    End_Function
11084>>>>>
11084>>>>>    Function ComIDL Returns String
11086>>>>>        Handle hDispatchDriver
11086>>>>>        String retVal
11086>>>>>        Get phDispatchDriver to hDispatchDriver
11087>>>>>        Get InvokeComMethod of hDispatchDriver 4 OLE_VT_BSTR to retVal
11088>>>>>        Function_Return retVal
11089>>>>>    End_Function
11090>>>>>
11090>>>>>    Function ComExceptionData Returns Variant
11092>>>>>        Handle hDispatchDriver
11092>>>>>        Variant retVal
11092>>>>>        Get phDispatchDriver to hDispatchDriver
11093>>>>>        Get InvokeComMethod of hDispatchDriver 5 OLE_VT_DISPATCH to retVal
11094>>>>>        Function_Return retVal
11095>>>>>    End_Function
11096>>>>>
11096>>>>>    Function ComWSDL Returns String
11098>>>>>        Handle hDispatchDriver
11098>>>>>        String retVal
11098>>>>>        Get phDispatchDriver to hDispatchDriver
11099>>>>>        Get InvokeComMethod of hDispatchDriver 6 OLE_VT_BSTR to retVal
11100>>>>>        Function_Return retVal
11101>>>>>    End_Function
11102>>>>>
11102>>>>>    Function ComDescription Returns String
11104>>>>>        Handle hDispatchDriver
11104>>>>>        String retVal
11104>>>>>        Get phDispatchDriver to hDispatchDriver
11105>>>>>        Get InvokeComMethod of hDispatchDriver 7 OLE_VT_BSTR to retVal
11106>>>>>        Function_Return retVal
11107>>>>>    End_Function
11108>>>>>
11108>>>>>    Function ComWADL Returns String
11110>>>>>        Handle hDispatchDriver
11110>>>>>        String retVal
11110>>>>>        Get phDispatchDriver to hDispatchDriver
11111>>>>>        Get InvokeComMethod of hDispatchDriver 8 OLE_VT_BSTR to retVal
11112>>>>>        Function_Return retVal
11113>>>>>    End_Function
11114>>>>>
11114>>>>>    Function ComProto Returns String
11116>>>>>        Handle hDispatchDriver
11116>>>>>        String retVal
11116>>>>>        Get phDispatchDriver to hDispatchDriver
11117>>>>>        Get InvokeComMethod of hDispatchDriver 9 OLE_VT_BSTR to retVal
11118>>>>>        Function_Return retVal
11119>>>>>    End_Function
11120>>>>>End_Class
11121>>>>>
11121>>>>>// CLSID: {2FCEEDA5-6697-4CB7-9B70-C9622BE7111E}
11121>>>>>Class cComIEvoRuntime is a cComAutomationObject
11122>>>>>
11122>>>>>    Procedure ComSetErrorInfo String llMessage
11124>>>>>        Handle hDispatchDriver
11124>>>>>        Get phDispatchDriver to hDispatchDriver
11125>>>>>        Send PrepareParams to hDispatchDriver 1
11126>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llMessage
11127>>>>>        Send InvokeComMethod to hDispatchDriver 1 OLE_VT_VOID
11128>>>>>    End_Procedure
11129>>>>>
11129>>>>>    Function ComCreateErrorInfoData Returns Variant
11131>>>>>        Handle hDispatchDriver
11131>>>>>        Variant retVal
11131>>>>>        Get phDispatchDriver to hDispatchDriver
11132>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_VARIANT to retVal
11133>>>>>        Function_Return retVal
11134>>>>>    End_Function
11135>>>>>
11135>>>>>    Procedure ComSetErrorInfoWithData String llMessage Variant llData
11137>>>>>        Handle hDispatchDriver
11137>>>>>        Get phDispatchDriver to hDispatchDriver
11138>>>>>        Send PrepareParams to hDispatchDriver 2
11139>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llMessage
11140>>>>>        Send DefineParam to hDispatchDriver OLE_VT_VARIANT llData
11141>>>>>        Send InvokeComMethod to hDispatchDriver 3 OLE_VT_VOID
11142>>>>>    End_Procedure
11143>>>>>
11143>>>>>    Procedure ComResetErrorInfo
11145>>>>>        Handle hDispatchDriver
11145>>>>>        Get phDispatchDriver to hDispatchDriver
11146>>>>>        Send InvokeComMethod to hDispatchDriver 4 OLE_VT_VOID
11147>>>>>    End_Procedure
11148>>>>>
11148>>>>>    Function ComJWT Returns Variant
11150>>>>>        Handle hDispatchDriver
11150>>>>>        Variant retVal
11150>>>>>        String sRetVal
11150>>>>>        Move "" to sRetVal
11151>>>>>        Get phDispatchDriver to hDispatchDriver
11152>>>>>        Get InvokeComMethod of hDispatchDriver 6 OLE_VT_BSTR to sRetVal
11153>>>>>        If (sRetVal <> "") Begin
11155>>>>>            Get InvokeComMethod of hDispatchDriver 5 OLE_VT_VARIANT to retVal
11156>>>>>        End
11156>>>>>>
11156>>>>>        Function_Return retVal
11157>>>>>    End_Function
11158>>>>>
11158>>>>>    Function ComJWS Returns String
11160>>>>>        Handle hDispatchDriver
11160>>>>>        String retVal
11160>>>>>        Get phDispatchDriver to hDispatchDriver
11161>>>>>        Get InvokeComMethod of hDispatchDriver 6 OLE_VT_BSTR to retVal
11162>>>>>        Function_Return retVal
11163>>>>>    End_Function
11164>>>>>    
11164>>>>>    Procedure ComHeartbeat
11166>>>>>        Handle hDispatchDriver
11166>>>>>        Get phDispatchDriver to hDispatchDriver
11167>>>>>        Send InvokeComMethod to hDispatchDriver 7 OLE_VT_VOID
11168>>>>>    End_Procedure    
11169>>>>>End_Class
11170>>>>>
11170>>>>>// CLSID: {60BF5709-ADBD-44E0-8A5E-372096E83149}
11170>>>>>Class cComIEvoServiceRuntimeCollection is a cComAutomationObject
11171>>>>>
11171>>>>>    Function Com_NewEnum Returns Variant
11173>>>>>        Handle hDispatchDriver
11173>>>>>        Variant retVal
11173>>>>>        Get phDispatchDriver to hDispatchDriver
11174>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
11175>>>>>        Function_Return retVal
11176>>>>>    End_Function
11177>>>>>
11177>>>>>    Function ComItem Integer llIndex Returns Variant
11179>>>>>        Handle hDispatchDriver
11179>>>>>        Variant retVal
11179>>>>>        Get phDispatchDriver to hDispatchDriver
11180>>>>>        Send PrepareParams to hDispatchDriver 1
11181>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
11182>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
11183>>>>>        Function_Return retVal
11184>>>>>    End_Function
11185>>>>>
11185>>>>>    Function ComCount Returns Integer
11187>>>>>        Handle hDispatchDriver
11187>>>>>        Integer retVal
11187>>>>>        Get phDispatchDriver to hDispatchDriver
11188>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_I4 to retVal
11189>>>>>        Function_Return retVal
11190>>>>>    End_Function
11191>>>>>
11191>>>>>    Procedure ComAdd Variant llServiceRuntime
11193>>>>>        Handle hDispatchDriver
11193>>>>>        Get phDispatchDriver to hDispatchDriver
11194>>>>>        Send PrepareParams to hDispatchDriver 1
11195>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llServiceRuntime
11196>>>>>        Send InvokeComMethod to hDispatchDriver 2 OLE_VT_VOID
11197>>>>>    End_Procedure
11198>>>>>
11198>>>>>    Procedure ComRemove Integer llIndex
11200>>>>>        Handle hDispatchDriver
11200>>>>>        Get phDispatchDriver to hDispatchDriver
11201>>>>>        Send PrepareParams to hDispatchDriver 1
11202>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
11203>>>>>        Send InvokeComMethod to hDispatchDriver 3 OLE_VT_VOID
11204>>>>>    End_Procedure
11205>>>>>End_Class
11206>>>>>
11206>>>>>// CLSID: {3F222A3B-68A7-4059-9A84-FBB42096401B}
11206>>>>>Class cComIEvoSimpleServerSettings is a cComAutomationObject
11207>>>>>
11207>>>>>    Function ComTcpPort Returns UShort
11209>>>>>        Handle hDispatchDriver
11209>>>>>        UShort retVal
11209>>>>>        Get phDispatchDriver to hDispatchDriver
11210>>>>>        Get InvokeComMethod of hDispatchDriver 10 OLE_VT_UI2 to retVal
11211>>>>>        Function_Return retVal
11212>>>>>    End_Function
11213>>>>>
11213>>>>>    Procedure Set ComTcpPort UShort value
11215>>>>>        Handle hDispatchDriver
11215>>>>>        Get phDispatchDriver to hDispatchDriver
11216>>>>>        Send PrepareParams to hDispatchDriver 1
11217>>>>>        Set ComProperty of hDispatchDriver 10 OLE_VT_UI2 to value
11218>>>>>    End_Procedure
11219>>>>>
11219>>>>>    Function ComServerTransport Returns OLEEVO_TRANSPORTS
11221>>>>>        Handle hDispatchDriver
11221>>>>>        OLEEVO_TRANSPORTS retVal
11221>>>>>        Get phDispatchDriver to hDispatchDriver
11222>>>>>        Get InvokeComMethod of hDispatchDriver 20 OLE_VT_I4 to retVal
11223>>>>>        Function_Return retVal
11224>>>>>    End_Function
11225>>>>>
11225>>>>>    Procedure Set ComServerTransport OLEEVO_TRANSPORTS value
11227>>>>>        Handle hDispatchDriver
11227>>>>>        Get phDispatchDriver to hDispatchDriver
11228>>>>>        Send PrepareParams to hDispatchDriver 1
11229>>>>>        Set ComProperty of hDispatchDriver 20 OLE_VT_I4 to value
11230>>>>>    End_Procedure
11231>>>>>
11231>>>>>    Function ComServerProtocol Returns OLEEVO_PROTOCOLS
11233>>>>>        Handle hDispatchDriver
11233>>>>>        OLEEVO_PROTOCOLS retVal
11233>>>>>        Get phDispatchDriver to hDispatchDriver
11234>>>>>        Get InvokeComMethod of hDispatchDriver 30 OLE_VT_I4 to retVal
11235>>>>>        Function_Return retVal
11236>>>>>    End_Function
11237>>>>>
11237>>>>>    Procedure Set ComServerProtocol OLEEVO_PROTOCOLS value
11239>>>>>        Handle hDispatchDriver
11239>>>>>        Get phDispatchDriver to hDispatchDriver
11240>>>>>        Send PrepareParams to hDispatchDriver 1
11241>>>>>        Set ComProperty of hDispatchDriver 30 OLE_VT_I4 to value
11242>>>>>    End_Procedure
11243>>>>>
11243>>>>>    Function ComLocalizeDatetime Returns Boolean
11245>>>>>        Handle hDispatchDriver
11245>>>>>        Boolean retVal
11245>>>>>        Get phDispatchDriver to hDispatchDriver
11246>>>>>        Get InvokeComMethod of hDispatchDriver 40 OLE_VT_BOOL to retVal
11247>>>>>        Function_Return retVal
11248>>>>>    End_Function
11249>>>>>
11249>>>>>    Procedure Set ComLocalizeDatetime Boolean value
11251>>>>>        Handle hDispatchDriver
11251>>>>>        Get phDispatchDriver to hDispatchDriver
11252>>>>>        Send PrepareParams to hDispatchDriver 1
11253>>>>>        Set ComProperty of hDispatchDriver 40 OLE_VT_BOOL to value
11254>>>>>    End_Procedure
11255>>>>>
11255>>>>>    Function ComStringEncoding Returns OLEEVO_ENCODINGS
11257>>>>>        Handle hDispatchDriver
11257>>>>>        OLEEVO_ENCODINGS retVal
11257>>>>>        Get phDispatchDriver to hDispatchDriver
11258>>>>>        Get InvokeComMethod of hDispatchDriver 50 OLE_VT_I4 to retVal
11259>>>>>        Function_Return retVal
11260>>>>>    End_Function
11261>>>>>
11261>>>>>    Procedure Set ComStringEncoding OLEEVO_ENCODINGS value
11263>>>>>        Handle hDispatchDriver
11263>>>>>        Get phDispatchDriver to hDispatchDriver
11264>>>>>        Send PrepareParams to hDispatchDriver 1
11265>>>>>        Set ComProperty of hDispatchDriver 50 OLE_VT_I4 to value
11266>>>>>    End_Procedure
11267>>>>>
11267>>>>>    Function ComIncomingJwtConfigurations Returns String
11269>>>>>        Handle hDispatchDriver
11269>>>>>        String retVal
11269>>>>>        Get phDispatchDriver to hDispatchDriver
11270>>>>>        Get InvokeComMethod of hDispatchDriver 60 OLE_VT_BSTR to retVal
11271>>>>>        Function_Return retVal
11272>>>>>    End_Function
11273>>>>>
11273>>>>>    Procedure Set ComIncomingJwtConfigurations String value
11275>>>>>        Handle hDispatchDriver
11275>>>>>        Get phDispatchDriver to hDispatchDriver
11276>>>>>        Send PrepareParams to hDispatchDriver 1
11277>>>>>        Set ComProperty of hDispatchDriver 60 OLE_VT_BSTR to value
11278>>>>>    End_Procedure
11279>>>>>
11279>>>>>    Function ComOutgoingJwtConfiguration Returns String
11281>>>>>        Handle hDispatchDriver
11281>>>>>        String retVal
11281>>>>>        Get phDispatchDriver to hDispatchDriver
11282>>>>>        Get InvokeComMethod of hDispatchDriver 70 OLE_VT_BSTR to retVal
11283>>>>>        Function_Return retVal
11284>>>>>    End_Function
11285>>>>>
11285>>>>>    Procedure Set ComOutgoingJwtConfiguration String value
11287>>>>>        Handle hDispatchDriver
11287>>>>>        Get phDispatchDriver to hDispatchDriver
11288>>>>>        Send PrepareParams to hDispatchDriver 1
11289>>>>>        Set ComProperty of hDispatchDriver 70 OLE_VT_BSTR to value
11290>>>>>    End_Procedure
11291>>>>>End_Class
11292>>>>>
11292>>>>>// CLSID: {91BB24E5-0D9F-4A7B-9641-77727DAC8A38}
11292>>>>>Class cComIEvoConsole is a cComAutomationObject
11293>>>>>
11293>>>>>    Function ComConnect Variant llServer Variant llServices OLEEVO_MARSHALING_MODES llmode Returns UInteger
11295>>>>>        Handle hDispatchDriver
11295>>>>>        UInteger retVal
11295>>>>>        Get phDispatchDriver to hDispatchDriver
11296>>>>>        Send PrepareParams to hDispatchDriver 3
11297>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llServer
11298>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llServices
11299>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llmode
11300>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_UI4 to retVal
11301>>>>>        Function_Return retVal
11302>>>>>    End_Function
11303>>>>>
11303>>>>>    Procedure ComDisconnect UInteger llCookie
11305>>>>>        Handle hDispatchDriver
11305>>>>>        Get phDispatchDriver to hDispatchDriver
11306>>>>>        Send PrepareParams to hDispatchDriver 1
11307>>>>>        Send DefineParam to hDispatchDriver OLE_VT_UI4 llCookie
11308>>>>>        Send InvokeComMethod to hDispatchDriver 2 OLE_VT_VOID
11309>>>>>    End_Procedure
11310>>>>>
11310>>>>>    Function ComIsRunning Returns Boolean
11312>>>>>        Handle hDispatchDriver
11312>>>>>        Boolean retVal
11312>>>>>        Get phDispatchDriver to hDispatchDriver
11313>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_BOOL to retVal
11314>>>>>        Function_Return retVal
11315>>>>>    End_Function
11316>>>>>End_Class
11317>>>Use Dferror.pkg
Including file: Dferror.pkg    (C:\Program Files\DataFlex 26.0\Pkg\Dferror.pkg)
11317>>>>>Use cWindowsErrorHandler.pkg
Including file: cWindowsErrorHandler.pkg    (C:\Program Files\DataFlex 26.0\Pkg\cWindowsErrorHandler.pkg)
11317>>>>>>>Use cBaseErrorHandler.pkg
Including file: cBaseErrorHandler.pkg    (C:\Program Files\DataFlex 26.0\Pkg\cBaseErrorHandler.pkg)
11317>>>>>>>>>Use errornum.inc
11317>>>>>>>>>Use cTrappedErrors.pkg
Including file: cTrappedErrors.pkg    (C:\Program Files\DataFlex 26.0\Pkg\cTrappedErrors.pkg)
11317>>>>>>>>>>>Define MAX_ERROR_NUMBER for 32766
11317>>>>>>>>>>>
11317>>>>>>>>>>>// This array stores the set of trapped errors as toggled ranges starting
11317>>>>>>>>>>>// with the errors that are trapped. The array should always contain 0 and
11317>>>>>>>>>>>// MAX_ERROR_NUMBER + 1, which are the limits. If an array contained the
11317>>>>>>>>>>>// following items...
11317>>>>>>>>>>>//
11317>>>>>>>>>>>// { 0, 5, 10, MAX_ERROR_NUMBER + 1 }.
11317>>>>>>>>>>>//
11317>>>>>>>>>>>// This would mean that errors 1 - 4 are trapped, 5 - 9 are ignored, and
11317>>>>>>>>>>>// 10 through the rest are trapped.
11317>>>>>>>>>>>//
11317>>>>>>>>>>>Class cTrappedErrors is an array
11318>>>>>>>>>>>    Procedure Construct_Object
11320>>>>>>>>>>>        Forward Send Construct_Object
11322>>>>>>>>>>>        
11322>>>>>>>>>>>        Send initArray
11323>>>>>>>>>>>    End_Procedure
11324>>>>>>>>>>>    
11324>>>>>>>>>>>    // Find largest error LE targetError. Assumes array is sorted.
11324>>>>>>>>>>>    Function findErrorLE Integer targetError Returns Integer
11326>>>>>>>>>>>        
11326>>>>>>>>>>>        Integer lowIndex hiIndex midIndex currError
11326>>>>>>>>>>>        
11326>>>>>>>>>>>        // If error is outside of boudary conditions, use
11326>>>>>>>>>>>        // value of closest valid error# instead.
11326>>>>>>>>>>>        If (targetError <= 0);            Move 1 to targetError
11329>>>>>>>>>>>        Else If (targetError >= MAX_ERROR_NUMBER) ;            Move ( MAX_ERROR_NUMBER - 1 ) to targetError
11333>>>>>>>>>>>        
11333>>>>>>>>>>>        Move 0 to lowIndex
11334>>>>>>>>>>>        Move ( item_count( Self ) - 1 ) to hiIndex
11335>>>>>>>>>>>        
11335>>>>>>>>>>>        // midIndex will contain the closest error LE to target upon exit.
11335>>>>>>>>>>>        Repeat
11335>>>>>>>>>>>>
11335>>>>>>>>>>>            
11335>>>>>>>>>>>            Move ( ( lowIndex + hiIndex ) / 2 ) to midIndex
11336>>>>>>>>>>>            Move ( integer_value( Self, midIndex ) )  to currError
11337>>>>>>>>>>>            
11337>>>>>>>>>>>            // midIndex is targetIndex if a match occurs
11337>>>>>>>>>>>            If (currError = targetError) ;                Function_Return midIndex
11340>>>>>>>>>>>            
11340>>>>>>>>>>>            // We are either on it or just below it.
11340>>>>>>>>>>>            If ( lowIndex = midIndex ) Begin
11342>>>>>>>>>>>                
11342>>>>>>>>>>>                If ( integer_value( Self, hiIndex ) le targetError ) ;                    Move hiIndex to midIndex
11345>>>>>>>>>>>                
11345>>>>>>>>>>>                Function_Return midIndex
11346>>>>>>>>>>>                
11346>>>>>>>>>>>            End
11346>>>>>>>>>>>>
11346>>>>>>>>>>>            
11346>>>>>>>>>>>            // No match, so move the boundaries.
11346>>>>>>>>>>>            If (currError > targetError) ;                Move ( midIndex - 1 ) to hiIndex
11349>>>>>>>>>>>            Else ;                Move midIndex to lowIndex
11351>>>>>>>>>>>            
11351>>>>>>>>>>>        Until lowIndex gt hiIndex
11353>>>>>>>>>>>        
11353>>>>>>>>>>>        Function_Return midIndex
11354>>>>>>>>>>>        
11354>>>>>>>>>>>    End_Function
11355>>>>>>>>>>>    
11355>>>>>>>>>>>    // Boundaries of the table are assumed to hold error limits.
11355>>>>>>>>>>>    Procedure initArray
11357>>>>>>>>>>>        Send delete_data
11358>>>>>>>>>>>        Set array_value  0 to 0
11359>>>>>>>>>>>        Set array_value  1 to ( MAX_ERROR_NUMBER + 1 )
11360>>>>>>>>>>>    End_Procedure
11361>>>>>>>>>>>    
11361>>>>>>>>>>>    // Return 1 if Error is trapped, 0 otherwise.
11361>>>>>>>>>>>    Function IsTrapped Integer Error# Returns Integer
11363>>>>>>>>>>>        Function_Return ( not ( mod( findErrorLE( Self, Error# ), 2 ) ) )
11364>>>>>>>>>>>    End_Function
11365>>>>>>>>>>>    
11365>>>>>>>>>>>    // Add the error as long as it doesn't violate boundary conditions.
11365>>>>>>>>>>>    // This routine leaves the array unsorted.
11365>>>>>>>>>>>    Procedure addError Integer Error#
11367>>>>>>>>>>>        If ( ( Error# lt MAX_ERROR_NUMBER ) and ( Error# gt 0 ) ) ;            Set array_value  ( item_count( Self ) ) to ( Integer( Error# ) )
11370>>>>>>>>>>>    End_Procedure
11371>>>>>>>>>>>    
11371>>>>>>>>>>>    // Set error to flagged state.
11371>>>>>>>>>>>    Procedure handleError Integer Error# Integer trapFlag
11373>>>>>>>>>>>        
11373>>>>>>>>>>>        Integer prevErrIndex prevErrFlag prevErrValue nextErrValue
11373>>>>>>>>>>>        
11373>>>>>>>>>>>        If ( ( Error# gt MAX_ERROR_NUMBER ) or ( Error# lt 0 ) ) Begin
11375>>>>>>>>>>>            Error DFERR_ERROR_NUMBER_OUT_OF_RANGE
11376>>>>>>>>>>>>
11376>>>>>>>>>>>            Procedure_Return
11377>>>>>>>>>>>        End
11377>>>>>>>>>>>>
11377>>>>>>>>>>>        
11377>>>>>>>>>>>        Get findErrorLE Error# to prevErrIndex
11378>>>>>>>>>>>        Get isTrapped   Error# to prevErrFlag
11379>>>>>>>>>>>        
11379>>>>>>>>>>>        // if eq, Error already handled in some range.
11379>>>>>>>>>>>        If (PrevErrFlag <> trapFlag) Begin
11381>>>>>>>>>>>            
11381>>>>>>>>>>>            // This is kind of complicated. If we are adding an error,
11381>>>>>>>>>>>            // we have to account for the error already being in the
11381>>>>>>>>>>>            // array as well as rejoining ranges that have been previously
11381>>>>>>>>>>>            // split and splitting ranges when adding a new flag.
11381>>>>>>>>>>>            
11381>>>>>>>>>>>            Get integer_value  ( prevErrIndex + 1 ) to nextErrValue
11382>>>>>>>>>>>            Get integer_value  prevErrIndex         to prevErrValue
11383>>>>>>>>>>>            
11383>>>>>>>>>>>            // Do this first so prevErrIndex stays valid.
11383>>>>>>>>>>>            If (nextErrValue = ( Error# + 1 )) ;                Send delete_item ( prevErrIndex + 1 )
11386>>>>>>>>>>>            Else ;                Send addError ( Error# + 1 )
11388>>>>>>>>>>>            
11388>>>>>>>>>>>            If ( prevErrValue < Error# ) ;                Send addError Error#
11391>>>>>>>>>>>            Else ;                Send delete_item prevErrIndex
11393>>>>>>>>>>>        End
11393>>>>>>>>>>>>
11393>>>>>>>>>>>        Send sort_items UPWARD_DIRECTION
11394>>>>>>>>>>>        
11394>>>>>>>>>>>    End_Procedure
11395>>>>>>>>>>>    
11395>>>>>>>>>>>    // Flag error as trappable
11395>>>>>>>>>>>    Procedure Trap_Error Integer Error#
11397>>>>>>>>>>>        Send handleError Error# 1
11398>>>>>>>>>>>    End_Procedure
11399>>>>>>>>>>>    
11399>>>>>>>>>>>    // Flag error as non-trappable
11399>>>>>>>>>>>    Procedure Ignore_Error Integer Error#
11401>>>>>>>>>>>        Send handleError Error# 0
11402>>>>>>>>>>>    End_Procedure
11403>>>>>>>>>>>    
11403>>>>>>>>>>>    // Flag all errors as trappable
11403>>>>>>>>>>>    Procedure Trap_All
11405>>>>>>>>>>>        Send initArray
11406>>>>>>>>>>>    End_Procedure
11407>>>>>>>>>>>    
11407>>>>>>>>>>>    // Flag all errors as non-trappable
11407>>>>>>>>>>>    Procedure Ignore_All
11409>>>>>>>>>>>        Send delete_data
11410>>>>>>>>>>>        Set array_value 0 to 0
11411>>>>>>>>>>>        Set array_value 1 to 1
11412>>>>>>>>>>>        Set array_value 2 to ( MAX_ERROR_NUMBER + 1 )
11413>>>>>>>>>>>    End_Procedure
11414>>>>>>>>>>>End_Class
11415>>>>>>>>>>>
11415>>>>>>>>>Use LanguageText.pkg
11415>>>>>>>>>Use VdfBase.pkg
11415>>>>>>>>>
11415>>>>>>>>>// used by error handler and UserError to pull a caption out of the error string
11415>>>>>>>>>Define C_ErrorCaption for "*CAPTION*="
11415>>>>>>>>>
11415>>>>>>>>>Class cBaseErrorHandler is a cObject
11416>>>>>>>>>    Procedure Construct_Object
11418>>>>>>>>>        Forward Send Construct_Object
11420>>>>>>>>>        
11420>>>>>>>>>        Set delegation_mode to no_delegate_or_error
11421>>>>>>>>>        
11421>>>>>>>>>        // This is the caption that appears for unhandled errors dialog box
11421>>>>>>>>>        Property String psUnhandledErrorCaption C_$UnhandledProgramError
11422>>>>>>>>>        
11422>>>>>>>>>        // This is the caption that appears for standard user errors
11422>>>>>>>>>        Property String psUserErrorCaption C_$Error
11423>>>>>>>>>        
11423>>>>>>>>>        // If set false, this makes the error handler work the old way which
11423>>>>>>>>>        // does not use the new unhandled dialog. Only exists for compatibility reasons
11423>>>>>>>>>        Property Boolean pbUnhandledErrorSupport       True
11424>>>>>>>>>        
11424>>>>>>>>>        Property Boolean pbErrorProcessingState False  // Flag which is sent when error is being processed. This stops error recursion.
11425>>>>>>>>>        
11425>>>>>>>>>        Property Integer piCurrentErrorNumber     0
11426>>>>>>>>>        Property Integer piCurrentErrorLine        0
11427>>>>>>>>>        
11427>>>>>>>>>        Property Integer[] paUserErrors       // Collection of sorted error numbers considered to be user errors. (note, this array must remain sorted!)
11428>>>>>>>>>        
11428>>>>>>>>>        
11428>>>>>>>>>        Object oTrappedErrors is a cTrappedErrors
11430>>>>>>>>>        End_Object
11431>>>>>>>>>        
11431>>>>>>>>>        Send DefineStandardUserErrors
11432>>>>>>>>>        
11432>>>>>>>>>        Move Self to Error_Object_Id
11433>>>>>>>>>        Move Self to ghoErrorHandler
11434>>>>>>>>>    End_Procedure
11435>>>>>>>>>    
11435>>>>>>>>>    Procedure DefineStandardUserErrors
11437>>>>>>>>>        Integer[] aUserErrors
11438>>>>>>>>>        
11438>>>>>>>>>        // define the standard user error numbers....
11438>>>>>>>>>        Move 0                                     to aUserErrors[0]
11439>>>>>>>>>        Move DFERR_NUMBER_TOO_LARGE                to aUserErrors[1]
11440>>>>>>>>>        Move DFERR_WINDOW_RANGE                    to aUserErrors[2]
11441>>>>>>>>>        Move DFERR_ENTRY_REQUIRED                  to aUserErrors[3]
11442>>>>>>>>>        Move DFERR_ENTER_A_NUMBER                  to aUserErrors[4]
11443>>>>>>>>>        Move DFERR_BAD_ENTRY                       to aUserErrors[5]
11444>>>>>>>>>        Move DFERR_ENTER_VALID_DATE                to aUserErrors[6]
11445>>>>>>>>>        Move DFERR_NUMERIC_RANGE                   to aUserErrors[7]
11446>>>>>>>>>        Move DFERR_DUPLICATE_REC                   to aUserErrors[8]
11447>>>>>>>>>        Move DFERR_TEXT_FIELD_TOO_LONG             to aUserErrors[9]
11448>>>>>>>>>        Move DFERR_FIND_PRIOR_BEG_OF_FILE          to aUserErrors[10]
11449>>>>>>>>>        Move DFERR_FIND_PAST_END_OF_FILE           to aUserErrors[11]
11450>>>>>>>>>        Move DFERR_NO_REC_TO_DELETE                to aUserErrors[12]
11451>>>>>>>>>        Move DFERR_FIELD_NOT_INDEXED               to aUserErrors[13]
11452>>>>>>>>>        Move DFERR_REC_NUMBER_RANGE                to aUserErrors[14]
11453>>>>>>>>>        Move DFERR_ENTER_VALID_REC_ID              to aUserErrors[15]
11454>>>>>>>>>        Move DFERR_OPERATOR_ERROR                  to aUserErrors[16]
11455>>>>>>>>>        Move DFERR_CANT_CHANGE_KEY_FIELD           to aUserErrors[17]
11456>>>>>>>>>        Move DFERR_NO_DELETE_RELATED_RECORDS_EXIST to aUserErrors[18]
11457>>>>>>>>>        Move DFERR_OPERATION_NOT_ALLOWED           to aUserErrors[19]
11458>>>>>>>>>        Move DFERR_OPERATOR                        to aUserErrors[20]
11459>>>>>>>>>        Move DFERR_XML_HTTP                        to aUserErrors[21]
11460>>>>>>>>>        Move DFERR_CLIENT_SOAP_TRANSFER            to aUserErrors[22]
11461>>>>>>>>>        Move DFERR_CLIENT_SOAP_FAULT               to aUserErrors[23]
11462>>>>>>>>>        Move DFERR_TEXT_TOO_LARGE_FOR_FIELD        to aUserErrors[24]
11463>>>>>>>>>        Move DFERR_WINPRINT                        to aUserErrors[25]
11464>>>>>>>>>        Move DFERR_CRYSTAL_REPORT                  to aUserErrors[26]
11465>>>>>>>>>        Move DFERR_MAPI                            to aUserErrors[27]
11466>>>>>>>>>        Move DFERR_FILE_ACCESS_VIOLATION           to aUserErrors[28]
11467>>>>>>>>>        Move DFERR_DATAFLEX_REPORTS                to aUserErrors[29]
11468>>>>>>>>>        Move DFERR_CANT_REFIND_RECORD              to aUserErrors[30]
11469>>>>>>>>>        // WebApp Errors
11469>>>>>>>>>        Move DFERR_WEBAPP_ACCESS_DENIED            to aUserErrors[31]
11470>>>>>>>>>        // This is defined as DD_DEFAULT_ERROR_NUMBER in DataDict.pkg and is the default Field_error number of DDs.
11470>>>>>>>>>        Move 999                                   to aUserErrors[32]
11471>>>>>>>>>        // This is session timeout (we keep the old number 950 for backwards comatibility reasons)
11471>>>>>>>>>        Move DFERR_WEBAPP_SESSION_TIMEOUT          to aUserErrors[33]
11472>>>>>>>>>        // This is session timeout (we keep the old number 951 for backwards comatibility reasons)
11472>>>>>>>>>        Move DFERR_WEBAPP_BAD_SESSION_KEY          to aUserErrors[34]
11473>>>>>>>>>        Move DFERR_WEBAPP_INVALID_URL              to aUserErrors[35]
11474>>>>>>>>>        Move DFERR_WEBAPP_INVALID_URL_REC          to aUserErrors[36]
11475>>>>>>>>>        Move (SortArray(aUserErrors)) to aUserErrors
11476>>>>>>>>>        Set paUserErrors to aUserErrors
11477>>>>>>>>>    End_Procedure
11478>>>>>>>>>    
11478>>>>>>>>>    Procedure HandleError Integer iErrNum Integer iErrLine String sErrText
11480>>>>>>>>>        //  Stub method implemented by subclass
11480>>>>>>>>>    End_Procedure
11481>>>>>>>>>    
11481>>>>>>>>>    // Called by the runtime when an error occurs. Initiates the main error handling. Skips errors
11481>>>>>>>>>    // that are ignored and makes sure to prevent recursion by checking the error processing state.
11481>>>>>>>>>    Procedure Error_Report Integer iErrNum Integer iErrLine String sErrText
11483>>>>>>>>>        If (pbErrorProcessingState(Self)) ;            Procedure_Return
11486>>>>>>>>>            
11486>>>>>>>>>        If (not(IsTrapped(Self, iErrNum))) ;            Procedure_Return
11489>>>>>>>>>        
11489>>>>>>>>>        Set pbErrorProcessingState to True
11490>>>>>>>>>        Set piCurrentErrorNumber to iErrNum
11491>>>>>>>>>        Set piCurrentErrorLine to iErrLine
11492>>>>>>>>>        
11492>>>>>>>>>        Send HandleError iErrNum iErrLine sErrText
11493>>>>>>>>>        
11493>>>>>>>>>        Set piCurrentErrorNumber to 0
11494>>>>>>>>>        Set piCurrentErrorLine to 0
11495>>>>>>>>>        Move 0 to ghoErrorSource
11496>>>>>>>>>        Set pbErrorProcessingState to False
11497>>>>>>>>>    End_Procedure
11498>>>>>>>>>    
11498>>>>>>>>>    
11498>>>>>>>>>
11498>>>>>>>>>    
11498>>>>>>>>>    // Returns true if this is a user error (i.e. "find past end of file")
11498>>>>>>>>>    Function IsUserError Integer iError Returns Boolean
11500>>>>>>>>>        Integer[] aUserErrors
11501>>>>>>>>>        Get paUserErrors to aUserErrors
11502>>>>>>>>>        Function_Return (BinarySearchArray(iError, aUserErrors) <> -1)
11503>>>>>>>>>    End_Function
11504>>>>>>>>>    
11504>>>>>>>>>        // returns true if this is an unhandled error (i.e., not a user error
11504>>>>>>>>>    Function IsUnhandledError Integer iError Returns Boolean
11506>>>>>>>>>        Integer[] UserErrors
11507>>>>>>>>>        Get paUserErrors to UserErrors
11508>>>>>>>>>        Function_Return (SearchArray(iError,UserErrors)=-1)
11509>>>>>>>>>    End_Function
11510>>>>>>>>>    
11510>>>>>>>>>    Procedure AddUserError Integer iError
11512>>>>>>>>>        // adds a user error to the collection of defined 'user errors'
11512>>>>>>>>>        Integer[] aUserErrors
11513>>>>>>>>>        Get paUserErrors to aUserErrors
11514>>>>>>>>>        
11514>>>>>>>>>        If (BinarySearchArray(iError, aUserErrors) = -1) Begin
11516>>>>>>>>>            Move (InsertInArray(aUserErrors, BinarySearchInsertPos(), iError)) to aUserErrors         // Keep the array sorted. Makes searching fast, adding slower.
11517>>>>>>>>>            Set paUserErrors to aUserErrors
11518>>>>>>>>>        End
11518>>>>>>>>>>
11518>>>>>>>>>    End_Procedure
11519>>>>>>>>>    
11519>>>>>>>>>    Procedure RemoveUserError Integer iError
11521>>>>>>>>>        // Removes the passed error number from the set of user errors.
11521>>>>>>>>>        Integer iIndex
11521>>>>>>>>>        Integer[] aUserErrors
11522>>>>>>>>>        
11522>>>>>>>>>        Get paUserErrors to aUserErrors
11523>>>>>>>>>        Move (BinarySearchArray(iError, aUserErrors)) to iIndex
11524>>>>>>>>>        
11524>>>>>>>>>        If (iIndex <> -1) Begin
11526>>>>>>>>>            Move (RemoveFromArray(aUserErrors, iIndex)) to aUserErrors
11527>>>>>>>>>            Set paUserErrors to aUserErrors
11528>>>>>>>>>        End
11528>>>>>>>>>>
11528>>>>>>>>>    End_Procedure
11529>>>>>>>>>    
11529>>>>>>>>>    Procedure RemoveAllUserErrors
11531>>>>>>>>>        // Clears set of User Errors
11531>>>>>>>>>        Set paUserErrors to (ResizeArray(paUserErrors(Self), 0))
11532>>>>>>>>>    End_Procedure
11533>>>>>>>>>    
11533>>>>>>>>>    // return true if an error number is critical
11533>>>>>>>>>    Function IsCritical Integer iError Returns Boolean
11535>>>>>>>>>        Function_Return (".3.10.18.19.20.21.22.43.70.72.74.75.78.80.97.";            contains ("."+String(iError)+"."))
11536>>>>>>>>>    End_Function
11537>>>>>>>>>    
11537>>>>>>>>>    Procedure TrapError Integer iError
11539>>>>>>>>>        Send Trap_Error of oTrappedErrors iError
11540>>>>>>>>>    End_Procedure
11541>>>>>>>>>    
11541>>>>>>>>>    Procedure IgnoreError Integer iError
11543>>>>>>>>>        Send Ignore_Error of oTrappedErrors iError
11544>>>>>>>>>    End_Procedure
11545>>>>>>>>>    
11545>>>>>>>>>    Procedure IgnoreAllErrors
11547>>>>>>>>>        Send Ignore_All of oTrappedErrors
11548>>>>>>>>>    End_Procedure
11549>>>>>>>>>    
11549>>>>>>>>>    Procedure TrapAllErrors
11551>>>>>>>>>        Send Trap_All of oTrappedErrors
11552>>>>>>>>>    End_Procedure
11553>>>>>>>>>    
11553>>>>>>>>>    Function IsTrapped Integer iError  Returns Boolean
11555>>>>>>>>>        Function_Return (IsTrapped(oTrappedErrors,iError))
11556>>>>>>>>>    End_Function
11557>>>>>>>>>    
11557>>>>>>>>>    
11557>>>>>>>>>
11557>>>>>>>>>    
11557>>>>>>>>>    // Used to fetch the default error description.
11557>>>>>>>>>    //
11557>>>>>>>>>    // iError   - Error number
11557>>>>>>>>>    // sMessage - Additional error message
11557>>>>>>>>>    // Returns  - Complete error message
11557>>>>>>>>>    Function ErrorDescription Integer iError String sMessage Returns String
11559>>>>>>>>>        String sDescription
11559>>>>>>>>>        Boolean bAvailable
11559>>>>>>>>>        
11559>>>>>>>>>        //  Fetch system error text
11559>>>>>>>>>        Get Error_Text of Desktop iError to sDescription
11560>>>>>>>>>        Get Error_Text_Available of Desktop iError to bAvailable
11561>>>>>>>>>        
11561>>>>>>>>>        //  Trim both messages
11561>>>>>>>>>        Move (Trim(sDescription)) to sDescription
11562>>>>>>>>>        Move (Trim(sMessage)) to sMessage
11563>>>>>>>>>        
11563>>>>>>>>>        //  Append message if needed
11563>>>>>>>>>        If (sMessage <> "") Begin
11565>>>>>>>>>            If (sDescription <> "" and bAvailable) Begin
11567>>>>>>>>>                Move (sDescription + Character(13) + Character(13) + sMessage) to sDescription
11568>>>>>>>>>            End
11568>>>>>>>>>>
11568>>>>>>>>>            Else Begin
11569>>>>>>>>>                Move sMessage to sDescription
11570>>>>>>>>>            End
11570>>>>>>>>>>
11570>>>>>>>>>        End
11570>>>>>>>>>>
11570>>>>>>>>>        
11570>>>>>>>>>        Function_Return sDescription
11571>>>>>>>>>    End_Function
11572>>>>>>>>>    
11572>>>>>>>>>    // Legacy names here for backwards compatibility
11572>>>>>>>>>    Function Error_Description Integer iError String sMessage Returns String
11574>>>>>>>>>        Function_Return (ErrorDescription(Self, iError, sMessage))
11575>>>>>>>>>    End_Function
11576>>>>>>>>>    
11576>>>>>>>>>    
11576>>>>>>>>>    Function Error_processing_state Returns Boolean
11578>>>>>>>>>        Function_Return (pbErrorProcessingState(Self))
11579>>>>>>>>>    End_Function
11580>>>>>>>>>    
11580>>>>>>>>>    Function Current_Error_Number Returns Integer
11582>>>>>>>>>        Function_Return (piCurrentErrorNumber(Self))
11583>>>>>>>>>    End_Function
11584>>>>>>>>>    
11584>>>>>>>>>    Procedure Set Current_Error_Number Integer iErr
11586>>>>>>>>>        Set piCurrentErrorNumber to iErr
11587>>>>>>>>>    End_Procedure
11588>>>>>>>>>    
11588>>>>>>>>>    Function Error_Line_Number Returns Integer
11590>>>>>>>>>        Function_Return (piCurrentErrorLine(Self))
11591>>>>>>>>>    End_Function
11592>>>>>>>>>    
11592>>>>>>>>>    Procedure Set Error_Line_Number Integer iLine
11594>>>>>>>>>        Set piCurrentErrorLine to iLine
11595>>>>>>>>>    End_Procedure
11596>>>>>>>>>    
11596>>>>>>>>>    Procedure Trap_Error Integer iError
11598>>>>>>>>>        Send TrapError iError
11599>>>>>>>>>    End_Procedure
11600>>>>>>>>>    
11600>>>>>>>>>    Procedure Ignore_Error Integer iError
11602>>>>>>>>>        Send IgnoreError iError
11603>>>>>>>>>    End_Procedure
11604>>>>>>>>>    
11604>>>>>>>>>    Procedure Trap_All
11606>>>>>>>>>        Send TrapAllErrors
11607>>>>>>>>>    End_Procedure
11608>>>>>>>>>    
11608>>>>>>>>>    Procedure Ignore_All
11610>>>>>>>>>        Send IgnoreAllErrors
11611>>>>>>>>>    End_Procedure
11612>>>>>>>>>    
11612>>>>>>>>>    Function Is_Critical Integer iError Returns Boolean
11614>>>>>>>>>        Function_Return (IsCritical(Self, iError))
11615>>>>>>>>>    End_Function
11616>>>>>>>>>End_Class
11617>>>>>>>>>
11617>>>>>>>>>Procedure UserError Global String sMessage String sCaption
11619>>>>>>>>>    String sCapt
11619>>>>>>>>>    If (Error_Object_Id=0) Begin
11621>>>>>>>>>        Error DFERR_PROGRAM "No Error Handler"
11622>>>>>>>>>>
11622>>>>>>>>>        Procedure_Return
11623>>>>>>>>>    End
11623>>>>>>>>>>
11623>>>>>>>>>    
11623>>>>>>>>>    // Accept not passing a caption in which case the error handler's
11623>>>>>>>>>    // default caption. It had been the intention to require a caption ("" if none)
11623>>>>>>>>>    // but having no caption kind of worked where the caption would be "0". Since it
11623>>>>>>>>>    // kind of worked, I don't want to remove this which might generate runtime errors.
11623>>>>>>>>>    If (num_arguments>1) Begin
11625>>>>>>>>>        Move sCaption to sCapt
11626>>>>>>>>>    End
11626>>>>>>>>>>
11626>>>>>>>>>    
11626>>>>>>>>>    Error DFERR_OPERATOR (sMessage + If(sCapt<>"",C_ErrorCaption + sCapt,""))
11627>>>>>>>>>>
11627>>>>>>>>>End_Procedure
11628>>>>>>>Use Windows.pkg
11628>>>>>>>Use msgbox.pkg
11628>>>>>>>Use GlobalFunctionsProcedures.pkg
11628>>>>>>>
11628>>>>>>>Class cWindowsErrorHandler is a cBaseErrorHandler
11629>>>>>>>    Procedure Construct_Object
11631>>>>>>>        Forward Send Construct_Object
11633>>>>>>>        
11633>>>>>>>        
11633>>>>>>>        
11633>>>>>>>        // shows error numbers with user errors. Only set this true if your
11633>>>>>>>        // application has meaningful numbers that helps the end user. Note that
11633>>>>>>>        // unhandled errors always show numbers.
11633>>>>>>>        // this is ignored if pbUnhandledErrorSupport is false
11633>>>>>>>        Property Boolean pbShowErrorNumber        False
11634>>>>>>>        
11634>>>>>>>        //  This allows us to skip find errors (GT & LT) and to only
11634>>>>>>>        //  ring a bell when these occur.
11634>>>>>>>        //
11634>>>>>>>        Property Boolean pbBellOnFindErrorState True
11635>>>>>>>        
11635>>>>>>>        Property Integer pbVerboseState         True
11636>>>>>>>
11636>>>>>>>    End_Procedure
11637>>>>>>>    
11637>>>>>>>
11637>>>>>>>    
11637>>>>>>>    Procedure UnhandledErrorDisplay Integer iErrorLine String sMessage
11639>>>>>>>        String sCaption sCRLF
11639>>>>>>>        Move (Character(13)+Character(10)) to sCRLF
11640>>>>>>>        Get psUnhandledErrorCaption to sCaption
11641>>>>>>>        Move (Replaces("\n",sMessage,sCRLF)) to sMessage
11642>>>>>>>        Move (Replaces("\"+sCRLF, sMessage, "\n")) to sMessage
11643>>>>>>>        ErrorDisplay iErrorLine sMessage sCaption C_$OK C_$Copy
11644>>>>>>>    End_Procedure
11645>>>>>>>    
11645>>>>>>>    // Handle error event, displaying error info to user.
11645>>>>>>>    Procedure HandleError Integer iErrNum Integer iErrLine String sErrText
11647>>>>>>>        Integer iReply iIcon
11647>>>>>>>        String  sDescription sMess
11647>>>>>>>        String  sSource sCaption
11647>>>>>>>        Integer iSrcPos iSrc iTxtLen
11647>>>>>>>        Boolean bIsUnhandled bUnhandledSupport bCritical bVerbose
11647>>>>>>>        
11647>>>>>>>        
11647>>>>>>>        // if this is false, this will work old-style -- all errors go through message box
11647>>>>>>>        Get pbUnhandledErrorSupport to bUnhandledSupport
11648>>>>>>>        
11648>>>>>>>        Get IsCritical iErrNum to bCritical
11649>>>>>>>        Get IsUnhandledError iErrNum to bIsUnhandled
11650>>>>>>>        
11650>>>>>>>        
11650>>>>>>>        //
11650>>>>>>>        //   Changes made so find errors don't report - just beep
11650>>>>>>>        //
11650>>>>>>>        If ( pbBellOnFindErrorState(Self) and ;             (iErrNum=DFERR_FIND_PRIOR_BEG_OF_FILE or iErrNum=DFERR_FIND_PAST_END_OF_FILE)) Begin
11652>>>>>>>            Send Bell
11653>>>>>>>        End
11653>>>>>>>>
11653>>>>>>>        Else Begin
11654>>>>>>>            
11654>>>>>>>            // See if source information is provided (Source = module.function). If so remove
11654>>>>>>>            // as detail. Must find last instance of this in string
11654>>>>>>>            Move (pos(C_ErrorContextSourceText,sErrText)) to iSrc
11655>>>>>>>            If (iSrc > 0) Begin
11657>>>>>>>                Move (iSrc-1) to iSrcPos
11658>>>>>>>                Move (length(C_ErrorContextSourceText)) to  iTxtLen
11659>>>>>>>                Move sErrText to sSource
11660>>>>>>>                Repeat // this makes sure we find last instance of this
11660>>>>>>>>
11660>>>>>>>                    Move (Remove(sSource, 1, iSrc-1 + iTxtLen )) to sSource // right part of string
11661>>>>>>>                    Move (Pos(C_ErrorContextSourceText,sSource)) to iSrc           // see if it was the last
11662>>>>>>>                    If (iSrc > 0) ;                                               // if not, track length                        Move (iSrcPos + iTxtLen + iSrc-1) to iSrcPos
11665>>>>>>>                Until (iSrc=0)
11667>>>>>>>                Move (Trim(Left(sErrText,iSrcPos))) to sErrText
11668>>>>>>>                If (Right(sErrText,1) = ',') ;                    Move (Left(sErrText,Length(sErrText) - 1)) to sErrText
11671>>>>>>>            End
11671>>>>>>>>
11671>>>>>>>            
11671>>>>>>>            // the caption normally used for handled user errors
11671>>>>>>>            Get psUserErrorCaption to sCaption
11672>>>>>>>            // if an operator error this may be a Procedure UserError situation where the
11672>>>>>>>            // caption is passed in the error text. If so, get the caption
11672>>>>>>>            If (iErrNum=DFERR_OPERATOR) Begin
11674>>>>>>>                Move (pos(C_ErrorCaption,sErrText)) to iSrc
11675>>>>>>>                If iSrc Begin
11677>>>>>>>                    Move (Length(C_ErrorCaption)) to  iTxtLen
11678>>>>>>>                    Move (Remove(sErrText, 1, iSrc-1 + iTxtLen )) to sCaption
11679>>>>>>>                    Move (Left(sErrText,iSrc-1)) to sErrText
11680>>>>>>>                End
11680>>>>>>>>
11680>>>>>>>            End
11680>>>>>>>>
11680>>>>>>>            
11680>>>>>>>            Get ErrorDescription iErrNum sErrText to sDescription
11681>>>>>>>            
11681>>>>>>>            // if the error source is identified we can get extended error
11681>>>>>>>            // text for our error message
11681>>>>>>>            If (ghoErrorSource > 0) Begin
11683>>>>>>>                Get extended_error_Message of ghoErrorSource to sMess
11684>>>>>>>                If (sMess <> '') ;                    Move (sDescription + "\n\n" + sMess ) to sDescription
11687>>>>>>>            End
11687>>>>>>>>
11687>>>>>>>            
11687>>>>>>>            If (bUnhandledSupport) Begin
11689>>>>>>>                // as of 14.1, this is the preferred way to do errors
11689>>>>>>>                If (bCritical or bIsUnhandled) Begin
11691>>>>>>>                    Move ( sDescription + "\n\n" + C_$Error + ":" * String(iErrNum) ) to sDescription
11692>>>>>>>                    If (sSource <> "") Begin
11694>>>>>>>                        Move (sDescription + "\n" + C_$ErrorSource +" =" * sSource) to sDescription
11695>>>>>>>                    End
11695>>>>>>>>
11695>>>>>>>                End
11695>>>>>>>>
11695>>>>>>>                Else If (pbShowErrorNumber(Self)) Begin
11698>>>>>>>                    // if a user error, we provide a way to see error numbers.
11698>>>>>>>                    Move ( sDescription + "\n\n" + C_$Error + ":" * String(iErrNum) ) to sDescription
11699>>>>>>>                End
11699>>>>>>>>
11699>>>>>>>            End
11699>>>>>>>>
11699>>>>>>>            Else Begin
11700>>>>>>>                // we get here if we want it to work the old (less good) way. This is provided
11700>>>>>>>                // only for backwards compatibility. All errors go through the message box
11700>>>>>>>                Get Verbose_State to bVerbose
11701>>>>>>>                If (bVerbose)  Begin
11703>>>>>>>                    Move ( sDescription + "\n\n" + SFormat(C_$TechnicalDetails, iErrNum, iErrLine) ) to sDescription
11704>>>>>>>                    If (sSource<>"") Begin
11706>>>>>>>                        Move (sDescription + "\n" + C_$ErrorSource +" =" * sSource) to sDescription
11707>>>>>>>                    End
11707>>>>>>>>
11707>>>>>>>                End
11707>>>>>>>>
11707>>>>>>>            End
11707>>>>>>>>
11707>>>>>>>            
11707>>>>>>>            If ( (bCritical or bIsUnhandled) and bUnhandledSupport) Begin
11709>>>>>>>                Send UnhandledErrorDisplay iErrLine sDescription
11710>>>>>>>            End
11710>>>>>>>>
11710>>>>>>>            Else Begin
11711>>>>>>>                Move (If(bCritical,MB_IconHand,MB_IconExclamation)) to iIcon
11712>>>>>>>                Move (Message_Box(sDescription, sCaption, MB_Ok, iIcon)) to iReply
11713>>>>>>>            End
11713>>>>>>>>
11713>>>>>>>            
11713>>>>>>>            // abort on critical errors
11713>>>>>>>            If bCritical ;                Abort
11716>>>>>>>            
11716>>>>>>>        End
11716>>>>>>>>
11716>>>>>>>        
11716>>>>>>>    End_Procedure
11717>>>>>>>    
11717>>>>>>>    
11717>>>>>>>    
11717>>>>>>>    Function Help_Context Integer Context_Type Returns String
11719>>>>>>>        Function_Return (Current_Error_Number(Self))
11720>>>>>>>    End_Function
11721>>>>>>>    
11721>>>>>>>    
11721>>>>>>>    
11721>>>>>>>    // The following functions are rarely or never used.
11721>>>>>>>    
11721>>>>>>>    // The functions below are used to construct a general help
11721>>>>>>>    // name for errors that are generated by the system.  If processing
11721>>>>>>>    // comes here, then there was no module specific help found.  These
11721>>>>>>>    // functions will provide a more general help name that appears in
11721>>>>>>>    // the form of SYSTEM..ERROR:#.  All global errors should be
11721>>>>>>>    // places in the help file under this application and module name.
11721>>>>>>>    
11721>>>>>>>    // Returns "ERROR:errornum" to supply error help.
11721>>>>>>>    Function Help_Name Returns String
11723>>>>>>>        Function_Return (Append("ERROR:",lastErr))
11724>>>>>>>    End_Function
11725>>>>>>>    
11725>>>>>>>    Function Application_Name Returns String
11727>>>>>>>        Function_Return 'SYSTEM'
11728>>>>>>>    End_Function
11729>>>>>>>    
11729>>>>>>>    Function Module_Name Returns String
11731>>>>>>>        Function_Return ''
11732>>>>>>>    End_Function
11733>>>>>>>    
11733>>>>>>>    
11733>>>>>>>    // Legacy names here for backwards compatibility
11733>>>>>>>    Function Verbose_State Returns Boolean
11735>>>>>>>        Function_Return (pbVerboseState(Self))
11736>>>>>>>    End_Function
11737>>>>>>>    
11737>>>>>>>    Procedure Set Verbose_State Boolean bVal
11739>>>>>>>        Set pbVerboseState to bVal
11740>>>>>>>    End_Procedure
11741>>>>>>>    
11741>>>>>>>    Procedure Set Bell_on_Find_Error_State Boolean bVal
11743>>>>>>>        Set pbBellOnFindErrorState to bVal
11744>>>>>>>    End_Procedure
11745>>>>>>>    
11745>>>>>>>    Function Bell_on_Find_Error_State Returns Boolean
11747>>>>>>>        Function_Return (pbBellOnFindErrorState(Self))
11748>>>>>>>    End_Function
11749>>>>>>>End_Class
11750>>>>>
11750>>>>>// Legacy classnames
11750>>>>>Class ErrorSystem is a cWindowsErrorHandler
11751>>>>>End_Class
11752>>>>>
11752>>>>>Class Trapped_Errors_Array is a cTrappedErrors
11753>>>>>End_Class
11754>>>>>
11754>>>>>// Replace to make legacy code run that uses old names work
11754>>>>>
11754>>>>>Object oErrorHandler is a cWindowsErrorHandler
11756>>>>>End_Object
11757>>>>>
11757>>>Use cTimer.pkg
Including file: cTimer.pkg    (C:\Program Files\DataFlex 26.0\Pkg\cTimer.pkg)
11757>>>>>// This supercedes the DFTimer class.
11757>>>>>// It is simpler and more flexible
11757>>>>>
11757>>>>>Use Dftimer.pkg // we still use the Timer Manager classes and global objects
Including file: Dftimer.pkg    (C:\Program Files\DataFlex 26.0\Pkg\Dftimer.pkg)
11757>>>>>>>Use LanguageText.pkg
11757>>>>>>>Use Windows.pkg
11757>>>>>>>Use WinUser.pkg
11757>>>>>>>
11757>>>>>>>External_Function SetTimer "SetTimer" User32.DLL ;    Handle  hWnd ;    Longptr idTimer ;    Integer idTimeout ;    Pointer tmprc ;    Returns Longptr     // return type is UINT_PTR
11758>>>>>>>
11758>>>>>>>External_Function KillTimer "KillTimer" User32.DLL ;    Handle  hWnd ;    Longptr idTimer ;    Returns Integer
11759>>>>>>>
11759>>>>>>>// This global integer holds the ID of the object
11759>>>>>>>// that manages all timers.
11759>>>>>>>Integer giTimerManager
11759>>>>>>>
11759>>>>>>>// This class is used to store the object IDs
11759>>>>>>>// of the active timer objects. It augments
11759>>>>>>>// the Destroy_Object procedure to notify
11759>>>>>>>// the DFTimerManager to kill all its active
11759>>>>>>>// timers.
11759>>>>>>>// NOTE: This class looks very much like the
11759>>>>>>>// Set class. I didn't want to use Set because
11759>>>>>>>// Remove_Element shifts items which I don't
11759>>>>>>>// want to happen because item numbers are used
11759>>>>>>>// as timerIDs.
11759>>>>>>>
11759>>>>>>>Class TimersArray is an Array
11760>>>>>>>    
11760>>>>>>>    Function Find_Object Integer iObj Returns Integer
11762>>>>>>>        Integer iMax
11762>>>>>>>        Integer iItem
11762>>>>>>>        Integer iValue
11762>>>>>>>        Get Item_count to iMax
11763>>>>>>>        Decrement iMax
11764>>>>>>>        For iItem from 1 to iMax
11770>>>>>>>>
11770>>>>>>>            Get Integer_Value iItem to iValue
11771>>>>>>>            If (iValue = iObj) ;                Function_Return iItem
11774>>>>>>>        Loop
11775>>>>>>>>
11775>>>>>>>        Function_Return -1
11776>>>>>>>    End_Function
11777>>>>>>>    
11777>>>>>>>    Procedure Add_Object Integer iObj Returns Integer
11779>>>>>>>        Integer iItem
11779>>>>>>>        Get Find_Object iObj to iItem
11780>>>>>>>        If (iItem < 0) Begin
11782>>>>>>>            Get Find_Object 0 to iItem
11783>>>>>>>            If (iItem < 0) ;                Get Item_Count to iItem
11786>>>>>>>        End
11786>>>>>>>>
11786>>>>>>>        Set Array_Value iItem to iObj
11787>>>>>>>        Procedure_Return iItem
11788>>>>>>>    End_Procedure
11789>>>>>>>    
11789>>>>>>>    Procedure Remove_Object Integer iObj
11791>>>>>>>        Integer iItem
11791>>>>>>>        Get Find_Object iObj to iItem
11792>>>>>>>        If (iItem > 0) ;            Set Array_Value iItem to 0
11795>>>>>>>    End_Procedure
11796>>>>>>>    
11796>>>>>>>    Procedure Destroy_Object
11798>>>>>>>        Delegate Send Kill_All_Timers
11800>>>>>>>        Forward Send Destroy_Object
11802>>>>>>>    End_Procedure
11803>>>>>>>    
11803>>>>>>>End_Class
11804>>>>>>>
11804>>>>>>>// This class is the actual timer manager
11804>>>>>>>// A timer will be created when Message Set_Timer_Active_State
11804>>>>>>>// has been send. This message needs two arguments. The first
11804>>>>>>>// is the objectID of the object to receive the timer event,
11804>>>>>>>// and the second is state. The object which ID has been passed,
11804>>>>>>>// needs to have a Timeout property to return the timeout for the
11804>>>>>>>// timer and it also needs to handle the MSG_OnTimer whenever a
11804>>>>>>>// timer event occurs.
11804>>>>>>>// The objectID of the Object will be placed in an array which contains
11804>>>>>>>// the objectIDs of all active timers. The Windows timer ID of a timer
11804>>>>>>>// is the itemnumber of the object in the array.
11804>>>>>>>//
11804>>>>>>>Class DFTimerManager is a DfBaseControl
11805>>>>>>>    
11805>>>>>>>    Procedure Construct_Object
11807>>>>>>>        
11807>>>>>>>        Forward Send Construct_Object
11809>>>>>>>        
11809>>>>>>>        Set Visible_State to False
11810>>>>>>>        
11810>>>>>>>        Set External_Class_Name "cVdfTimer" to "static"
11811>>>>>>>        Set External_Message WM_TIMER to OnTimer
11812>>>>>>>        
11812>>>>>>>        Object TimersArray is a TimersArray
11814>>>>>>>            Set Array_Value 0 to -9999 // So we don't use item 0
11815>>>>>>>        End_Object
11816>>>>>>>        
11816>>>>>>>        Move Self to giTimerManager
11817>>>>>>>        
11817>>>>>>>    End_Procedure
11818>>>>>>>    
11818>>>>>>>    Procedure Set Timer_Active_State Integer iObj Integer iState
11820>>>>>>>        Integer iTimerID
11820>>>>>>>        Integer iTimeout
11820>>>>>>>        Integer iResult
11820>>>>>>>        Integer iSet
11820>>>>>>>        DWord   nResult
11820>>>>>>>        Handle  hWnd
11820>>>>>>>        
11820>>>>>>>        // Get the handle of this object
11820>>>>>>>        Get Window_Handle to hWnd
11821>>>>>>>        If (not(hWnd)) Begin
11823>>>>>>>            Error DFERR_DFTIMER C_$TimerNoHandle
11824>>>>>>>>
11824>>>>>>>            Procedure_Return
11825>>>>>>>        End
11825>>>>>>>>
11825>>>>>>>        
11825>>>>>>>        // Test if handle is valid. If not, we leave.
11825>>>>>>>        If (not(IsWindow(hWnd))) ;            Procedure_Return
11828>>>>>>>        
11828>>>>>>>        Move (TimersArray(Self)) to iSet
11829>>>>>>>        
11829>>>>>>>        If (iSet) Begin
11831>>>>>>>            
11831>>>>>>>            // Let's create or modify a timer
11831>>>>>>>            If iState Begin
11833>>>>>>>                
11833>>>>>>>                // Get the exising to new TimerID
11833>>>>>>>                Get MSG_Add_Object of iSet iObj to iTimerID
11834>>>>>>>                
11834>>>>>>>                // Set/Modify the timer
11834>>>>>>>                Get Timeout of iObj to iTimeout
11835>>>>>>>                Move (SetTimer(hWnd, iTimerID, iTimeout, 0)) to iResult
11836>>>>>>>                If not iResult Begin
11838>>>>>>>                    Error DFERR_DFTIMER C_$TooManyTimers
11839>>>>>>>>
11839>>>>>>>                    Procedure_Return
11840>>>>>>>                End
11840>>>>>>>>
11840>>>>>>>                
11840>>>>>>>            End
11840>>>>>>>>
11840>>>>>>>            
11840>>>>>>>            // Let's kill an existing timer
11840>>>>>>>            Else Begin
11841>>>>>>>                
11841>>>>>>>                // Look up the object in the set
11841>>>>>>>                Get Find_Object of iSet iObj to iTimerID
11842>>>>>>>                
11842>>>>>>>                If (iTimerID = -1) ;                    Procedure_Return
11845>>>>>>>                
11845>>>>>>>                // Kill the timer
11845>>>>>>>                Move (KillTimer(hWnd, iTimerID)) to iResult
11846>>>>>>>                If not iResult Begin
11848>>>>>>>                    Move (GetLastError()) to nResult
11849>>>>>>>                    Error DFERR_DFTIMER (C_$CantKillTimer * String(nResult) - "!")
11850>>>>>>>>
11850>>>>>>>                    Procedure_Return
11851>>>>>>>                End
11851>>>>>>>>
11851>>>>>>>                
11851>>>>>>>                // Remove the objectID
11851>>>>>>>                Send Remove_Object to iSet iObj
11852>>>>>>>            End
11852>>>>>>>>
11852>>>>>>>        End
11852>>>>>>>>
11852>>>>>>>    End_Procedure
11853>>>>>>>    
11853>>>>>>>    Function Timer_Active_State Integer iObj Returns Integer
11855>>>>>>>        Integer iResult
11855>>>>>>>        Get Find_Object of (TimersArray(Self)) iObj to iResult
11856>>>>>>>        Function_Return (iResult<>-1) // note: -1= not found
11857>>>>>>>    End_Function
11858>>>>>>>    
11858>>>>>>>    // Will be called by the Set when it is being destroyed.
11858>>>>>>>    Procedure Kill_All_Timers
11860>>>>>>>        Integer iMax
11860>>>>>>>        Integer iSet
11860>>>>>>>        Integer iItem
11860>>>>>>>        Integer iObj
11860>>>>>>>        Integer iResult
11860>>>>>>>        Handle  hWnd
11860>>>>>>>        
11860>>>>>>>        // Get the handle of this object
11860>>>>>>>        Get Window_Handle to hWnd
11861>>>>>>>        If (not(hWnd)) Begin
11863>>>>>>>            Error DFERR_DFTIMER C_$TimerNoHandle
11864>>>>>>>>
11864>>>>>>>            Procedure_Return
11865>>>>>>>        End
11865>>>>>>>>
11865>>>>>>>        
11865>>>>>>>        // If the window handle is no longer valid, we
11865>>>>>>>        // leave this procedure. This can happen when the
11865>>>>>>>        // program is begin aborted using Exit_Application
11865>>>>>>>        If (not(IsWindow(hWnd))) ;            Procedure_Return
11868>>>>>>>        
11868>>>>>>>        // Scan the set and kill all known timers
11868>>>>>>>        Move (TimersArray(Self)) to iSet
11869>>>>>>>        If (iSet) Begin
11871>>>>>>>            Get Item_Count of iSet to iMax
11872>>>>>>>            Decrement iMax
11873>>>>>>>            For iItem from 1 to iMax
11879>>>>>>>>
11879>>>>>>>                Get Integer_Value of iSet iItem to iObj
11880>>>>>>>                If iObj Begin
11882>>>>>>>                    Move (KillTimer(hWnd, iItem)) to iResult
11883>>>>>>>                    Set Array_Value of iSet iItem to 0
11884>>>>>>>                End
11884>>>>>>>>
11884>>>>>>>            Loop
11885>>>>>>>>
11885>>>>>>>        End
11885>>>>>>>>
11885>>>>>>>        
11885>>>>>>>    End_Procedure
11886>>>>>>>    
11886>>>>>>>    Procedure OnTimer Longptr wParam Longptr lParam
11888>>>>>>>        Integer iObj
11888>>>>>>>        Get Integer_Value of (TimersArray(Self)) wParam to iObj
11889>>>>>>>        If not iObj Begin
11891>>>>>>>            Error DFERR_DFTIMER C_$TimerWithoutObject
11892>>>>>>>>
11892>>>>>>>            Procedure_Return
11893>>>>>>>        End
11893>>>>>>>>
11893>>>>>>>        Send OnTimer to iObj wParam lParam
11894>>>>>>>    End_Procedure
11895>>>>>>>    
11895>>>>>>>    Procedure Destroy_Object
11897>>>>>>>        Send Kill_All_Timers
11898>>>>>>>        Forward Send Destroy_Object
11900>>>>>>>        Move 0 to giTimerManager
11901>>>>>>>    End_Procedure
11902>>>>>>>    
11902>>>>>>>End_Class
11903>>>>>>>
11903>>>>>>>
11903>>>>>>>
11903>>>>>>>
11903>>>>>>>// This class acts as a container for the
11903>>>>>>>// timer manager object. This is needed because
11903>>>>>>>// A DFTimerManager object created directly at the
11903>>>>>>>// desktop doesn't have a Window_Handle which we
11903>>>>>>>// need to create a Windoows timer. By placing
11903>>>>>>>// this non-visual container around the timer
11903>>>>>>>// manager, it does get a Window_Handle.
11903>>>>>>>// The procedure End_Construct_Object has been
11903>>>>>>>// augmented to create a window and also
11903>>>>>>>// automatically page all children, which will
11903>>>>>>>// be the timer manager.
11903>>>>>>>//
11903>>>>>>>Class DFTimerManagerPanel is a dfBasePanel
11904>>>>>>>    
11904>>>>>>>    Procedure Construct_Object
11906>>>>>>>        Forward Send Construct_Object
11908>>>>>>>        Set Visible_State to False
11909>>>>>>>        Object DFTimerManager is a DFTimerManager
11911>>>>>>>        End_Object
11912>>>>>>>    End_Procedure
11913>>>>>>>    
11913>>>>>>>    Procedure End_Construct_Object
11915>>>>>>>        Forward Send End_Construct_Object
11917>>>>>>>        Send Page_Object True
11918>>>>>>>        Broadcast Send Page_Object True
11920>>>>>>>    End_Procedure
11921>>>>>>>    
11921>>>>>>>End_Class
11922>>>>>>>
11922>>>>>>>// This is the class the user uses to create DFTimer objects
11922>>>>>>>
11922>>>>>>>
11922>>>>>>>//{ OverrideProperty=Skip_State DesignTime=False }
11922>>>>>>>//{ OverrideProperty=TypeFace DesignTime=False }
11922>>>>>>>Class DFTimer is a Textbox
11923>>>>>>>    
11923>>>>>>>    Procedure Construct_Object
11925>>>>>>>        Forward Send Construct_Object
11927>>>>>>>        
11927>>>>>>>        // Make sure this object never appears
11927>>>>>>>        Set Visible_State to False
11928>>>>>>>        
11928>>>>>>>        Property Integer Private.Timeout    1000
11929>>>>>>>        
11929>>>>>>>        Property Integer Timer_Message      0
11930>>>>>>>        Property Integer Timer_Object       0
11931>>>>>>>        Property Integer Auto_Start_State   True
11932>>>>>>>        Property Integer Auto_Stop_State    True
11933>>>>>>>    End_Procedure
11934>>>>>>>    
11934>>>>>>>    Procedure Set Timer_Active_State Integer iState
11936>>>>>>>        Integer iObj
11936>>>>>>>        Move Self to iObj
11937>>>>>>>        If giTimerManager ;            Set Timer_Active_State of giTimerManager iObj to iState
11940>>>>>>>    End_Procedure
11941>>>>>>>    
11941>>>>>>>    Function Timer_Active_State Returns Integer
11943>>>>>>>        Integer iState
11943>>>>>>>        Integer iObj
11943>>>>>>>        Move Self to iObj
11944>>>>>>>        If giTimerManager ;            Get Timer_Active_State of giTimerManager iObj to iState
11947>>>>>>>        Function_Return iState
11948>>>>>>>    End_Function
11949>>>>>>>    
11949>>>>>>>    Procedure Set Timeout Integer iTimeout
11951>>>>>>>        Integer iActive
11951>>>>>>>        Set Private.Timeout to iTimeout
11952>>>>>>>        Get Timer_Active_State to iActive
11953>>>>>>>        If iActive ;            Set Timer_Active_State to True
11956>>>>>>>    End_Procedure
11957>>>>>>>    
11957>>>>>>>    Function Timeout Returns Integer
11959>>>>>>>        Integer iTimeout
11959>>>>>>>        Get Private.Timeout to iTimeout
11960>>>>>>>        Function_Return iTimeout
11961>>>>>>>    End_Function
11962>>>>>>>    
11962>>>>>>>    Procedure OnTimer Integer iwParam Integer ilParam
11964>>>>>>>        Integer iMsg
11964>>>>>>>        Integer iObj
11964>>>>>>>        Get Timer_Message to iMsg
11965>>>>>>>        If (iMsg) Begin
11967>>>>>>>            Get Timer_Object  to iObj
11968>>>>>>>            If iObj ;                Send iMsg to iObj iwParam ilParam
11971>>>>>>>            Else ;                Send iMsg iwParam ilParam
11973>>>>>>>        End
11973>>>>>>>>
11973>>>>>>>    End_Procedure
11974>>>>>>>    
11974>>>>>>>    // Augmented to Auto_Start a timer
11974>>>>>>>    //
11974>>>>>>>    Procedure Page_Object Integer iState
11976>>>>>>>        Forward Send Page_Object iState
11978>>>>>>>        If (iState and Auto_Start_State(Self)) ;            Set Timer_Active_State to True
11981>>>>>>>    End_Procedure
11982>>>>>>>    
11982>>>>>>>    // Augmented to Auto_Stop a timer
11982>>>>>>>    //
11982>>>>>>>    Procedure Page_Delete
11984>>>>>>>        If (Auto_Stop_State(Self)) ;            Set Timer_Active_State to False
11987>>>>>>>        Forward Send Page_Delete
11989>>>>>>>    End_Procedure
11990>>>>>>>    
11990>>>>>>>    // Augmented to stop the timer
11990>>>>>>>    //
11990>>>>>>>    Procedure Destroy_Object
11992>>>>>>>        Set Timer_Active_State to False
11993>>>>>>>        Forward Send Destroy_Object
11995>>>>>>>    End_Procedure
11996>>>>>>>    
11996>>>>>>>End_Class
11997>>>>>>>
11997>>>>>>>//
11997>>>>>>>// This was moved into a method so it can be reliable created
11997>>>>>>>// at the desktop. Note that cDesktop adds method to cDesktop class (class of desktop)
11997>>>>>>>//
11997>>>>>>>Procedure CreateDfTimerManagerPanel for cDesktop
11999>>>>>>>    // Create the Desktop Timer Manager Object.
11999>>>>>>>    Object DFTimerManagerPanel is a DFTimerManagerPanel
12001>>>>>>>    End_Object
12002>>>>>>>End_Procedure
12003>>>>>>>
12003>>>>>>>Send CreateDfTimerManagerPanel of DESKTOP
12004>>>>>
12004>>>>>Class cTimer is a cObject
12005>>>>>    
12005>>>>>    Procedure Construct_Object
12007>>>>>        Forward Send Construct_Object
12009>>>>>        Property Integer piPrivate_Timeout 1000
12010>>>>>    End_Procedure
12011>>>>>    
12011>>>>>    Procedure Set pbEnabled Boolean bEnabled
12013>>>>>        If giTimerManager Begin
12015>>>>>            Set Timer_Active_State of giTimerManager Self to bEnabled
12016>>>>>        End
12016>>>>>>
12016>>>>>    End_Procedure
12017>>>>>    
12017>>>>>    Function pbEnabled Returns Boolean
12019>>>>>        Boolean bEnabled
12019>>>>>        If giTimerManager Begin
12021>>>>>            Get Timer_Active_State of giTimerManager Self to bEnabled
12022>>>>>        End
12022>>>>>>
12022>>>>>        Function_Return bEnabled
12023>>>>>    End_Function
12024>>>>>    
12024>>>>>    Procedure Set piTimeout Integer iTimeout
12026>>>>>        Boolean bEnabled
12026>>>>>        Set piPrivate_Timeout to iTimeout
12027>>>>>        Get pbEnabled to bEnabled
12028>>>>>        If bEnabled Begin
12030>>>>>            Set pbEnabled to True
12031>>>>>        End
12031>>>>>>
12031>>>>>    End_Procedure
12032>>>>>    
12032>>>>>    Function piTimeout Returns Integer
12034>>>>>        Integer iTimeout
12034>>>>>        Get piPrivate_Timeout to iTimeout
12035>>>>>        Function_Return iTimeout
12036>>>>>    End_Function
12037>>>>>    
12037>>>>>    Procedure OnTimer
12039>>>>>    End_Procedure
12040>>>>>    
12040>>>>>    // this is needed by the timer manager
12040>>>>>    Function Timeout Returns Integer
12042>>>>>        Integer iTimeout
12042>>>>>        Get piPrivate_Timeout to iTimeout
12043>>>>>        Function_Return iTimeout
12044>>>>>    End_Function
12045>>>>>    
12045>>>>>    Procedure Destroy_Object
12047>>>>>        Set pbEnabled to False
12048>>>>>        Forward Send Destroy_Object
12050>>>>>    End_Procedure
12051>>>>>    
12051>>>>>End_Class
12052>>>Use Winkern.pkg
12052>>>
12052>>>Use ThriftlyCommands.pkg
Including file: ThriftlyCommands.pkg    (C:\Users\marce\OneDrive\Documentos\Thriftly Developer\Dataflex\Library_x64\AppSrc\ThriftlyCommands.pkg)
12052>>>>>
12052>>>>>
12052>>>>>
12052>>>>>
12052>>>>>
12052>>>>>//=========================================================================================================================================================================================================
12052>>>>>//*********************************************************************************************************************************************************************************************************
12052>>>>>// This is the custom message command for VDF 15-19
12052>>>>>//*********************************************************************************************************************************************************************************************************
12052>>>>>//=========================================================================================================================================================================================================
12052>>>>>
12052>>>>>
12052>>>Use cThriftlyDoc.pkg
Including file: cThriftlyDoc.pkg    (C:\Users\marce\OneDrive\Documentos\Thriftly Developer\Dataflex\Library_x64\AppSrc\cThriftlyDoc.pkg)
12052>>>>>//Thriftly documentation. 
12052>>>>>
12052>>>>>Struct tDocumentCommand
12052>>>>>    String sType 
12052>>>>>    String sDesc
12052>>>>>    String sElementName
12052>>>>>End_Struct
12052>>>>>
12052>>>>>Object oThriftlyDocumentation is a cObject
12054>>>>>    Property Boolean pisError
12056>>>>>    
12056>>>>>    Procedure Error_Report Integer iErrNum Integer iErrLine String sErrText
12059>>>>>        Set pisError to (True) 
12060>>>>>    End_Procedure
12061>>>>>    
12061>>>>>    Function ImageNumber String sImage Returns Integer 
12064>>>>>        Integer hErrObj
12064>>>>>        Integer iReturn 
12064>>>>>
12064>>>>>        Move Error_Object_Id to  hErrObj
12065>>>>>        Move (Self) to Error_Object_Id 
12066>>>>>        Set pisError to False 
12067>>>>>        Move (Eval(sImage+".N")) to iReturn 
12068>>>>>        If (pisError(Self)) Move -1 to iReturn 
12071>>>>>        Move hErrObj to Error_Object_Id 
12072>>>>>        
12072>>>>>        Function_Return iReturn 
12073>>>>>    End_Function
12074>>>>>
12074>>>>>    Function ImageDataAsArray Integer iImageNo Returns String[]
12077>>>>>        String[] aLines 
12078>>>>>        String sReturn 
12078>>>>>        Integer iCh 
12078>>>>>        String sLine 
12078>>>>>        
12078>>>>>        Move (Seq_New_Channel()) to iCh 
12079>>>>>        Direct_Input channel iCh ("image:"+String(iImageNo))
12081>>>>>        While (not(SeqEof))   
12085>>>>>            Readln sLine 
12086>>>>>            If (not(SeqEof)) Move sLine to aLines[SizeOfArray(aLines)]
12089>>>>>        Loop 
12090>>>>>>
12090>>>>>        Close_Input iCh 
12091>>>>>        Send Seq_Release_Channel iCh 
12092>>>>>        
12092>>>>>        Function_Return aLines  
12093>>>>>    End_Function
12094>>>>>    
12094>>>>>    Function ImageToLines String sImageName Returns String[]
12097>>>>>        String[] aLines 
12098>>>>>        Integer iImage 
12098>>>>>        Get ImageNumber sImageName to iImage
12099>>>>>        If (iImage>0) Get ImageDataAsArray iImage to aLines
12102>>>>>        
12102>>>>>        Function_Return aLines 
12103>>>>>    End_Function
12104>>>>>
12104>>>>>    Function ImageText String sObject String sMethod Returns String[]
12107>>>>>        String[] aLines 
12108>>>>>        String sImageName
12108>>>>>        Integer iImage
12108>>>>>        
12108>>>>>        Move (lowercase(sMethod)) to sMethod 
12109>>>>>        If ((Pos("get_",sMethod))=1) Move (Mid(sMethod,(Length(sMethod)),5)) to sMethod 
12112>>>>>        If ((Pos("msg_",sMethod))=1) Move (Mid(sMethod,(Length(sMethod)),5)) to sMethod 
12115>>>>>        
12115>>>>>        Move (sObject+"."+sMethod) to sImageName 
12116>>>>>        Move (ImageToLines(Self,sImageName)) to aLines 
12117>>>>>
12117>>>>>        Function_Return aLines 
12118>>>>>    End_Function
12119>>>>>    
12119>>>>>    Function RemoveInitialChars String sInp Integer iIndent Returns String 
12122>>>>>        Integer iStartPos 
12122>>>>>        Function_Return (Mid(sInp,(Length(sInp)),iIndent))
12123>>>>>        //Function_Return sInp 
12123>>>>>    End_Function
12124>>>>>    
12124>>>>>    Function hasNameParameter String sName Returns Boolean 
12127>>>>>        Move (Lowercase(sName)) to sName 
12128>>>>>        If (sName="param") Function_Return True 
12131>>>>>        Else Function_Return False 
12133>>>>>    End_Function
12134>>>>>    
12134>>>>>    Function LineStartPos String sInp Returns Integer 
12137>>>>>        Char[] myCharArray
12138>>>>>        Address pStr
12138>>>>>        Integer iMax
12138>>>>>        Integer iPos 
12138>>>>>        String sSkipNext
12138>>>>>        
12138>>>>>        If ((Pos("//",sInp))=0) Function_Return 0 
12141>>>>>        
12141>>>>>        Move (Replace("//",sInp,"  ")) to sInp 
12142>>>>>        Move (Length(sInp)) to iMax
12143>>>>>        Move (ResizeArray(myCharArray,iMax+1)) to myCharArray
12144>>>>>        Move (AddressOf(myCharArray)) to pStr
12145>>>>>        Move (AddressOf(sInp)) to pStr        
12146>>>>>        
12146>>>>>        For iPos from 0 to (iMax-1) 
12152>>>>>>
12152>>>>>            If (myCharArray[iPos]<>32) Function_Return (iPos+1)
12155>>>>>        Loop
12156>>>>>>
12156>>>>>        
12156>>>>>        Function_Return 0 
12157>>>>>    End_Function
12158>>>>>    
12158>>>>>    Function StripIndentPoint String[] aLines Returns Integer 
12161>>>>>        Integer iPos 
12161>>>>>        Integer iMax 
12161>>>>>        Integer iStartPos
12161>>>>>        Integer iTest 
12161>>>>>        
12161>>>>>        Move 0 to iStartPos 
12162>>>>>        Move (SizeOfArray(aLines)) to iMax
12163>>>>>        For iPos from 0 to (iMax-1)
12169>>>>>>
12169>>>>>            Move (LineStartPos(Self,aLines[iPos])) to iTest
12170>>>>>            If (iTest<>0) Begin
12172>>>>>                If ((iTest<iStartPos) or (iStartPos=0)) Move iTest to iStartPos
12175>>>>>            End 
12175>>>>>>
12175>>>>>        Loop
12176>>>>>>
12176>>>>>        
12176>>>>>        Function_Return iStartPos 
12177>>>>>    End_Function
12178>>>>>    
12178>>>>>    Function isNewCommand String sTest Returns Boolean 
12181>>>>>        Move (Trim(sTest)) to sTest 
12182>>>>>        Function_Return ((pos("@",sTest))<>0)
12183>>>>>    End_Function
12184>>>>>    
12184>>>>>    Enum_List 
12184>>>>>        Define C_Starting
12184>>>>>        Define C_command
12184>>>>>        Define C_Before_Param
12184>>>>>        Define C_Param
12184>>>>>        Define C_before_detail
12184>>>>>        Define C_detail  
12184>>>>>    End_Enum_List
12184>>>>>    
12184>>>>>    Function HasTitle String sType Returns Boolean 
12187>>>>>             If (sType="param")   Function_Return True 
12190>>>>>        Else If (sType="element") Function_Return True 
12194>>>>>        Else If (sType="error")   Function_Return True 
12198>>>>>        Else                      Function_Return False 
12200>>>>>    End_Function
12201>>>>>    
12201>>>>>    Function CreateCommand String sLine tDocumentCommand TempCommand Returns tDocumentCommand
12204>>>>>        Char[] myCharArray
12205>>>>>        Address pStr
12205>>>>>        Integer iMax 
12205>>>>>        Integer iPos 
12205>>>>>        String sChar 
12205>>>>>        Integer iParsing 
12205>>>>>        
12205>>>>>        If (not(isNewCommand(Self,sLine))) Begin 
12207>>>>>            Move sLine to TempCommand.sDesc
12208>>>>>            If (TempCommand.sType="") Move "detail" to TempCommand.sType
12211>>>>>            Function_Return TempCommand
12212>>>>>        End
12212>>>>>>
12212>>>>>        
12212>>>>>        Move C_Starting to iParsing 
12213>>>>>        Move (Length(sLine)) to iMax
12214>>>>>        Move (ResizeArray(myCharArray,iMax+1)) to myCharArray
12215>>>>>        Move (AddressOf(myCharArray)) to pStr
12216>>>>>        Move (AddressOf(sLine)) to pStr        
12217>>>>>        
12217>>>>>        For iPos from 0 to (iMax-1) 
12223>>>>>>
12223>>>>>            Move (Character(myCharArray[iPos])) to sChar
12224>>>>>            If (iParsing=C_Starting) Begin
12226>>>>>                Move "" to TempCommand.sElementName 
12227>>>>>                If (sChar="@") Begin 
12229>>>>>                    Move "" to TempCommand.sType
12230>>>>>                    Move C_command to iParsing 
12231>>>>>                End
12231>>>>>>
12231>>>>>                Else If (sChar<>" ") Begin 
12234>>>>>                    Move sChar to TempCommand.sType 
12235>>>>>                    Move C_command to iParsing 
12236>>>>>                End
12236>>>>>>
12236>>>>>            End
12236>>>>>>
12236>>>>>            Else If (iParsing=C_Command) Begin 
12239>>>>>                If (sChar<>" ") Append TempCommand.sType sChar 
12242>>>>>                Else Begin 
12243>>>>>                    Move (Lowercase(TempCommand.sType)) to TempCommand.sType
12244>>>>>                    Move "" to TempCommand.sElementName
12245>>>>>                    If (HasTitle(Self,TempCommand.sType)) Move C_Before_Param to iParsing 
12248>>>>>                    Else Move C_before_detail to iParsing 
12250>>>>>                End
12250>>>>>>
12250>>>>>            End
12250>>>>>>
12250>>>>>            Else If (iParsing=C_Before_Param) Begin 
12253>>>>>                If ((pos(sChar," -.:=")) = 0) Begin 
12255>>>>>                    Move C_Param to iParsing 
12256>>>>>                    Move sChar to TempCommand.sElementName
12257>>>>>                End
12257>>>>>>
12257>>>>>            End
12257>>>>>>
12257>>>>>            Else If (iParsing=C_Param) Begin 
12260>>>>>                If ((pos(sChar," -.:=")) <> 0) Begin 
12262>>>>>                    Move C_Before_Detail to iParsing
12263>>>>>                End
12263>>>>>>
12263>>>>>                Else Begin 
12264>>>>>                    Append TempCommand.sElementName sChar 
12265>>>>>                End
12265>>>>>>
12265>>>>>            End
12265>>>>>>
12265>>>>>            Else If (iParsing=C_Before_Detail) Begin 
12268>>>>>                If ((pos(sChar," -.:=")) = 0) Begin 
12270>>>>>                    Move C_Detail to iParsing 
12271>>>>>                    Move sChar to TempCommand.sDesc
12272>>>>>                End
12272>>>>>>
12272>>>>>            End
12272>>>>>>
12272>>>>>            Else If (iParsing=C_Detail) Begin 
12275>>>>>                Move (TempCommand.sDesc+sChar) to TempCommand.sDesc
12276>>>>>            End
12276>>>>>>
12276>>>>>        Loop
12277>>>>>>
12277>>>>>        
12277>>>>>        Function_Return TempCommand
12278>>>>>    End_Function
12279>>>>>    
12279>>>>>    Function FindDocumentCommand tDocumentCommand cmd1 tDocumentCommand cmd2 Returns Integer 
12282>>>>>        If (cmd1.sType > cmd2.sType) Function_Return (GT)
12285>>>>>        If (cmd1.sType < cmd2.sType) Function_Return (LT)
12288>>>>>
12288>>>>>        If (cmd1.sElementName > cmd2.sElementName) Function_Return (GT)
12291>>>>>        If (cmd1.sElementName < cmd2.sElementName) Function_Return (LT)
12294>>>>>        
12294>>>>>        Function_Return (EQ) 
12295>>>>>    End_Function
12296>>>>>    
12296>>>>>    //todo - this function could do with being a bit easier to read.
12296>>>>>    Function ParseImage String[] aLines Returns tDocumentCommand[]
12299>>>>>        Integer iCharStartPos
12299>>>>>        Integer iMax 
12299>>>>>        Integer iPos 
12299>>>>>        Integer iCommand 
12299>>>>>        tDocumentCommand[] aCommands
12299>>>>>        tDocumentCommand[] aCommands
12300>>>>>        tDocumentCommand tmpCommand 
12300>>>>>        tDocumentCommand tmpCommand 
12300>>>>>        String sLine 
12300>>>>>        String sCRLF 
12300>>>>>        String sTmp
12300>>>>>                
12300>>>>>        Move ((Character(13))+(character(10))) to sCRLF
12301>>>>>        Move (StripIndentPoint(Self,aLines)) to iCharStartPos 
12302>>>>>
12302>>>>>        Move "detail" to tmpCommand.sType
12303>>>>>
12303>>>>>        Move (SizeOfArray(aLines)) to iMax
12304>>>>>        For iPos from 0 to (iMax-1)
12310>>>>>>
12310>>>>>            Move aLines[iPos] to sLine 
12311>>>>>            If ((Trim(sLine))="") Move "" to sLine 
12314>>>>>            If ((Pos("//",sLine))<>0) Move (Mid(sLine,(length(sLine)),iCharStartPos)) to sLine
12317>>>>>            
12317>>>>>            Move (CreateCommand(Self,sLine,tmpCommand)) to tmpCommand 
12318>>>>>            Move (SearchArray(tmpCommand,aCommands,Self,get_FindDocumentCommand)) to iCommand 
12319>>>>>            
12319>>>>>            If (iCommand=-1) Move tmpCommand to aCommands[SizeOfArray(aCommands)]
12322>>>>>            Else Begin 
12323>>>>>                //Command line without description does not add blank line to text block 
12323>>>>>                If ((sLine="") or (tmpCommand.sDesc<>"")) Begin 
12325>>>>>                    Move aCommands[iCommand].sDesc to sTmp 
12326>>>>>                    If (sTmp<>"") Append sTmp sCRLF 
12329>>>>>                    Append sTmp tmpCommand.sDesc
12330>>>>>                    Move sTmp to aCommands[iCommand].sDesc
12331>>>>>                End
12331>>>>>>
12331>>>>>            End
12331>>>>>>
12331>>>>>        Loop
12332>>>>>>
12332>>>>>        
12332>>>>>        Function_Return aCommands
12333>>>>>    End_Function
12334>>>>>    
12334>>>>>    Function isSearchOK String sTest String sInp Returns Boolean 
12337>>>>>        If (sTest="") Function_Return (True)
12340>>>>>        
12340>>>>>        Move (Lowercase(sInp)) to sInp 
12341>>>>>        Move (Lowercase(sTest)) to sTest
12342>>>>>        If (Pos(sInp,sTest)) Function_Return (True)  
12345>>>>>        
12345>>>>>        Function_Return (False) 
12346>>>>>    End_Function
12347>>>>>    
12347>>>>>    Function stripCodes tDocumentCommand[] aCommands String sType String sElement Returns tDocumentCommand[] 
12350>>>>>        tDocumentCommand[] aReturn 
12350>>>>>        tDocumentCommand[] aReturn 
12351>>>>>        Integer iMax
12351>>>>>        Integer iPos 
12351>>>>>        Boolean isLineOK 
12351>>>>>        
12351>>>>>        Move (SizeOfArray(aCommands)) to iMax 
12352>>>>>        For iPos from 0 to (iMax-1)
12358>>>>>>
12358>>>>>            Move (True) to isLineOK 
12359>>>>>            If (not(isSearchOK(Self,sType,aCommands[iPos].sType))) Move (False) to isLineOK
12362>>>>>            If (not(isSearchOK(Self,sElement,aCommands[iPos].sElementName))) Move (False) to isLineOK
12365>>>>>            If (isLineOK) Move aCommands[iPos] to aReturn[SizeOfArray(aReturn)]
12368>>>>>        Loop
12369>>>>>>
12369>>>>>        
12369>>>>>        Function_Return aReturn 
12370>>>>>    End_Function
12371>>>>>    
12371>>>>>    Function GenericDetail String sObject String sMethod String sType String sElement Returns String 
12374>>>>>        String[] aLines 
12375>>>>>        tDocumentCommand[] aCommands 
12375>>>>>        tDocumentCommand[] aCommands 
12376>>>>>        Integer iPos 
12376>>>>>        Integer iMax 
12376>>>>>        String sReturn 
12376>>>>>        String sCRLF 
12376>>>>>        
12376>>>>>        Move ((Character(10))+(Character(13))) to sCRLF 
12377>>>>>        
12377>>>>>        Get ImageText sObject sMethod to aLines 
12378>>>>>        Move (ParseImage(Self,aLines)) to aCommands 
12379>>>>>        Move (stripCodes(Self,aCommands,sType,sElement)) to aCommands
12380>>>>>        
12380>>>>>        Move (SizeOfArray(aCommands)) to iMax 
12381>>>>>        For iPos from 0 to (iMax-1) 
12387>>>>>>
12387>>>>>            If (sReturn<>"") Append sReturn sCRLF
12390>>>>>            Append sReturn aCommands[iPos].sDesc
12391>>>>>        Loop
12392>>>>>>
12392>>>>>        
12392>>>>>        Function_Return sReturn 
12393>>>>>    End_Function
12394>>>>>
12394>>>>>    Function MethodDescription String sObject String sMethod Returns String 
12397>>>>>        String sReturn 
12397>>>>>        Get GenericDetail sObject sMethod "detail" "" to sReturn 
12398>>>>>        Function_Return sReturn 
12399>>>>>    End_Function
12400>>>>>
12400>>>>>    Function ParameterDescription String sObject String sMethod String sParameter Returns String
12403>>>>>        String sReturn 
12403>>>>>        Get GenericDetail sObject sMethod "param" sParameter to sReturn
12404>>>>>        
12404>>>>>        Function_Return sReturn 
12405>>>>>    End_Function  
12406>>>>>    
12406>>>>>    Function ReturnDescription String sObject String sMethod Returns String
12409>>>>>        String sReturn 
12409>>>>>        Get GenericDetail sObject sMethod "returns" "" to sReturn
12410>>>>>        
12410>>>>>        Function_Return sReturn 
12411>>>>>    End_Function  
12412>>>>>    
12412>>>>>    Function ErrorDescription String sObject String sMethod String sError Returns String
12415>>>>>        String sReturn 
12415>>>>>        Get GenericDetail sObject sMethod "errors" sError to sReturn
12416>>>>>        
12416>>>>>        Function_Return sReturn 
12417>>>>>    End_Function  
12418>>>>>    
12418>>>>>    Function StructDescription String sStruct Returns String
12421>>>>>        String sReturn 
12421>>>>>        Get GenericDetail "struct" sStruct "" "" to sReturn
12422>>>>>        
12422>>>>>        Function_Return sReturn 
12423>>>>>    End_Function  
12424>>>>>    
12424>>>>>    Function StructElementDescription String sStruct String sElement Returns String
12427>>>>>        String sReturn 
12427>>>>>        Get GenericDetail "struct" sStruct "element" sElement to sReturn
12428>>>>>        
12428>>>>>        Function_Return sReturn 
12429>>>>>    End_Function 
12430>>>>>End_Object
12431>>>
12431>>>// So Dataflex has this long standing "feature" where strings in a table are
12431>>>// always padded to the length of the field. This is a pain when developing
12431>>>// APIs because using the file buffer is a bit easier to code than using the
12431>>>// DD buffer. So we provide a custom version of the move command that right 
12431>>>// trim's the first parameter if it's a string.
12431>>>
12431>>>Struct ServiceErrorType
12431>>>    String serviceName
12431>>>    String customErrorStructName
12431>>>    Variant errorStruct
12431>>>End_Struct
12431>>>
12431>>>// This global is unfortunate but needed so that when errors are generated
12431>>>// we know which Evolution runtime to send details to.
12431>>>Global_Variable Integer EVO_CURRENT_SERVICE
12431>>>
12431>>>Use cThriftlyErrorSystem.pkg
Including file: cThriftlyErrorSystem.pkg    (C:\Users\marce\OneDrive\Documentos\Thriftly Developer\Dataflex\Library_x64\AppSrc\cThriftlyErrorSystem.pkg)
12431>>>>>Use UI
12431>>>>>Use Dferror.pkg
12431>>>>>
12431>>>>>Struct ErrorData
12431>>>>>    Boolean  Unhandled
12431>>>>>    Integer  ErrorNumber
12431>>>>>    Integer  LineNumber
12431>>>>>    Boolean  IsCritical
12431>>>>>    String   Value
12431>>>>>    String   Description
12431>>>>>    String   Caption
12431>>>>>    String[] CallStack
12431>>>>>End_Struct
12431>>>>>
12431>>>>>Define C_CRLF for (Character(13)+Character(10))
12431>>>>>
12431>>>>>Class cThriftlyErrorSystem is an ErrorSystem    
12432>>>>>    Procedure Construct_Object
12434>>>>>        Property Handle phoEvoRuntime
12435>>>>>        Property Boolean pbErrorsIncludeStackTrace True
12436>>>>>        Property Integer Error_Processing_State False
12437>>>>>        Forward Send Construct_Object
12439>>>>>    End_Procedure
12440>>>>>
12440>>>>>    Procedure End_Construct_Object
12442>>>>>        Forward Send End_Construct_Object
12444>>>>>        
12444>>>>>        Send RemoveAllUserErrors // we want everything to run through our handlers
12445>>>>>    End_Procedure
12446>>>>>
12446>>>>>    Function StringToArray String sSrc String sDelim Returns String[]
12448>>>>>        Integer iPos iCtr
12448>>>>>        String[] sData
12449>>>>>        Repeat
12449>>>>>>
12449>>>>>            Move (Pos(sDelim,sSrc)) to iPos
12450>>>>>            If (iPos > 0) Begin
12452>>>>>                Move (Left(sSrc,(iPos-1))) to sData[iCtr]
12453>>>>>                Move (Replace(sData[iCtr],sSrc,'')) to sSrc
12454>>>>>                Move (Replace(sDelim,sSrc,'')) to sSrc
12455>>>>>                Increment iCtr
12456>>>>>            End
12456>>>>>>
12456>>>>>            Else Break
12458>>>>>        Loop
12459>>>>>>
12459>>>>>        If (Length(sSrc) > 0) Begin
12461>>>>>          Move sSrc to sData[iCtr]
12462>>>>>        End
12462>>>>>>
12462>>>>>        Function_Return sData
12463>>>>>    End_Function
12464>>>>>  
12464>>>>>    Procedure Error_Report Integer ErrNum Integer Err_Line String ErrMsg
12466>>>>>        Integer iReply iIcon
12466>>>>>        String  sErrorText sMess sCallStack
12466>>>>>        String[] callstack
12467>>>>>        String  sSource sCaption
12467>>>>>        Integer iSrcPos iSrc iTxtLen
12467>>>>>        Handle hoRuntime
12467>>>>>        Variant vRuntime
12467>>>>>        Variant vErrInfo
12467>>>>>        Boolean bIsUnhandled bUnhandledSupport bCritical bVerbose
12467>>>>>        ErrorData errinfo
12467>>>>>        ErrorData errinfo
12467>>>>>        
12467>>>>>        If (Error_processing_State(Self)) Begin // don't allow error
12469>>>>>            Procedure_Return                     // recursion
12470>>>>>        End
12470>>>>>>
12470>>>>>        
12470>>>>>        Set Error_Processing_State to True // we are now in an error reporting state
12471>>>>>        Get Is_Critical errnum to bCritical
12472>>>>>
12472>>>>>        Get ComRuntime of EVO_CURRENT_SERVICE to vRuntime
12473>>>>>        Get Create U_cComIEvoRuntime to hoRuntime
12474>>>>>        Set pvComObject of hoRuntime to vRuntime
12475>>>>>
12475>>>>>        Move True to errinfo.Unhandled
12476>>>>>        Move ErrNum to errinfo.ErrorNumber
12477>>>>>        Move Err_Line to errinfo.LineNumber
12478>>>>>        Move bCritical to errinfo.IsCritical
12479>>>>>
12479>>>>>        If (pbErrorsIncludeStackTrace(Self)) Begin
12481>>>>>            CallStackDump sCallStack
12482>>>>>            
12482>>>>>            Get StringToArray sCallStack C_CRLF to callstack
12483>>>>>            // This function ends up in the call stack, which is stupid and deceptive, so remove it if it's present.
12483>>>>>            // Unfortunately it's not ALWAYS present, so you can't just always remove the first time.
12483>>>>>            If (Left(callstack[0], 16) = "MSG_ERROR_REPORT") ;                Move (RemoveFromArray(callstack, 0)) to callstack
12486>>>>>            
12486>>>>>            Move callstack to errinfo.CallStack
12487>>>>>        End
12487>>>>>>
12487>>>>>            
12487>>>>>        If not ( isTrapped( TrappedErrors( Self ), ErrNum ) ) Begin
12489>>>>>            // if trapped do nothing
12489>>>>>            
12489>>>>>            // We used to forward send. Since this is based on array, it does not understand this message, the forward was
12489>>>>>            // not understood. Since arrays don't delegate or error, nothing happened.
12489>>>>>            // An easier way to do nothing, is to do nothing, hence this line is removed
12489>>>>>            //forward send Error_Report ErrNum Err_Line ErrMsg
12489>>>>>            
12489>>>>>            Set pvComObject of hoRuntime to (NullComObject())
12490>>>>>            Send Destroy_Object of hoRuntime
12491>>>>>        End
12491>>>>>>
12491>>>>>        Else Begin
12492>>>>>            // See if source information is provided (Source = module.function). If so remove
12492>>>>>            // as detail. Must find last instance of this in string
12492>>>>>            Move (pos(C_ErrorContextSourceText,ErrMsg)) to iSrc
12493>>>>>            If iSrc Begin
12495>>>>>                Move (iSrc-1) to iSrcPos
12496>>>>>                Move (length(C_ErrorContextSourceText)) to  iTxtLen
12497>>>>>                Move ErrMsg to sSource
12498>>>>>                Repeat // this makes sure we find last instance of this
12498>>>>>>
12498>>>>>                    Move (remove(sSource, 1, iSrc-1 + iTxtLen )) to sSource // right part of string
12499>>>>>                    Move (pos(C_ErrorContextSourceText,sSource)) to iSrc           // see if it was the last
12500>>>>>                    If iSrc ;                                               // if not, track length                       Move (iSrcPos + iTxtLen + iSrc-1) to iSrcPos
12503>>>>>                Until (iSrc=0)
12505>>>>>                Move (trim(left(ErrMsg,iSrcPos))) to ErrMsg
12506>>>>>                If (right(ErrMsg,1)=',') ;                   Move (left(ErrMsg,length(ErrMsg)-1)) to ErrMsg
12509>>>>>            End
12509>>>>>>
12509>>>>>            
12509>>>>>            // the caption normally used for handled user errors
12509>>>>>            Move "" to sCaption
12510>>>>>            // if an operator error this may be a Procedure UserError situation where the
12510>>>>>            // caption is passed in the error text. If so, get the caption
12510>>>>>            If (ErrNum=DFERR_OPERATOR) Begin
12512>>>>>             Move (pos(C_ErrorCaption,ErrMsg)) to iSrc
12513>>>>>             If iSrc Begin
12515>>>>>                Move (length(C_ErrorCaption)) to  iTxtLen
12516>>>>>                Move (remove(ErrMsg, 1, iSrc-1 + iTxtLen )) to sCaption
12517>>>>>                Move (Left(ErrMsg,iSrc-1)) to ErrMsg
12518>>>>>             End
12518>>>>>>
12518>>>>>            End
12518>>>>>>
12518>>>>>
12518>>>>>            Move ErrMsg to errinfo.Value
12519>>>>>            Move sCaption to errinfo.Caption
12520>>>>>            
12520>>>>>            Get Error_Description ErrNum ErrMsg to sErrorText
12521>>>>>            
12521>>>>>            // if the error source is identified we can get extended error
12521>>>>>            // text for our error message
12521>>>>>            If ghoErrorSource Begin
12523>>>>>                Get extended_error_Message of ghoErrorSource to sMess
12524>>>>>                If sMess ne '' ;                   Move (sErrorText + "\n\n" + sMess ) to sErrorText
12527>>>>>            End
12527>>>>>>
12527>>>>>
12527>>>>>            Move sErrorText to errinfo.Description
12528>>>>>            Send Custom_Error_Report of EVO_CURRENT_SERVICE hoRuntime errinfo
12529>>>>>
12529>>>>>            Set pvComObject of hoRuntime to (NullComObject())
12530>>>>>            Send Destroy_Object of hoRuntime
12531>>>>>            
12531>>>>>            // abort on critical errors
12531>>>>>            If bCritical Abort
12534>>>>>       End
12534>>>>>>
12534>>>>>
12534>>>>>       Move 0 to ghoErrorSource
12535>>>>>       Set Error_Processing_State to False // no longer reporting an error
12536>>>>>    End_Procedure
12537>>>>>
12537>>>>>End_Class
12538>>>
12538>>>
12538>>>
12538>>>
12538>>>Use SoapConstants.pkg
Including file: SoapConstants.pkg    (C:\Program Files\DataFlex 26.0\Pkg\SoapConstants.pkg)
12538>>>>>// SoapConstants.pkg
12538>>>>>// constants used by soap
12538>>>>>
12538>>>>>// DataFlex datatypes that we support in soap.
12538>>>>>// These MUST match the dataflex definitions as provided in fmac
12538>>>>>Enum_List
12538>>>>>    Define xsString    for 0
12538>>>>>    Define xsNumber    for 1
12538>>>>>    Define xsDate      for 2
12538>>>>>    Define xsInteger   for 3
12538>>>>>    Define xsBigint    for 4
12538>>>>>    Define xsReal      for 5
12538>>>>>    Define xsBoolean   for 6
12538>>>>>    Define xsTime      for 8
12538>>>>>    Define xsDatetime  for 9
12538>>>>>    Define xsFloat     for 10
12538>>>>>    Define xsChar      for 11
12538>>>>>    Define xsUchar     for 12
12538>>>>>    Define xsShort     for 13
12538>>>>>    Define xsUShort    for 14
12538>>>>>    Define xsUinteger  for 15
12538>>>>>    Define xsUbigint   for 17
12538>>>>>    Define xsCurrency  for 18
12538>>>>>    Define xsStruct    for 19
12538>>>>>    Define xsDecimal   for 22
12538>>>>>
12538>>>>>    Define xsEmpty     for  -1  // not a real datatype. Used with return types when nothing is returned. We must use -1 (the runtime message InterfaceMessageParamType returns this)
12538>>>>>    Define xsAnyType    for 127  // not a real type (represent as XML within a wrapper document)
12538>>>>>    Define xsXmlElement for 128  // not a real type (represent as an xml document. <any /> type in schema)
12538>>>>>    Define xsAnyTypeStr    for 129  // not a real type (represent as XML serialized stringwithin a wrapper document). Can be used in struct/array definitions.
12538>>>>>    Define xsXmlElementStr for 130  // not a real type (represent as an xml serialized stringdocument. <any /> type in schema). Can be used in struct/array definitions.
12538>>>>>    Define xsBase64Binary for 131 //  not a real type (represent as a base64binary serialized stringdocument. Can be used in struct/array definitions.
12538>>>>>
12538>>>>>End_Enum_List
12538>>>>>
12538>>>>>// soap style
12538>>>>>Enum_List
12538>>>>>   Define ssDocument
12538>>>>>   Define ssRPC
12538>>>>>End_Enum_List
12538>>>>>
12538>>>>>// soap encoding
12538>>>>>Enum_List
12538>>>>>   Define seLiteral
12538>>>>>   Define seEncoded
12538>>>>>End_Enum_List
12538>>>>>
12538>>>>>// service/port-types. Currently we only support soap
12538>>>>>Enum_List
12538>>>>>   Define ptUnKnown
12538>>>>>   Define ptSOAP
12538>>>>>   Define ptHttp
12538>>>>>End_Enum_List
12538>>>>>
12538>>>>>Define C_UnBounded            for -1 // used when maxOccurs=Unbounded
12538>>>>>
12538>>>>>Define svSOAP11 for 1
12538>>>>>Define svSOAP12 for 2
12538>>>>>
12538>>>>>// SOAP URI constants (SOAP1.1)
12538>>>>>Define C_WSDLURI              for "http://schemas.xmlsoap.org/wsdl/"
12538>>>>>Define C_SOAPURI              for "http://schemas.xmlsoap.org/wsdl/soap/"
12538>>>>>Define C_XMLSCHEMAURI         for "http://www.w3.org/2001/XMLSchema"
12538>>>>>Define C_XMLSCHEMAXSIURI      for "http://www.w3.org/2001/XMLSchema-instance"
12538>>>>>Define C_SOAPENVELOPEURI      for "http://schemas.xmlsoap.org/soap/envelope/"
12538>>>>>Define C_SOAPENCODINGURI      for "http://schemas.xmlsoap.org/soap/encoding/"
12538>>>>>Define C_ContentTypeSOAP      for "text/xml"
12538>>>>>Define C_SOAPHREF             for "href" // 1.1 uses href while 1.2 uses ref
12538>>>>>
12538>>>>>// SOAP1.2 constants
12538>>>>>Define C_SOAPURI12            for "http://schemas.xmlsoap.org/wsdl/soap12/"
12538>>>>>Define C_SOAPENVELOPEURI12    for "http://www.w3.org/2003/05/soap-envelope"
12538>>>>>Define C_SOAPENCODINGURI12    for "http://www.w3.org/2003/05/soap-encoding"
12538>>>>>Define C_SOAPRPC12            for "http://www.w3.org/2003/05/soap-rpc"
12538>>>>>Define C_ContentTypeSOAP12    for "application/soap+xml"
12538>>>>>Define C_SOAPHREF12 for "ref"
12538>>>>>
12538>>>>>Define C_MTOMMimeMarker for "dfMimeContent"
12538>>>>>
12538>>>
12538>>>// The SOAP Constants are missing Boolean (Bit type, not logical type)
12538>>>// So we define it ourselves (FMAC defines it "ARGBIT = 16")
12538>>>Define xsBit for 16
12538>>>
12538>>>Use Variant.pkg
12538>>>Use Flexml.pkg
Including file: Flexml.pkg    (C:\Program Files\DataFlex 26.0\Pkg\Flexml.pkg)
12538>>>>>Use VdfBase.pkg
12538>>>>>Use LanguageText.pkg
12538>>>>>Use GlobalFunctionsProcedures.pkg
12538>>>>>
12538>>>>>
12538>>>>>// Used to designate that a handle is a handle to an Xml Dom object. This
12538>>>>>// is used/required by server web-services but could be used elsewhere .
12538>>>>>
12538>>>>>
12538>>>>>// Types of Nodes
12538>>>>>
12538>>>>>
12538>>>>>// classes and methods defined in fmac
12538>>>>>
12538>>>>>
12538>>>>>Register_Function transformNode Handle infcXSLNode Returns String
12538>>>>>
12538>>>>>
12538>>>>>
12538>>>>>
12538>>>>>
12538>>>>>
12538>>>>>
12538>>>>>
12538>>>>>
12538>>>>>// XML function & procedure registration
12538>>>>>
12538>>>>>Register_Procedure Set XmlInterface Handle iHandle
12538>>>>>Register_Function XmlInterface Returns Handle
12538>>>>>
12538>>>>>// NODE Properties
12538>>>>>Register_Function phAttributes Returns Handle
12538>>>>>Register_Function psBaseName Returns String
12538>>>>>Register_Function phChildNodes Returns Handle
12538>>>>>Register_Function phDefinition Returns Handle
12538>>>>>Register_Function phFirstChild Returns Handle
12538>>>>>Register_Function phLastChild Returns Handle
12538>>>>>Register_Function phNextSibling Returns Handle
12538>>>>>Register_Function psNameSpaceURI Returns String
12538>>>>>Register_Function psNodeName Returns String
12538>>>>>Register_Function piNodeType Returns Integer
12538>>>>>Register_Function psNodeTypeString Returns String
12538>>>>>Register_Function phOwnerDocument Returns Handle
12538>>>>>Register_Function phParentNode Returns Handle
12538>>>>>Register_Function pbParsed Returns Integer
12538>>>>>Register_Function psPrefix Returns String
12538>>>>>Register_Function phPreviousSibling Returns Handle
12538>>>>>Register_Function pbSpecified Returns Integer
12538>>>>>Register_Function psText Returns String
12538>>>>>Register_Procedure Set psText String sText
12538>>>>>Register_Function psXML Returns String
12538>>>>>
12538>>>>>// Node Read write properties
12538>>>>>
12538>>>>>Register_Procedure Set psDataType String sTypeName
12538>>>>>Register_Function psDataType Returns String
12538>>>>>Register_Procedure Set pvNodeTypedValue Integer iType Integer iAddress
12538>>>>>Register_Function pvNodeTypedValue Integer iType Returns Integer  // address of data
12538>>>>>Register_Procedure Set psNodeValue String sValue
12538>>>>>Register_Function psNodeValue Returns String
12538>>>>>
12538>>>>>// Node Methods
12538>>>>>
12538>>>>>Register_Function AppendChild Handle iChildInfc Returns Handle
12538>>>>>Register_Function CloneInfcNode Handle bRecurse Returns Handle
12538>>>>>Register_Function HasChildNodes Returns Integer
12538>>>>>Register_Function InsertBefore Handle infcNodeToInsert Handle iWhere Returns Handle
12538>>>>>Register_Function RemoveChild Handle iChildToRemove Returns Handle
12538>>>>>Register_Function ReplaceChild Handle iNewChild Handle iChildToReplace Returns Handle
12538>>>>>Register_Function SelectNodes String selectstring Returns Handle
12538>>>>>Register_Function SelectSingleNode String selectstring Returns Handle
12538>>>>>
12538>>>>>// Node Collections
12538>>>>>// READONLY PROPERTIES
12538>>>>>
12538>>>>>Register_Function phItem Integer iItem Returns Handle
12538>>>>>Register_Function phElementItem Integer iItem Returns Handle
12538>>>>>
12538>>>>>Register_Function piLength Returns Integer
12538>>>>>
12538>>>>>Register_Function NamedItem String sName Returns Handle
12538>>>>>Register_Function QualifiedItem String sBaseName String sNameSpace Returns Handle
12538>>>>>Register_Function RemoveNamedItem String sName Returns Handle
12538>>>>>Register_Function RemoveQualifiedItem String sBaseName String sNameSpace Returns Handle
12538>>>>>Register_Function SetNamedItem Handle iInterface Returns Handle
12538>>>>>
12538>>>>>// XML DOM Document
12538>>>>>// Read only properties
12538>>>>>
12538>>>>>Register_Function phDocType Returns Handle
12538>>>>>Register_Function phImplementation Returns Handle
12538>>>>>Register_Function phParseError Returns Handle
12538>>>>>Register_Function piReadyState Returns Integer
12538>>>>>Register_Function psURL Returns String
12538>>>>>
12538>>>>>// Read Write Properties
12538>>>>>
12538>>>>>Register_Procedure Set pbAsync Integer bValue
12538>>>>>Register_Function pbAsync Returns Integer
12538>>>>>Register_Procedure Set phDocumentElement Handle iElement
12538>>>>>Register_Function phDocumentElement Returns Handle
12538>>>>>Register_Procedure Set pbPreserveWhiteSpace Integer bValue
12538>>>>>Register_Function pbPreserveWhiteSpace Returns Integer
12538>>>>>Register_Procedure Set pbResolveExternals Integer bValue
12538>>>>>Register_Function pbResolveExternals Returns Integer
12538>>>>>Register_Procedure Set pbValidateOnParse Integer bValue
12538>>>>>Register_Function pbValidateOnParse Returns Integer
12538>>>>>
12538>>>>>// Events
12538>>>>>
12538>>>>>// Methods
12538>>>>>
12538>>>>>Register_Function Abort Returns Integer
12538>>>>>Register_Function ElementsByTagName String sTagName Returns Handle
12538>>>>>Register_Function LoadDocument String sURLName Returns Integer
12538>>>>>Register_Function LoadXML String sXMLText Returns Integer
12538>>>>>Register_Function NodeFromID String sNodeName Returns Handle
12538>>>>>Register_Function SaveDocument String sURLName Returns Integer
12538>>>>>
12538>>>>>// Parse Error
12538>>>>>// Read Only Properties
12538>>>>>
12538>>>>>Register_Function piErrorCode Returns Integer
12538>>>>>Register_Function piFilePos Returns Integer
12538>>>>>Register_Function piLine Returns Integer
12538>>>>>Register_Function piLinePos Returns Integer
12538>>>>>Register_Function psReason Returns String
12538>>>>>Register_Function psSrcText Returns String
12538>>>>>Register_Function psURL Returns String
12538>>>>>
12538>>>>>// DOM Implementation
12538>>>>>// Method
12538>>>>>
12538>>>>>Register_Function HasFeature String sSystem String sFeature Returns Integer
12538>>>>>
12538>>>>>// Methods
12538>>>>>
12538>>>>>Register_Function substringData Integer iOffset Integer iCount Returns String
12538>>>>>Register_Function appendData String sData Returns Handle
12538>>>>>Register_Function insertData Integer iOffset String sData Returns Handle
12538>>>>>Register_Function deleteData Integer iOffset Integer iCount Returns Handle
12538>>>>>Register_Function replaceData Integer iOffset Integer iCount String sData Returns Handle
12538>>>>>
12538>>>>>// Attributes
12538>>>>>
12538>>>>>Register_Function psName Returns String
12538>>>>>
12538>>>>>// Elements
12538>>>>>// Read Only properties
12538>>>>>
12538>>>>>Register_Function psTagName Returns String
12538>>>>>
12538>>>>>// Methods
12538>>>>>
12538>>>>>Register_Procedure Set attributeValue String sName String sValue
12538>>>>>Register_Function attributeValue String sName Returns String
12538>>>>>Register_Function removeAttribute String sName Returns Handle
12538>>>>>Register_Function attributeNode String sName Returns Handle
12538>>>>>Register_Procedure Set attributeNode Handle iNode Returns Handle
12538>>>>>Register_Function removeAttributeNode Handle iNode Returns Handle
12538>>>>>
12538>>>>>// DOM Text
12538>>>>>// Methods
12538>>>>>
12538>>>>>Register_Function splitText Integer iOffset Returns Integer
12538>>>>>
12538>>>>>// DOM Processing Instruction
12538>>>>>// Read Only Properties
12538>>>>>Register_Function psTarget Returns String
12538>>>>>
12538>>>>>// DOM Document Type
12538>>>>>
12538>>>>>Register_Function phEntities Returns Handle
12538>>>>>Register_Function phNotations Returns Handle
12538>>>>>
12538>>>>>// DOM Notations
12538>>>>>
12538>>>>>Register_Function psPublicID Returns String
12538>>>>>Register_Function psSystemID Returns String
12538>>>>>Register_Function psNotationName Returns String
12538>>>>>
12538>>>>>// create nodes
12538>>>>>
12538>>>>>Register_Function createAttribute String sName Returns Handle
12538>>>>>Register_Function createCDataSection String sValue Returns Handle
12538>>>>>Register_Function createComment String sValue Returns Handle
12538>>>>>Register_Function createDocumentFragment Returns Handle
12538>>>>>Register_Function createElement String sTagName Returns Handle
12538>>>>>Register_Function createEntityReference String sEntityName Returns Handle
12538>>>>>Register_Function createNode Integer iNodeType String sName String sNameSpace Returns Handle
12538>>>>>Register_Function createProcessingInstruction String sTarget String sData Returns Handle
12538>>>>>Register_Function createTextNode String sData Returns Handle
12538>>>>>
12538>>>>>Register_Function ChangeNodeType Integer iTypeOfNode Integer bSetInterface Returns Handle
12538>>>>>
12538>>>>>
12538>>>>>//          Part 1:  Base Document Logic Specialized For Templates
12538>>>>>
12538>>>>>//
12538>>>>>//  XML Collections
12538>>>>>//
12538>>>>>//  Collection mixin has common functions to both node lists and named node maps
12538>>>>>//
12538>>>>>
12538>>>>>// This provides functions required of all XMLDOM objects.
12538>>>>>//
12538>>>>>Class cXMLDOMMixin is a Mixin
12539>>>>>    
12539>>>>>    // Create an XML object of passed class Id and bind passed interface. returns
12539>>>>>    // the object handle. All dynamic XML object can be created using this syntax
12539>>>>>    
12539>>>>>    Function CreateXMLObject Integer iClassId Handle hinfXMLInterface Returns Handle
12541>>>>>        Handle hoId hoDocument
12541>>>>>        // We will always create objects at the DOMDocument level.
12541>>>>>        Get DocumentObject to hoDocument
12542>>>>>        If (hoDocument=0) Begin  // this should never happen.
12544>>>>>            Error DFERR_XML_INTERNAL_ERROR C_$XmlFailedNoDocObject
12545>>>>>>
12545>>>>>            Function_Return 0
12546>>>>>        End
12546>>>>>>
12546>>>>>        If hinfXMLInterface Begin
12548>>>>>            Get Create of hoDocument iClassId to hoID
12549>>>>>            Set XMLInterface of hoID to hinfXMLInterface
12550>>>>>        End
12550>>>>>>
12550>>>>>        Function_Return hoID
12551>>>>>    End_Function
12552>>>>>    
12552>>>>>    // create an XML Node object based on the interface type.
12552>>>>>    // this will convert the interface to the proper type and will create
12552>>>>>    // an appropriate DF object.
12552>>>>>    // This requires that a DocumentObject exists
12552>>>>>    
12552>>>>>    Function CreateXMLNode Handle hinfc Returns Handle
12554>>>>>        Integer iType iClassId
12554>>>>>        Handle  hoDocument hoNode
12554>>>>>        // Get the node type of the infc handle w/o creating a DF object
12554>>>>>        Move (invokexml(DF_IXMLDOMNODE, GET_piNodeType, hinfc, 0, 0, 0, 0)) to iType
12555>>>>>        Move (invokexml(DF_IXMLDOMNODE, GET_ChangeNodeType, hinfc, iType, 1, 0, 0)) to hInfc
12556>>>>>        If (hinfc=0) Begin
12558>>>>>            // this should not happen and we would need to know about this.
12558>>>>>            Error DFERR_XML_INTERNAL_ERROR (C_$XmlFailedNoDocObject + String(iType))
12559>>>>>>
12559>>>>>            Function_Return 0
12560>>>>>        End
12560>>>>>>
12560>>>>>        Get DocumentObject to hoDocument
12561>>>>>        // you can augment your class IDs in a single place.
12561>>>>>        Get NodeClassId of hoDocument iType to iClassId
12562>>>>>        Get CreateXMLObject of hoDocument iClassId hinfc to hoNode
12563>>>>>        
12563>>>>>        Function_Return hoNode
12564>>>>>    End_Function
12565>>>>>    
12565>>>>>    
12565>>>>>    // Change object's class. This let's you change the class id of an object
12565>>>>>    // on an object by object basis. This would let you create nodes (e.g. elements)
12565>>>>>    // that have a custom interface for each node type. Normally, this would be sent
12565>>>>>    // after a node has been created using one of the default classes
12565>>>>>    Function ChangeNodeClass Handle hoNode Integer iClassID Returns Handle
12567>>>>>        Integer iType
12567>>>>>        Handle  hinfcNew
12567>>>>>        Get piNodeType of hoNode to iType
12568>>>>>        Get ChangeNodeType of hoNode iType False to hInfcNew
12569>>>>>        Send Destroy to hoNode // destroy object and old infc handle.
12570>>>>>        Get CreateXMLObject iClassId hinfcNew to hoNode
12571>>>>>        Function_Return hoNode
12572>>>>>    End_Function
12573>>>>>    
12573>>>>>End_Class
12574>>>>>
12574>>>>>
12574>>>>>Class cXMLDOMCollectionMixin is a Mixin
12575>>>>>    
12575>>>>>    Import_Class_Protocol cXMLDOMMixin
12576>>>>>    
12576>>>>>    //  Returns number of items in the collection
12576>>>>>    //
12576>>>>>    Function NodeListLength Returns Integer
12578>>>>>        Integer iLength
12578>>>>>        Get piLength to iLength
12579>>>>>        Function_Return iLength
12580>>>>>    End_Function
12581>>>>>    
12581>>>>>    // Returns an XML node object for pass item
12581>>>>>    //
12581>>>>>    Function CollectionNode Integer I Returns Handle
12583>>>>>        Handle hoNewNode
12583>>>>>        Handle infcItem
12583>>>>>        Get phItem i to infcItem
12584>>>>>        If (infcItem) ;            Get CreateXMLNode infcItem to hoNewNode
12587>>>>>        Function_Return hoNewNode
12588>>>>>    End_Function
12589>>>>>    
12589>>>>>    
12589>>>>>End_Class
12590>>>>>
12590>>>>>// Simple declarations of collections.
12590>>>>>
12590>>>>>Class cXMLDOMNodeList is a BaseXmlDomNodeList
12591>>>>>    Import_Class_Protocol cXMLDOMCollectionMixin
12592>>>>>End_Class
12593>>>>>
12593>>>>>Class cXMLDOMNamedNodeMap is a BaseXmlDomNamedNodeMap
12594>>>>>    
12594>>>>>    Import_Class_Protocol cXMLDOMCollectionMixin
12595>>>>>    
12595>>>>>    // returns a node attribute that matches passed name, zero if none
12595>>>>>    Function NamedNode String sName Returns Handle
12597>>>>>        Handle hoNewNode
12597>>>>>        Handle infcItem
12597>>>>>        Get NamedItem sName to infcItem
12598>>>>>        If infcItem ;            Get CreateXMLNode infcItem to hoNewNode
12601>>>>>        Function_Return hoNewNode
12602>>>>>    End_Function
12603>>>>>    
12603>>>>>    // Adds or changes a node attribute
12603>>>>>    // This should return the passed object Id which is now bound to the attribute. If an error, returns 0
12603>>>>>    Function SetNamedNode Handle hoNode Returns Handle
12605>>>>>        Handle hinfcNode hinfcItem
12605>>>>>        Get XMLInterface of hoNode to hinfcNode // node of passed attribute
12606>>>>>        Get SetNamedItem hinfcNode to hinfcItem
12607>>>>>        If hinfcItem ;            Set XMLInterface of hoNode to hinfcItem
12610>>>>>        Else ;            Move 0 to hoNode // zero indicates error
12612>>>>>        Function_Return hoNode
12613>>>>>    End_Function
12614>>>>>    
12614>>>>>    // removes named attribute, Returns handle of removed node or zero if not found.
12614>>>>>    // Note that returned object must be disposed of or moved somewhere else.
12614>>>>>    Function RemoveNamedNode String sName Returns Handle
12616>>>>>        Handle hoNewNode
12616>>>>>        Handle infcItem
12616>>>>>        Get RemoveNamedItem sName to infcItem
12617>>>>>        If infcItem ;            Get CreateXMLNode infcItem to hoNewNode
12620>>>>>        Function_Return hoNewNode
12621>>>>>    End_Function
12622>>>>>    
12622>>>>>    Function QualifiedNode String sNameSpace String sBaseName Returns Handle
12624>>>>>        Handle hoNewNode
12624>>>>>        Handle infcItem
12624>>>>>        Get QualifiedItem  sBaseName sNameSpace  to infcItem
12625>>>>>        If infcItem ;            Get CreateXMLNode infcItem to hoNewNode
12628>>>>>        Function_Return hoNewNode
12629>>>>>    End_Function
12630>>>>>    
12630>>>>>    Function RemoveQualifiedNode String sNameSpace String sBaseName Returns Handle
12632>>>>>        Handle hoNewNode
12632>>>>>        Handle infcItem
12632>>>>>        Get RemoveQualifiedItem sBaseName sNameSpace to infcItem
12633>>>>>        If infcItem ;            Get CreateXMLNode infcItem to hoNewNode
12636>>>>>        Function_Return hoNewNode
12637>>>>>    End_Function
12638>>>>>    
12638>>>>>End_Class
12639>>>>>
12639>>>>>
12639>>>>>
12639>>>>>// Mixin for nodes.
12639>>>>>//
12639>>>>>//  First the declaration of functions that have no object references.
12639>>>>>//
12639>>>>>
12639>>>>>
12639>>>>>Class cXMLDOMNodeMixin is a Mixin
12640>>>>>    
12640>>>>>    Import_Class_Protocol cXMLDOMMixin
12641>>>>>    
12641>>>>>    //  Append Node to the end of list. Returns passed Object handle if Ok, 0 if error
12641>>>>>    
12641>>>>>    Function AppendNode Handle hoNode Returns Handle
12643>>>>>        Handle hinfcNode
12643>>>>>        Handle infcReturned
12643>>>>>        // Get COM Interface to call Append child.
12643>>>>>        Get XMLInterface of hoNode to hinfcNode
12644>>>>>        If (hinfcNode=0) ;            Function_Return 0
12647>>>>>        Get AppendChild hinfcNode to infcReturned
12648>>>>>        // Interface returned is stored in DataFlex object.
12648>>>>>        If (infcReturned=0) ;            Function_Return 0
12651>>>>>        Set XMLInterface of hoNode to infcReturned
12652>>>>>        Function_Return hoNode
12653>>>>>    End_Function
12654>>>>>    
12654>>>>>    //  Insert NewNode before Node. Returns passed newnode Object handle if Ok, 0 if error
12654>>>>>    
12654>>>>>    Function InsertBeforeNode Handle hoNewNode Handle hoNode Returns Handle
12656>>>>>        Handle hinfcNewNode hinfcNode hoRefNode infcReturned
12656>>>>>        Integer iType
12656>>>>>        // DOM says if no refnode argument passed or it is 0, append to end
12656>>>>>        If (Num_Arguments=1) ;            Move 0 to hoRefNode
12659>>>>>        Else ;            Move hoNode to hoRefNode
12661>>>>>        Get XMLInterface of hoNewNode to hinfcNewNode
12662>>>>>        If (hinfcNewNode=0) ;            Function_Return 0
12665>>>>>        If hoRefNode Begin
12667>>>>>            Get XMLInterface of hoRefNode to hinfcNode
12668>>>>>            If (hinfcNode=0) ;                Function_Return 0
12671>>>>>        End
12671>>>>>>
12671>>>>>        Get InsertBefore hinfcNewNode hinfcNode to infcReturned
12672>>>>>        If (infcReturned=0) ;            Function_Return 0
12675>>>>>        // Interface returned is stored in DataFlex object.
12675>>>>>        Set XMLInterface of hoNewNode to infcReturned
12676>>>>>        Function_Return hoNewNode
12677>>>>>    End_Function
12678>>>>>    
12678>>>>>    //  Remove Node. Returns object Id of removed node, zero if error
12678>>>>>    //  Important: The node is not destroyed! This lets you move it elsewhere if you want
12678>>>>>    
12678>>>>>    Function RemoveNode Handle hoNode Returns Handle
12680>>>>>        Handle hInfcNode
12680>>>>>        Get XMLInterface of hoNode to hInfcNode
12681>>>>>        If (hinfcNode=0) ;            Function_Return 0
12684>>>>>        Get RemoveChild hInfcNode to hinfcNode
12685>>>>>        If (hinfcNode=0) ;            Function_Return 0
12688>>>>>        Set XMLInterface of hoNode to hinfcNode
12689>>>>>        Function_Return hoNode
12690>>>>>    End_Function
12691>>>>>    
12691>>>>>    //  Replace Node. Returns object Id of replaced node, zero if error
12691>>>>>    //  Important: The replaced node is not destroyed! This lets you move it elsewhere if you want
12691>>>>>    
12691>>>>>    Function ReplaceNode Handle hoNewNode Handle hoNodeToReplace Returns Handle
12693>>>>>        Handle hInfcNewNode hinfcNodetoReplace hinfcNode
12693>>>>>        Get XMLInterface of hoNewNode       to hInfcNewNode
12694>>>>>        Get XMLInterface of hoNodetoReplace to hInfcNodetoreplace
12695>>>>>        If (hinfcNewNode=0 or hInfcNodeToReplace=0) ;            Function_Return 0
12698>>>>>        Get ReplaceChild hInfcNewNode hinfcNodeToReplace to hinfcNode
12699>>>>>        If (hinfcNode=0) ;            Function_Return 0
12702>>>>>        Set XMLInterface of hoNodetoReplace to hinfcNode
12703>>>>>        Function_Return hoNodetoReplace
12704>>>>>    End_Function
12705>>>>>    
12705>>>>>    // Remove the named node. Returns handle to removed node. You must destroy
12705>>>>>    // or move this removed object as needed
12705>>>>>    
12705>>>>>    Function RemoveNamedNode String sQueryString Returns Handle
12707>>>>>        Handle hoNode
12707>>>>>        Handle hInfcTemplate hinfcNode
12707>>>>>        Integer iRet
12707>>>>>        Get SelectSingleNode sQueryString to hinfcTemplate
12708>>>>>        If (hinfcTemplate) Begin
12710>>>>>            // Remove child returns an interface to the disassociated node.
12710>>>>>            // It should be disposed by setting it to an object and then calling destroy
12710>>>>>            Get RemoveChild hInfcTemplate to hInfcNode
12711>>>>>            // Even if hInfcTemplate and hInfcNode are the same their reference count will be incremented.
12711>>>>>            // Therefore we must destroy one the interfaces which will decrement the reference count thus
12711>>>>>            // avoding a memory leak
12711>>>>>            Move (invokexml(DF_IXMLDOMNODE, DESTROY_XML_INTERFACE, hInfcTemplate, 0, 0, 0, 0)) to iRet
12712>>>>>            If hInfcNode ;                Get CreateXMLNode hinfcNode to hoNode
12715>>>>>        End
12715>>>>>>
12715>>>>>        Function_Return hoNode
12716>>>>>    End_Function
12717>>>>>    
12717>>>>>    // This function creates a clone of the passed Node. if bRecurse all child nodes are also
12717>>>>>    // cloned. The object Id of the new clone object is returned.
12717>>>>>    // The interface of the object returned can be used in AppendChild to add
12717>>>>>    // the node to the XML Document.
12717>>>>>    
12717>>>>>    Function CloneNode Integer bRecurse Returns Handle
12719>>>>>        Handle hoNewNode
12719>>>>>        Handle hinfcNewNode
12719>>>>>        Get CloneInfcNode (If(bRecurse,-1,0)) to hinfcNewNode
12720>>>>>        If hinfcNewNode ;            Get CreateXMLNode hinfcNewNode to hoNewNode
12723>>>>>        Function_Return hoNewNode
12724>>>>>    End_Function
12725>>>>>    
12725>>>>>    //  Create a collection of all nodes. returns handle of a cXMLDomNodeList
12725>>>>>    
12725>>>>>    Function ChildNodes Returns Handle
12727>>>>>        Handle infcNodeList
12727>>>>>        Handle hoNodeList
12727>>>>>        Get phChildNodes to infcNodeList
12728>>>>>        If (infcNodeList) ;            Get CreateXMLObject U_cXMLDOMNodeList infcNodeList to hoNodeList
12731>>>>>        Function_Return hoNodeList
12732>>>>>    End_Function
12733>>>>>    
12733>>>>>    //  Create a collection of all attributes. returns handle of a cXMLDomNodeMapList
12733>>>>>    
12733>>>>>    Function AttributeNodes Returns Handle
12735>>>>>        Handle hoCollectionId   // Object to hold collection
12735>>>>>        Handle hinfcAttributes  // XML Interface for collection
12735>>>>>        Get phAttributes to hinfcAttributes
12736>>>>>        If (hinfcAttributes) ;            Get CreateXMLObject U_cXMLDOMNamedNodeMap hinfcAttributes to hoCollectionId
12739>>>>>        Function_Return hoCollectionId
12740>>>>>    End_Function
12741>>>>>    
12741>>>>>    //  Create a collection of all attributes for the temporary attribute node object.
12741>>>>>    //  Using this saves a small amount of time creating and destroying this object but
12741>>>>>    //  it must be used with care. This binding is temporary!
12741>>>>>    Function TempAttributeNodes Returns Handle
12743>>>>>        Handle hoCollectionId hoDocument
12743>>>>>        Handle hinfcAttributes  // XML Interface for collection
12743>>>>>        Get phAttributes to hinfcAttributes
12744>>>>>        If (hinfcAttributes) Begin
12746>>>>>            Get DocumentObject to hoDocument
12747>>>>>            Get phoTempDomNodeMap of hoDocument to hoCollectionId
12748>>>>>            Set XMLInterface of hoCollectionId to hinfcAttributes
12749>>>>>        End
12749>>>>>>
12749>>>>>        Function_Return hoCollectionId
12750>>>>>    End_Function
12751>>>>>    
12751>>>>>    
12751>>>>>    // Returns a collection of just elements
12751>>>>>    
12751>>>>>    Function ElementNodes String sQueryString Returns Handle
12753>>>>>        Handle hoNodeList
12753>>>>>        Handle hinfcNodeList
12753>>>>>        Get ElementsByTagName sQueryString to hinfcNodeList
12754>>>>>        If (hinfcNodeList <> 0) ;            Get CreateXMLObject U_cXMLDOMNodeList hinfcNodeList to hoNodeList
12757>>>>>        Function_Return hoNodeList
12758>>>>>    End_Function
12759>>>>>    
12759>>>>>    
12759>>>>>    
12759>>>>>    // Return object handle for query.
12759>>>>>    
12759>>>>>    Function FindNode String sQueryString Returns Handle
12761>>>>>        Handle hoNode
12761>>>>>        Handle hinfcNode
12761>>>>>        Get SelectSingleNode sQueryString to hinfcNode
12762>>>>>        If (hinfcNode <> 0) ;            Get CreateXMLNode hInfcNode to hoNode
12765>>>>>        Function_Return hoNode
12766>>>>>    End_Function
12767>>>>>    
12767>>>>>    // Return object handle for a collection node.
12767>>>>>    
12767>>>>>    
12767>>>>>    Function FindNodeList String sQueryString Returns Handle
12769>>>>>        Handle hoNodeList
12769>>>>>        Handle hinfcNodeList
12769>>>>>        Get SelectNodes sQueryString to hinfcNodeList
12770>>>>>        If (hinfcNodeList <> 0) ;            Get CreateXMLObject U_cXMLDOMNodeList hinfcNodeList to hoNodeList
12773>>>>>        Function_Return hoNodeList
12774>>>>>    End_Function
12775>>>>>    
12775>>>>>    // The CreatexxxxxNode messages creates an node object for the type specified. Both
12775>>>>>    // the interface and the object or of the correct type (i.e. element, comment)
12775>>>>>    // These all return an object handle which can be used to place the object via
12775>>>>>    // appendNode or InsertBeforeNode
12775>>>>>    
12775>>>>>    // This function creates a child element, returning a dataflex object.
12775>>>>>    // The interface of the object returned can be used in AppendChild to add
12775>>>>>    // the element to the XML Document.
12775>>>>>    
12775>>>>>    Function CreateElementNode String sTagName String sValue Returns Handle
12777>>>>>        Handle hoNewElement
12777>>>>>        Handle hoDocumentObject
12777>>>>>        Handle infcNewElement
12777>>>>>        Integer iClassId
12777>>>>>        // The DataFlex objects are created inside the nodes (elements).
12777>>>>>        // Create an element in the document and assign its interface to the new DF object.
12777>>>>>        Get DocumentObject to hoDocumentObject
12778>>>>>        Get createElement of hoDocumentObject sTagName to infcNewElement
12779>>>>>        If infcNewElement Begin // if there was an error, no infc handle would be returned
12781>>>>>            Get NodeClassId of hoDocumentObject NODE_ELEMENT to iClassId
12782>>>>>            Get CreateXMLObject iClassId infcNewElement to hoNewElement
12783>>>>>            If hoNewElement ; // very unlikely this will be zero                Set psText of hoNewElement to sValue
12786>>>>>        End
12786>>>>>>
12786>>>>>        Function_Return hoNewElement
12787>>>>>    End_Function
12788>>>>>    
12788>>>>>    // This function creates an attribute in a document. Attributes are _NOT_ children of an element.
12788>>>>>    // A DataFlex object is returned. An attribute can be added to an xml document using
12788>>>>>    // get AddAttributeNode.
12788>>>>>    
12788>>>>>    Function CreateAttributeNode String sName String sValue Returns Handle
12790>>>>>        Handle hoNewAttribute
12790>>>>>        Handle hoDocumentObject
12790>>>>>        Handle infcNewAttribute
12790>>>>>        Integer iClassId
12790>>>>>        Get DocumentObject to hoDocumentObject
12791>>>>>        // Create an Attribute in the document and assign its interface to the new DF object.
12791>>>>>        Get createAttribute of hoDocumentObject sName to infcNewAttribute
12792>>>>>        If infcNewAttribute Begin // if there was an error, no infc handle would be returned
12794>>>>>            Get NodeClassId of hoDocumentObject NODE_ATTRIBUTE to iClassId
12795>>>>>            Get CreateXMLObject iClassId infcNewAttribute to hoNewAttribute
12796>>>>>            // Set the value of the attribute.
12796>>>>>            If hoNewAttribute ; // very unlikely this will be 0                Set psText of hoNewAttribute to sValue
12799>>>>>        End
12799>>>>>>
12799>>>>>        Function_Return hoNewAttribute
12800>>>>>    End_Function
12801>>>>>    
12801>>>>>    // This function creates a child comment, returning a dataflex object.
12801>>>>>    // The interface of the object returned can be used in AppendChild to add
12801>>>>>    // the comment to the XML Document.
12801>>>>>    
12801>>>>>    Function CreateChildComment String sValue Returns Handle
12803>>>>>        Handle hoNewComment
12803>>>>>        Handle hoDocumentObject
12803>>>>>        Handle infcNewComment
12803>>>>>        Integer iClassID
12803>>>>>        Get DocumentObject to hoDocumentObject
12804>>>>>        // Create an Comment in the document and assign its interface to the new DF object.
12804>>>>>        Get createComment of hoDocumentObject sValue to infcNewComment
12805>>>>>        If infcNewComment Begin // if there was an error, no infc handle would be returned
12807>>>>>            Get NodeClassId of hoDocumentObject NODE_COMMENT to iClassId
12808>>>>>            Get CreateXMLObject iClassId infcNewComment to hoNewComment
12809>>>>>            If hoNewComment ; // very unlikely this will be 0                Set psText of hoNewComment to sValue
12812>>>>>        End
12812>>>>>>
12812>>>>>        Function_Return hoNewComment
12813>>>>>    End_Function
12814>>>>>    
12814>>>>>    // This function creates a child processing instruction, returning a dataflex object.
12814>>>>>    // The interface of the object returned can be used in AppendChild to add
12814>>>>>    // the processing instruction to the XML Document.
12814>>>>>    
12814>>>>>    Function CreateChildProcessingInstruction String sTarget String sValue Returns Handle
12816>>>>>        Handle hoNewProcessingInstruction
12816>>>>>        Handle hoDocumentObject
12816>>>>>        Handle infcNewProcessingInstruction
12816>>>>>        Integer iClassID
12816>>>>>        Get DocumentObject to hoDocumentObject
12817>>>>>        // Create an ProcessingInstruction in the document and assign its interface to the new DF object.
12817>>>>>        Get createProcessingInstruction of hoDocumentObject sTarget sValue to infcNewProcessingInstruction
12818>>>>>        If infcNewProcessingInstruction  Begin // if there was an error, no infc handle would be returned
12820>>>>>            Get NodeClassId of hoDocumentObject NODE_PROCESSING_INSTRUCTION to iClassId
12821>>>>>            Get CreateXMLObject iClassID infcNewProcessingInstruction to hoNewProcessingInstruction
12822>>>>>        End
12822>>>>>>
12822>>>>>        Function_Return hoNewProcessingInstruction
12823>>>>>    End_Function
12824>>>>>    
12824>>>>>    // This function creates a child text node, returning a dataflex object.
12824>>>>>    // The interface of the object returned can be used in AppendChild to add
12824>>>>>    // the text node to the XML Document.
12824>>>>>    
12824>>>>>    Function CreateChildTextNode String sValue Returns Handle
12826>>>>>        Handle hoNewTextNode
12826>>>>>        Handle hoDocumentObject
12826>>>>>        Handle infcNewTextNode
12826>>>>>        Integer iClassID
12826>>>>>        Get DocumentObject to hoDocumentObject
12827>>>>>        // Create an TextNode in the document and assign its interface to the new DF object.
12827>>>>>        Get createTextNode of hoDocumentObject sValue to infcNewTextNode
12828>>>>>        If infcNewTextNode Begin // if there was an error, no infc handle would be returned
12830>>>>>            Get NodeClassId of hoDocumentObject NODE_TEXT to iClassId
12831>>>>>            Get CreateXMLObject iClassId infcNewTextNode to hoNewTextNode
12832>>>>>        End
12832>>>>>>
12832>>>>>        Function_Return hoNewTextNode
12833>>>>>    End_Function
12834>>>>>    
12834>>>>>    // This function creates a cdata text node, returning a dataflex object.
12834>>>>>    // The interface of the object returned can be used in AppendChild to add
12834>>>>>    // the cdata node to the XML Document.
12834>>>>>    
12834>>>>>    Function CreateCDATASectionNode String sValue Returns Handle
12836>>>>>        Handle hoNewNode
12836>>>>>        Handle hoDocumentObject
12836>>>>>        Handle infcNewNode
12836>>>>>        Integer iClassId
12836>>>>>        // The DataFlex objects are created inside the nodes (elements).
12836>>>>>        // Create an element in the document and assign its interface to the new DF object.
12836>>>>>        Get DocumentObject to hoDocumentObject
12837>>>>>        Get createCDATASection of hoDocumentObject sValue to infcNewNode
12838>>>>>        If infcNewNode Begin
12840>>>>>            Get NodeClassId of hoDocumentObject NODE_CDATA_SECTION to iClassId
12841>>>>>            Get CreateXMLObject iClassId infcNewNode to hoNewNode
12842>>>>>        End
12842>>>>>>
12842>>>>>        Function_Return hoNewNode
12843>>>>>    End_Function
12844>>>>>    
12844>>>>>    // Create a document fragment.  Document fragments can be used to house nodes temporarily. When
12844>>>>>    // You append or insert a document fragment (appendNode InsertBeforeNode) child nodes are appended
12844>>>>>    // to the destination object and not the fragment node itself. This is useful!
12844>>>>>    
12844>>>>>    Function CreateDocumentFragmentNode Returns Handle
12846>>>>>        Handle hoNew
12846>>>>>        Handle hoDocumentObject
12846>>>>>        Handle infcNew
12846>>>>>        Integer iClassID
12846>>>>>        Get DocumentObject to hoDocumentObject
12847>>>>>        // Create an Comment in the document and assign its interface to the new DF object.
12847>>>>>        Get createDocumentFragment of hoDocumentObject to infcNew
12848>>>>>        If infcNew Begin // if there was an error, no infc handle would be returned
12850>>>>>            Get NodeClassId of hoDocumentObject NODE_DOCUMENT_FRAGMENT to iClassId
12851>>>>>            Get CreateXMLObject iClassId infcNew to hoNew
12852>>>>>        End
12852>>>>>>
12852>>>>>        Function_Return hoNew
12853>>>>>    End_Function
12854>>>>>    
12854>>>>>    //  Create a Node of any passed Type (e.g. Node_element). Normally you don't need this as there are
12854>>>>>    //  specific messages to do this for each node type. Node that this lets you pass namespaces as a separate
12854>>>>>    //  parameter. With all of the other messages (e.g. createElementNode) you pass namespaces as prefixed to
12854>>>>>    // the tagname (e.g. Get CreateElementNode "MyNameSpace:MyTag" "MyValue" to hoEle)
12854>>>>>    
12854>>>>>    Function CreateChildNode Integer iNodeType String sTagName String sNameSpace Returns Handle
12856>>>>>        Handle hoNewNode hoDocumentObject
12856>>>>>        Handle infcNewNode
12856>>>>>        Integer iClassid iType
12856>>>>>        Get DocumentObject to hoDocumentObject
12857>>>>>        Get NodeClassId iNodeType to iClassId
12858>>>>>        If (iClassId<>0) Begin
12860>>>>>            // Create a node in the document and assign its interface to the new DF object.
12860>>>>>            Get createNode of hoDocumentObject iNodeType sTagName sNameSpace to infcNewNode
12861>>>>>            // this is required to force the interface type to be correct.
12861>>>>>            Move (invokexml(DF_IXMLDOMNODE, GET_piNodeType, infcNewNode, 0, 0, 0, 0)) to iType
12862>>>>>            Move (invokexml(DF_IXMLDOMNODE, GET_ChangeNodeType, infcNewNode, iType, 1, 0, 0)) to infcNewNode
12863>>>>>            
12863>>>>>            If infcNewNode ;                Get CreateXMLObject iClassId infcNewNode to hoNewNode
12866>>>>>        End
12866>>>>>>
12866>>>>>        Function_Return hoNewNode
12867>>>>>    End_Function
12868>>>>>    
12868>>>>>    
12868>>>>>    
12868>>>>>    // The Addxxxxx messages create a new node and appends it to the list. When used as a function,
12868>>>>>    // the object handle is returned and must be disposed of later by the programmer.
12868>>>>>    // When used as a procedure, the object is destroyed--it just does it and is done.
12868>>>>>    
12868>>>>>    Function AddElement String sTagName String sValue Returns Handle
12870>>>>>        Handle hoNewElement
12870>>>>>        Get CreateElementNode sTagName sValue to hoNewElement
12871>>>>>        If hoNewElement ;            Get AppendNode hoNewElement to hoNewElement
12874>>>>>        Function_Return hoNewElement
12875>>>>>    End_Function
12876>>>>>    
12876>>>>>    Procedure AddElement String sTagName String sValue
12878>>>>>        Handle hoNewElement
12878>>>>>        Get AddElement sTagName sValue to hoNewElement
12879>>>>>        If hoNewElement ;            Send Destroy to hoNewElement
12882>>>>>        Else ;            Error DFERR_XML_INTERNAL_ERROR (SFormat(C_$XmlMethodFailure, "msg_AddElement"))
12884>>>>>    End_Procedure
12885>>>>>    
12885>>>>>    // this returns the object, This is often needed
12885>>>>>    Function CreateElementNodeNS String sNameSpace String sTagName String sValue Returns Handle
12887>>>>>        Handle hoNewElement
12887>>>>>        Get CreateChildNode NODE_ELEMENT sTagName sNameSpace to hoNewElement
12888>>>>>        If (hoNewElement and sValue<>"") ;            Set psText of hoNewElement to sValue
12891>>>>>        Function_Return hoNewElement
12892>>>>>    End_Function
12893>>>>>    
12893>>>>>    
12893>>>>>    // this returns the object, This is often needed
12893>>>>>    Function AddElementNS String sNameSpace String sTagName String sValue Returns Handle
12895>>>>>        Handle hoNewElement
12895>>>>>        Get CreateElementNodeNS sNameSpace sTagName sValue to hoNewElement
12896>>>>>        If hoNewElement Begin
12898>>>>>            Get AppendNode hoNewElement to hoNewElement
12899>>>>>        End
12899>>>>>>
12899>>>>>        Function_Return hoNewElement
12900>>>>>    End_Function
12901>>>>>    
12901>>>>>    Procedure AddElementNS String sNameSpace String sTagName String sValue
12903>>>>>        Handle hoNewElement
12903>>>>>        Get AddElementNS sNameSpace sTagName sValue to hoNewElement
12904>>>>>        If hoNewElement ;            Send Destroy to hoNewElement
12907>>>>>        Else ;            Error DFERR_XML_INTERNAL_ERROR (SFormat(C_$XmlMethodFailure, "msg_AddElementNS"))
12909>>>>>    End_Procedure
12910>>>>>    
12910>>>>>    Function AddAttributeNode Handle hoNode Returns Handle
12912>>>>>        Handle hInfc
12912>>>>>        Get Set_AttributeNode (XmlInterface(hoNode)) to hInfc
12913>>>>>        If hInfc ; // if ret value we have a replacement            Set XmlInterface of hoNode to hInfc
12916>>>>>        Function_Return hoNode
12917>>>>>    End_Function
12918>>>>>    
12918>>>>>    Function AttributeValueNode String sName Returns Handle
12920>>>>>        Handle hInfc
12920>>>>>        Handle hoNode
12920>>>>>        Get AttributeNode sName to hInfc
12921>>>>>        If hInfc ; // if ret value we have a replacement            Get CreateXMLNode hInfc to hoNode
12924>>>>>        Function_Return hoNode
12925>>>>>    End_Function
12926>>>>>    
12926>>>>>    Function AttributeValueNodeNS String sNameSpace String sBaseName Returns Handle
12928>>>>>        Handle hoAttrs hoAttr
12928>>>>>        String sValue
12928>>>>>        Get TempAttributeNodes to hoAttrs
12929>>>>>        If hoAttrs Begin
12931>>>>>            Get QualifiedNode of hoAttrs sNamespace sBaseName to hoAttr
12932>>>>>            Set XMLInterface of hoAttrs to 0
12933>>>>>        End
12933>>>>>>
12933>>>>>        Function_Return hoAttr
12934>>>>>    End_Function
12935>>>>>    
12935>>>>>    
12935>>>>>    Function CreateAttributeNodeNS String sNameSpace String sName String sValue Returns Handle
12937>>>>>        Handle hoNewAttribute
12937>>>>>        Get CreateChildNode NODE_ATTRIBUTE sName sNameSpace to hoNewAttribute
12938>>>>>        If hoNewAttribute ;            Set psText of hoNewAttribute to sValue
12941>>>>>        Function_Return hoNewAttribute
12942>>>>>    End_Function
12943>>>>>    
12943>>>>>    Procedure AddAttributeNS String sNameSpace String sName String sValue
12945>>>>>        Handle hoNode
12945>>>>>        Get CreateAttributeNodeNS sNameSpace sName sValue to hoNode
12946>>>>>        If hoNode Begin
12948>>>>>            Get AddAttributeNode hoNode to hoNode
12949>>>>>            If hoNode ;                Send Destroy of hoNode
12952>>>>>        End
12952>>>>>>
12952>>>>>        Else ;            Error DFERR_XML_INTERNAL_ERROR (SFormat(C_$XmlMethodFailure, "msg_AddAttributeNS"))
12954>>>>>    End_Procedure
12955>>>>>    
12955>>>>>    
12955>>>>>    // This function encapsulates creation and addition of attributes to a node.
12955>>>>>    // should only work with element class
12955>>>>>    Procedure AddAttribute String sName String sValue
12957>>>>>        Set AttributeValue sName to sValue
12958>>>>>    End_Procedure
12959>>>>>    
12959>>>>>    // This function encapsulates creation and addition of comments to a node.
12959>>>>>    // The return value is a Boolean that is currently unused.
12959>>>>>    
12959>>>>>    Procedure AddChildComment String sValue
12961>>>>>        Handle hoNewNode
12961>>>>>        Get createChildComment sValue to hoNewNode
12962>>>>>        If not hoNewNode ;            Error DFERR_XML_INTERNAL_ERROR (SFormat(C_$XmlMethodFailure, "msg_AddChildComment"))
12965>>>>>        Else Begin
12966>>>>>            Get AppendNode hoNewNode to hoNewNode
12967>>>>>            Send Destroy to hoNewNode
12968>>>>>        End
12968>>>>>>
12968>>>>>    End_Procedure
12969>>>>>    
12969>>>>>    // This function encapsulates creation and addition of processing instructions to a node.
12969>>>>>    // The return value is a Boolean that is currently unused.
12969>>>>>    
12969>>>>>    Procedure AddChildProcessingInstruction String sTarget String sValue
12971>>>>>        Handle hoNewNode
12971>>>>>        Get createChildProcessingInstruction sTarget sValue to hoNewNode
12972>>>>>        If not hoNewNode ;            Error DFERR_XML_INTERNAL_ERROR (SFormat(C_$XmlMethodFailure, "msg_AddChildProcessingInstruction"))
12975>>>>>        Else Begin
12976>>>>>            Get AppendNode hoNewNode to hoNewNode
12977>>>>>            Send Destroy to hoNewNode
12978>>>>>        End
12978>>>>>>
12978>>>>>    End_Procedure
12979>>>>>    
12979>>>>>    
12979>>>>>    // This function encapsulates creation and addition of text nodes to a node.
12979>>>>>    // The return value is a Boolean that is currently unused.
12979>>>>>    
12979>>>>>    Procedure AddChildTextNode String sValue
12981>>>>>        Handle hoNewNode
12981>>>>>        Get createChildTextNode sValue to hoNewNode
12982>>>>>        If not hoNewNode ;            Error DFERR_XML_INTERNAL_ERROR (SFormat(C_$XmlMethodFailure, "msg_AddChildTextNode"))
12985>>>>>        Else Begin
12986>>>>>            Get AppendNode hoNewNode to hoNewNode
12987>>>>>            Send Destroy to hoNewNode
12988>>>>>        End
12988>>>>>>
12988>>>>>    End_Procedure
12989>>>>>    
12989>>>>>    // This procedure encapsulates creation and addition of cdata text nodes to a node.
12989>>>>>    Procedure AddCDataSection String sValue
12991>>>>>        Handle hoNewNode
12991>>>>>        Get CreateCDATASectionNode sValue to hoNewNode
12992>>>>>        If not hoNewNode ;            Error DFERR_XML_INTERNAL_ERROR (SFormat(C_$XmlMethodFailure, "msg_AddCDataSection"))
12995>>>>>        Else Begin
12996>>>>>            Get AppendNode hoNewNode to hoNewNode
12997>>>>>            Send Destroy to hoNewNode
12998>>>>>        End
12998>>>>>>
12998>>>>>    End_Procedure
12999>>>>>    
12999>>>>>    
12999>>>>>    Function AddChildNode Integer iNodeType String sTagName String sNameSpace Returns Handle
13001>>>>>        Handle hoNewNode
13001>>>>>        Handle hoDocumentObject
13001>>>>>        Get DocumentObject to hoDocumentObject
13002>>>>>        Get createChildNode of hoDocumentObject iNodeType sTagName sNamespace to hoNewNode
13003>>>>>        If hoNewNode ;            Get AppendNode hoNewNode to hoNewNode
13006>>>>>        Function_Return hoNewNode
13007>>>>>    End_Function
13008>>>>>    
13008>>>>>    // don't use the runtime/msxml version of this. Instead just return the
13008>>>>>    // first text from the first child node. This is much faster
13008>>>>>    Function psText Returns String
13010>>>>>        Handle hText
13010>>>>>        String sValue
13010>>>>>        Get phFirstChild to hText
13011>>>>>        Get InfcNodeValue hText to sValue
13012>>>>>        Function_Return sValue
13013>>>>>    End_Function
13014>>>>>    
13014>>>>>    // Use this to call the internal Text property. This returns all text for all child
13014>>>>>    // node. You rarely would want to do this. The is uses the msxml psText which can
13014>>>>>    // get slow with very large files. If for some reason you need all of the child node's
13014>>>>>    // text and the file is large, you might want to consider doing this process manually.
13014>>>>>    Function AllChildNodesText Returns String
13016>>>>>        String sValue
13016>>>>>        Forward Get psText to sValue
13018>>>>>        Function_Return sValue
13019>>>>>    End_Function
13020>>>>>    
13020>>>>>    // return the interface NodeValue without having to create a
13020>>>>>    // new object. This also disposes the hInfc interface
13020>>>>>    Function InfcNodeValue Handle hInfc Returns String
13022>>>>>        Handle hoDocument hoTempNode
13022>>>>>        String sValue
13022>>>>>        If (hinfc) Begin
13024>>>>>            Get DocumentObject to hoDocument
13025>>>>>            Get phoTempDomNode of hoDocument to hoTempNode
13026>>>>>            Set XMLInterface of hoTempNode to hInfc
13027>>>>>            Get psNodeValue of hoTempNode to sValue
13028>>>>>            // This disposes of hInfc which was passed in. After
13028>>>>>            // calling this you can no longer use it (which is good).
13028>>>>>            Set XMLInterface of hoTempNode to 0
13029>>>>>        End
13029>>>>>>
13029>>>>>        Function_Return sValue
13030>>>>>    End_Function
13031>>>>>    
13031>>>>>    // ChildNodeValue is used to get the "value" of an element. This is useful when the element
13031>>>>>    // only has a single value (similar to an attribute).
13031>>>>>    
13031>>>>>    Function ChildNodeValue String sTagName Returns String
13033>>>>>        Handle hoTempNode hoDocument
13033>>>>>        Handle hinfcTempNode
13033>>>>>        String sRetVal
13033>>>>>        Get SelectSingleNode sTagName to hinfcTempNode
13034>>>>>        If (hinfcTempNode <> 0) Begin
13036>>>>>            Get DocumentObject to hoDocument
13037>>>>>            Get phoTempDomNode of hoDocument to hoTempNode
13038>>>>>            Set XMLInterface of hoTempNode to hinfcTempNode
13039>>>>>            Get phFirstChild of hoTempNode to hinfcTempNode
13040>>>>>            Set XMLInterface of hoTempNode to 0
13041>>>>>            If hinfcTempNode Begin
13043>>>>>                Get InfcNodeValue hinfcTempNode to sRetVal
13044>>>>>            End
13044>>>>>>
13044>>>>>        End
13044>>>>>>
13044>>>>>        Function_Return sRetVal
13045>>>>>    End_Function
13046>>>>>    
13046>>>>>    // This simple function allows a parent to change the text of one of its elements.
13046>>>>>    // This actually occurs quite a bit, because (as stated above) lowest level
13046>>>>>    // elements are frequently used as properties.
13046>>>>>    //
13046>>>>>    Procedure SetChildNodeValue String sTagName String sValue
13048>>>>>        Handle hoTempNode
13048>>>>>        Handle hinfcTempNode
13048>>>>>        // Search for the node that matches.
13048>>>>>        Get SelectSingleNode sTagName to hinfcTempNode
13049>>>>>        // If no match is found, add a new element with the tag.
13049>>>>>        If (hinfcTempNode = 0) ;            Send AddElement sTagName sValue
13052>>>>>        Else Begin
13053>>>>>            Get CreateXMLObject U_BaseXMLDOMNode hinfcTempNode to hoTempNode
13054>>>>>            If hoTempNode Begin
13056>>>>>                // Set the text of the element.
13056>>>>>                Set psText of hoTempNode to sValue
13057>>>>>                Send Destroy to hoTempNode
13058>>>>>            End
13058>>>>>>
13058>>>>>            Else ;                Error DFERR_XML_INTERNAL_ERROR (SFormat(C_$XmlMethodFailure, "msg_SetChildNodeValue"))
13060>>>>>        End
13060>>>>>>
13060>>>>>    End_Procedure
13061>>>>>    
13061>>>>>    // These messages are used to allow you to travese through a nodes.
13061>>>>>    
13061>>>>>    Function FirstChild Returns Handle
13063>>>>>        Handle hoChild
13063>>>>>        Handle hinfcChild
13063>>>>>        Get phFirstChild  to hinfcChild
13064>>>>>        If (hinfcChild) ;            Get CreateXMLNode hinfcChild to hoChild
13067>>>>>        Function_Return hoChild
13068>>>>>    End_Function
13069>>>>>    
13069>>>>>    Function NextSibling Returns Handle
13071>>>>>        Handle hoChild
13071>>>>>        Handle hinfcChild
13071>>>>>        Get phNextSibling  to hinfcChild
13072>>>>>        If (hinfcChild) ;            Get CreateXMLNode hinfcChild to hoChild
13075>>>>>        Function_Return hoChild
13076>>>>>    End_Function
13077>>>>>    
13077>>>>>    Function PreviousSibling Returns Handle
13079>>>>>        Handle hoChild
13079>>>>>        Handle hinfcChild
13079>>>>>        Get phPreviousSibling  to hinfcChild
13080>>>>>        If (hinfcChild) ;            Get CreateXMLNode hinfcChild to hoChild
13083>>>>>        Function_Return hoChild
13084>>>>>    End_Function
13085>>>>>    
13085>>>>>    Function LastChild Returns Handle
13087>>>>>        Handle hoChild
13087>>>>>        Handle hinfcChild
13087>>>>>        Get phLastChild  to hinfcChild
13088>>>>>        If (hinfcChild) ;            Get CreateXMLNode hinfcChild to hoChild
13091>>>>>        Function_Return hoChild
13092>>>>>    End_Function
13093>>>>>    
13093>>>>>    // return an object that is the parent of the current node
13093>>>>>    Function ParentNode Returns Handle
13095>>>>>        Handle hoId
13095>>>>>        Handle hinfcXMLInterface
13095>>>>>        Get phParentNode to hinfcXMLInterface
13096>>>>>        If (hinfcXMLInterface) ;            Get CreateXmlNode hinfcXMLInterface to hoID
13099>>>>>        Function_Return hoID
13100>>>>>    End_Function
13101>>>>>    
13101>>>>>    // Same as NextSibling except it uses or destroys the current node
13101>>>>>    //
13101>>>>>    // optimized version does not destroy/create object unless it needs to.
13101>>>>>    // if the next node is the same node type we will resuse this object
13101>>>>>    // else this object is destroyed
13101>>>>>    Function NextNode Returns Handle
13103>>>>>        Handle hoNode hoDocument
13103>>>>>        Handle hInfc
13103>>>>>        Get phNextSibling to hInfc
13104>>>>>        If hInfc Begin
13106>>>>>            Get DocumentObject to hoDocument
13107>>>>>            Move Self to hoNode
13108>>>>>            Send BindXMLInfc of hoDocument hInfc (&hoNode)
13109>>>>>        End
13109>>>>>>
13109>>>>>        Else Begin
13110>>>>>            Send Destroy
13111>>>>>            Move 0 to hoNode
13112>>>>>        End
13112>>>>>>
13112>>>>>        Function_Return hoNode
13113>>>>>    End_Function
13114>>>>>    
13114>>>>>    
13114>>>>>    // Enumerate through all nodes.
13114>>>>>    
13114>>>>>    Procedure EnumerateNodes Integer iMsg Handle hoReceiver String sVal1 String sVal2
13116>>>>>        Integer i iLen
13116>>>>>        Handle hoNode
13116>>>>>        Handle hoNodeCollection
13116>>>>>        Get ChildNodes to hoNodeCollection
13117>>>>>        If (hoNodeCollection <> 0) Begin
13119>>>>>            Get NodeListLength of hoNodeCollection to iLen
13120>>>>>            Decrement iLen
13121>>>>>            For i from 0 to iLen
13127>>>>>>
13127>>>>>                // For each record, process its fields.
13127>>>>>                Get CollectionNode of hoNodeCollection i to hoNode
13128>>>>>                Send iMsg of hoReceiver hoNode sVal1 sVal2
13129>>>>>                Send Destroy of hoNode
13130>>>>>            Loop
13131>>>>>>
13131>>>>>            Send Destroy of hoNodeCollection
13132>>>>>        End
13132>>>>>>
13132>>>>>    End_Procedure
13133>>>>>    
13133>>>>>    // Enumerate through all elements.
13133>>>>>    
13133>>>>>    Procedure EnumerateElements Integer iMsg Handle hoReceiver String sVal1 String sVal2
13135>>>>>        Integer i iLen
13135>>>>>        Handle hoNode
13135>>>>>        Handle hoNodeCollection
13135>>>>>        Get ChildNodes to hoNodeCollection
13136>>>>>        If (hoNodeCollection <> 0) Begin
13138>>>>>            Get NodeListLength of hoNodeCollection to iLen
13139>>>>>            Decrement iLen
13140>>>>>            For i from 0 to iLen
13146>>>>>>
13146>>>>>                // For each record, process its fields.
13146>>>>>                Get CollectionNode of hoNodeCollection i to hoNode
13147>>>>>                If (piNodeType(hoNode)=NODE_ELEMENT) ;                    Send iMsg of hoReceiver hoNode sVal1 sVal2
13150>>>>>                Send Destroy of hoNode
13151>>>>>            Loop
13152>>>>>>
13152>>>>>            Send Destroy of hoNodeCollection
13153>>>>>        End
13153>>>>>>
13153>>>>>    End_Procedure
13154>>>>>    
13154>>>>>    
13154>>>>>    // enumerate through all attributes. There is no recurse here because attributes will not
13154>>>>>    // contain attributes.
13154>>>>>    
13154>>>>>    Procedure EnumerateAttributes Integer iMsg Handle hoReceiver String sSomeValue
13156>>>>>        Integer i iLen
13156>>>>>        Handle hoNode
13156>>>>>        Handle hoNodeMapCollection
13156>>>>>        // we don't use tempattributenodes because we don't know what the enum message will do.
13156>>>>>        Get AttributeNodes to hoNodeMapCollection
13157>>>>>        If (hoNodeMapCollection <> 0) Begin
13159>>>>>            Get NodeListLength of hoNodeMapCollection to iLen
13160>>>>>            Decrement iLen
13161>>>>>            For i from 0 to iLen
13167>>>>>>
13167>>>>>                // For each record, process its fields.
13167>>>>>                Get CollectionNode of hoNodeMapCollection i to hoNode
13168>>>>>                Send iMsg of hoReceiver hoNode sSomeValue
13169>>>>>                Send Destroy of hoNode
13170>>>>>            Loop
13171>>>>>>
13171>>>>>            Send Destroy of hoNodeMapCollection
13172>>>>>        End
13172>>>>>>
13172>>>>>    End_Procedure
13173>>>>>    
13173>>>>>    
13173>>>>>    Function XSLTransformation Handle hoXSLDocument Returns String
13175>>>>>        Handle infcXSLStartAt
13175>>>>>        String sBuffer
13175>>>>>        // Transformation is of current object using passed XSLDocument.
13175>>>>>        Get XMLInterface of hoXSLDocument to infcXSLStartAt
13176>>>>>        Get TransformNode infcXSLStartAt to sBuffer
13177>>>>>        Function_Return sBuffer
13178>>>>>    End_Function
13179>>>>>    
13179>>>>>    // This allows for transformations not limited to the size of the string buffer
13179>>>>>    //
13179>>>>>    // Note that it is up to the programmer to dispose of the memory allocated at pBuffer
13179>>>>>    // by using the free(pBuffer) function
13179>>>>>    //
13179>>>>>    Function XSLTransformationToAddress Handle hoXSLDocument Returns Pointer
13181>>>>>        Handle infcXSLStartAt
13181>>>>>        Pointer pBuffer
13181>>>>>        // Transformation is of current object using passed XSLDocument.
13181>>>>>        Get XMLInterface of hoXSLDocument to infcXSLStartAt
13182>>>>>        Get TransformNodeToAddress infcXSLStartAt to pBuffer
13183>>>>>        Function_Return pBuffer
13184>>>>>    End_Function
13185>>>>>    
13185>>>>>    
13185>>>>>    // extract base name from string. e.g.: ns:name --> name
13185>>>>>    //
13185>>>>>    Function BaseNameFromQName String sName Returns String
13187>>>>>        Integer iPos
13187>>>>>        Move (Pos(":",sName)) to iPos
13188>>>>>        If iPos Begin
13190>>>>>            Move (remove(sName,1,iPos)) to sName
13191>>>>>        End
13191>>>>>>
13191>>>>>        Function_Return sName
13192>>>>>    End_Function
13193>>>>>    
13193>>>>>    // extract prefix name from string. e.g.: ns:name --> ns
13193>>>>>    //
13193>>>>>    Function PrefixNameFromQName String sName Returns String
13195>>>>>        String sPreFix
13195>>>>>        Integer iPos
13195>>>>>        Move (Pos(":",sName)) to iPos
13196>>>>>        If iPos Begin
13198>>>>>            Move (Left(sName,iPos-1)) to sPreFix
13199>>>>>        End
13199>>>>>>
13199>>>>>        Function_Return sPreFix
13200>>>>>    End_Function
13201>>>>>    
13201>>>>>    
13201>>>>>    // Returns true if node is element and namespace and base name match
13201>>>>>    //
13201>>>>>    Function IsElementNS String sNamespaceURI String sBaseName Returns Boolean
13203>>>>>        Function_Return (piNodeType(Self)=NODE_ELEMENT and ;            psNameSpaceURI(Self)=sNamespaceURI and ;            psBaseName(Self)=sBaseName )
13204>>>>>    End_Function
13205>>>>>    
13205>>>>>    // Returns node of first occurence of child node matching namespace and base name
13205>>>>>    //
13205>>>>>    Function ChildElementNS String sNameSpaceURI String sBaseName Returns Handle
13207>>>>>        Handle hoNode
13207>>>>>        Get FirstChild to hoNode
13208>>>>>        While (hoNode and not(IsElementNS(hoNode, sNameSpaceURI, sBaseName)))
13212>>>>>            Get NextNode of hoNode to hoNode
13213>>>>>        Loop
13214>>>>>>
13214>>>>>        Function_Return hoNode
13215>>>>>    End_Function
13216>>>>>    
13216>>>>>    Function NextElementNS String sNameSpaceURI String sBaseName Returns Handle
13218>>>>>        Handle hoNode
13218>>>>>        // NextNode may return the same object or it may destroy the object and
13218>>>>>        // return nothing or a different object
13218>>>>>        Get NextNode to hoNode
13219>>>>>        While (hoNode and not(IsElementNS(hoNode, sNameSpaceURI, sBaseName)))
13223>>>>>            // use of hoNode is required. This can be different than self
13223>>>>>            Get NextNode of hoNode to hoNode
13224>>>>>        Loop
13225>>>>>>
13225>>>>>        
13225>>>>>        Function_Return hoNode
13226>>>>>    End_Function
13227>>>>>    
13227>>>>>    
13227>>>>>    // Returns value (string) first occurence of child node matching namespace and base name
13227>>>>>    //
13227>>>>>    Function ChildElementValueNS String sNameSpaceURI String sBaseName Returns String
13229>>>>>        Handle hoNext
13229>>>>>        String sText
13229>>>>>        Get ChildElementNS sNameSpaceURI sBaseName to hoNext
13230>>>>>        If hoNext Begin
13232>>>>>            Get psText of hoNext to sText
13233>>>>>            Send destroy of hoNext
13234>>>>>        End
13234>>>>>>
13234>>>>>        Function_Return sText
13235>>>>>    End_Function
13236>>>>>    
13236>>>>>    Procedure SetChildElementValueNS String sNameSpaceURI String sBaseName String sValue
13238>>>>>        Handle hoNode
13238>>>>>        Handle hinfcTempNode
13238>>>>>        Get ChildElementNS sNameSpaceURI sBaseName to hoNode
13239>>>>>        If (hoNode=0) Begin
13241>>>>>            Send AddElementNS sNameSpaceURI sBaseName sValue
13242>>>>>        End
13242>>>>>>
13242>>>>>        Else Begin
13243>>>>>            Set psText of hoNode to sValue
13244>>>>>            Send destroy of hoNode
13245>>>>>        End
13245>>>>>>
13245>>>>>    End_Procedure
13246>>>>>    
13246>>>>>    // pass a prefix and try to finds its NameSpaceURI. Start at current node and work up to parent.
13246>>>>>    // This can be useful when a qualified name is found in an attribute value
13246>>>>>    //
13246>>>>>    Function PrefixToNamespaceURI String sPrefix Returns String
13248>>>>>        Handle hoNode
13248>>>>>        Integer i iNodes
13248>>>>>        Handle hoNodes hoParentNode hoAttNode
13248>>>>>        Boolean bDone bParent
13248>>>>>        String sAttPrefix sName sNameSpace
13248>>>>>        
13248>>>>>        Move Self to hoNode
13249>>>>>        While not bDone
13253>>>>>            Get TempAttributeNodes of hoNode to hoNodes
13254>>>>>            If (hoNodes <> 0) Begin
13256>>>>>                Get NodeListLength of hoNodes to iNodes
13257>>>>>                For i from 0 to (iNodes-1)
13263>>>>>>
13263>>>>>                    // For each record, process its fields.
13263>>>>>                    Get CollectionNode of hoNodes i to hoAttNode
13264>>>>>                    Get psPrefix of hoAttNode to sAttPrefix
13265>>>>>                    Get psBaseName of hoAttNode to sName
13266>>>>>                    // with legacy msxml, xmlns="foo" returns psPrefix="xmlns" and pbBaseName=""
13266>>>>>                    // with newer msxml, xmlns="foo" returns psPrefix="" and pbBaseName="xmlns"
13266>>>>>                    // We handle both cases here.
13266>>>>>                    
13266>>>>>                    If ( (sAttPrefix="xmlns" and sName=sPrefix) or ; // if a normal xmlns:xx="foo" match (sPrefix="xx") or a legacy xmlns="foo" match (sPrefix="")                        (sPrefix="" and sAttPrefix="" and sName="xmlns") ) Begin // special test for newer msxml xmlns="foo" match (sPrefix="")
13268>>>>>                        
13268>>>>>                        Get Value of hoAttNode to sNameSpace
13269>>>>>                        Move True to bDone
13270>>>>>                        Move (iNodes-1) to i
13271>>>>>                        
13271>>>>>                    End
13271>>>>>>
13271>>>>>                    
13271>>>>>                    Send Destroy of hoAttNode
13272>>>>>                Loop
13273>>>>>>
13273>>>>>                Set XMLInterface of hoNodes to 0
13274>>>>>            End
13274>>>>>>
13274>>>>>            
13274>>>>>            Get ParentNode of hoNode to hoParentNode
13275>>>>>            If bParent ;                Send destroy of hoNode
13278>>>>>            If not bDone Begin
13280>>>>>                If not hoParentNode ;                    Move True to bDone
13283>>>>>                Else Begin
13284>>>>>                    Move True to bParent
13285>>>>>                    Move hoParentNode to hoNode
13286>>>>>                End
13286>>>>>>
13286>>>>>            End
13286>>>>>>
13286>>>>>        Loop
13287>>>>>>
13287>>>>>        Function_Return sNameSpace
13288>>>>>    End_Function
13289>>>>>    
13289>>>>>    
13289>>>>>    
13289>>>>>End_Class
13290>>>>>
13290>>>>>// Set up basic inheritance for specialized forms of XML classes.
13290>>>>>// This needs to be done so we can make objects of these types.
13290>>>>>
13290>>>>>Class cXMLDOMElement is a BaseXmlDomElement
13291>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
13292>>>>>    
13292>>>>>    // Should use AddAttributeValue...does same thing
13292>>>>>    Procedure SetAttributeValue String sName String sValue
13294>>>>>        Send AddAttribute sName sValue
13295>>>>>    End_Procedure
13296>>>>>    
13296>>>>>    // Note: Get_AttributeValue already there
13296>>>>>    
13296>>>>>    Procedure RemoveAttribute String sName
13298>>>>>        Integer iVal
13298>>>>>        Get RemoveAttribute sName to iVal
13299>>>>>    End_Procedure
13300>>>>>    
13300>>>>>    Function AttributeValueNS String sNameSpace String sBaseName Returns String
13302>>>>>        String sValue
13302>>>>>        Handle hinfcItem
13302>>>>>        Handle hoDoc hoTempAttributeNodes hoNode
13302>>>>>        Integer hinfcAttributes
13302>>>>>        
13302>>>>>        Get TempAttributeNodes to hoTempAttributeNodes
13303>>>>>        Get QualifiedItem of hoTempAttributeNodes sBaseName sNameSpace  to hinfcItem
13304>>>>>        Set XMLInterface of hoTempAttributeNodes to 0
13305>>>>>        If hinfcItem Begin
13307>>>>>            Get DocumentObject to hoDoc
13308>>>>>            Get phoTempDomNode of hoDoc to hoNode
13309>>>>>            Set XMLInterface of hoNode to hinfcItem
13310>>>>>            Get psNodeValue of hoNode to sValue
13311>>>>>            Set XMLInterface of hoNode to 0
13312>>>>>        End
13312>>>>>>
13312>>>>>        Function_Return sValue
13313>>>>>    End_Function
13314>>>>>    
13314>>>>>    Procedure RemoveAttributeNS String sNameSpace String sBaseName
13316>>>>>        Handle hoAttrs hoAttr
13316>>>>>        String sValue
13316>>>>>        Get TempAttributeNodes to hoAttrs
13317>>>>>        If hoAttrs Begin
13319>>>>>            Get RemoveQualifiedNode of hoAttrs sNamespace sBaseName to hoAttr
13320>>>>>            Set XMLInterface of hoAttrs to 0
13321>>>>>            If hoAttr ;                Send destroy of hoAttr
13324>>>>>        End
13324>>>>>>
13324>>>>>    End_Procedure
13325>>>>>    
13325>>>>>End_Class
13326>>>>>
13326>>>>>Class cXMLDOMNode is a BaseXmlDomNode
13327>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
13328>>>>>End_Class
13329>>>>>
13329>>>>>Class cXMLDOMAttribute is a BaseXmlDomAttribute
13330>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
13331>>>>>End_Class
13332>>>>>
13332>>>>>Class cXMLDOMComment is a BaseXmlDomComment
13333>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
13334>>>>>End_Class
13335>>>>>
13335>>>>>Class cXMLDOMProcessingInstruction is a BaseXmlDomProcessingInstruction
13336>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
13337>>>>>End_Class
13338>>>>>
13338>>>>>Class cXMLDOMTextNode is a BaseXmlDomTextNode
13339>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
13340>>>>>End_Class
13341>>>>>
13341>>>>>Class cXMLDOMCDATASection is a BaseXmlDomCDATASection
13342>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
13343>>>>>End_Class
13344>>>>>
13344>>>>>Class cXMLDOMDocumentType is a BaseXmlDomDocumentType
13345>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
13346>>>>>    
13346>>>>>End_Class
13347>>>>>
13347>>>>>Class cXMLDOMNotation is a BaseXmlDomNotation
13348>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
13349>>>>>End_Class
13350>>>>>
13350>>>>>Class cXMLDOMEntity is a BaseXmlDomEntity
13351>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
13352>>>>>End_Class
13353>>>>>
13353>>>>>Class cXMLDOMEntityReference is a BaseXmlDomEntityReference
13354>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
13355>>>>>End_Class
13356>>>>>
13356>>>>>Class cXMLDOMDocumentFragment is a BaseXmlDomDocumentFragment
13357>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
13358>>>>>End_Class
13359>>>>>
13359>>>>>
13359>>>>>Class cXMLDOMParseError is a BaseXMLDomParseError
13360>>>>>    // returns an error sub-object as a sibling of this error object
13360>>>>>    Function ErrorItemNode Integer iItem Returns Handle
13362>>>>>        Handle hoParseErrorNode hoParent
13362>>>>>        Handle hParseErrorIntf
13362>>>>>        Get ErrorItem iItem to hParseErrorIntf
13363>>>>>        If (hParseErrorIntf) Begin
13365>>>>>            // add to parent in case developer destroys the current object
13365>>>>>            Get Parent to hoParent
13366>>>>>            Get Create of hoParent U_cXMLDOMParseError to hoParseErrorNode
13367>>>>>            Set XmlInterface of hoParseErrorNode to hParseErrorIntf
13368>>>>>        End
13368>>>>>>
13368>>>>>        Function_Return hoParseErrorNode
13369>>>>>    End_Function
13370>>>>>End_Class
13371>>>>>
13371>>>>>// Base document class with Base functions.
13371>>>>>
13371>>>>>Class cXMLDOMDocument is an BaseXmlDomDocument
13372>>>>>    
13372>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
13373>>>>>    
13373>>>>>    Procedure Construct_Object
13375>>>>>        Handle hInfc
13375>>>>>        Forward Send Construct_Object
13377>>>>>        Property String psDocumentName ""
13378>>>>>        Property Integer phPrivateDocumentElement 0
13379>>>>>        Property Handle phoTempDomNode (Create(Self,U_cXMLDomNode))
13380>>>>>        Property Handle phoTempDomNodeMap (Create(Self,U_cXMLDOMNamedNodeMap))
13381>>>>>        
13381>>>>>        // added in 15.1. If no COM pointer, msxml6 is most likely not installed. This will
13381>>>>>        // raise an unhandled error, which could be augmented to do something else.
13381>>>>>        Get XmlInterface to hInfc
13382>>>>>        If (hInfc=0) Begin
13384>>>>>            Send ErrorCreatingXMLObject
13385>>>>>        End
13385>>>>>>
13385>>>>>        
13385>>>>>        // as of 18.0 pbAsync now defaults to False. In most cases, this is what you want
13385>>>>>        Set pbAsync to False
13386>>>>>    End_Procedure
13387>>>>>    
13387>>>>>    // returns the classId for the passed NodeType. This is a good augmentation point. All nodes
13387>>>>>    // within an xml document come here to get a class. So, if you want to augment and return a
13387>>>>>    // different class, just check the node type and return whatever -- else forward
13387>>>>>    
13387>>>>>    Function NodeClassId Integer iType Returns Integer
13389>>>>>        Integer iClassId
13389>>>>>        Case Begin
13389>>>>>            Case (iType=NODE_ELEMENT) ;                Move U_cXMLDOMElement      to iClassId
13392>>>>>            Case (iType=NODE_ATTRIBUTE) ;                Move U_cXMLDOMAttribute    to iClassId
13396>>>>>            Case (iType=NODE_TEXT) ;                Move U_cXMLDOMTextNode     to iClassId
13400>>>>>            Case (iType=NODE_CDATA_SECTION) ;                Move U_cXMLDOMCDATASection to iClassId
13404>>>>>            Case (iType=NODE_ENTITY_REFERENCE) ;                Move U_cXMLDOMEntityReference to iClassId
13408>>>>>            Case (iType=NODE_ENTITY) ;                Move U_cXMLDOMEntity       to iClassId
13412>>>>>            Case (iType=NODE_PROCESSING_INSTRUCTION) ;                Move U_cXMLDOMProcessingInstruction to iClassId
13416>>>>>            Case (iType=NODE_COMMENT) ;                Move U_cXMLDOMComment      to iClassId
13420>>>>>            Case (iType=NODE_DOCUMENT) ;                Move U_cXMLDOMDocument     to iClassId
13424>>>>>            Case (iType=NODE_DOCUMENT_TYPE) ;                Move U_cXMLDOMDocumentType to iClassId
13428>>>>>            Case (iType=NODE_DOCUMENT_FRAGMENT) ;                Move U_cXMLDOMDocumentFragment to iClassId
13432>>>>>            Case (iType=NODE_NOTATION) ;                Move U_cXMLDOMNotation     to iClassId
13436>>>>>            Case (iType=0) ;                Move 0                     to iClassId // this is an error!!
13440>>>>>            Case Else ;                Move U_cXMLDOMNode         to iClassId
13442>>>>>        Case End
13442>>>>>        Function_Return iClassId
13443>>>>>    End_Function
13444>>>>>    
13444>>>>>    // Load an XML Document. The name of the document is stored in a property
13444>>>>>    // that must be set for this function to work correctly.
13444>>>>>    
13444>>>>>    Function LoadXMLDocument Returns Integer
13446>>>>>        String sDocumentName
13446>>>>>        Integer bRetVal
13446>>>>>        Get psDocumentName to sDocumentName
13447>>>>>        Get LoadDocument sDocumentName to bRetVal
13448>>>>>        If (bRetVal = 0);            Function_Return True
13451>>>>>        Else;            Function_Return False
13453>>>>>    End_Function
13454>>>>>    
13454>>>>>    Function SaveXMLDocument Returns Integer
13456>>>>>        String sDocumentName
13456>>>>>        Integer bRetVal
13456>>>>>        Get psDocumentName to sDocumentName
13457>>>>>        Get SaveDocument sDocumentName to bRetVal
13458>>>>>        Function_Return bRetVal
13459>>>>>    End_Function
13460>>>>>    
13460>>>>>    // Load an XML from a string. This aguments the C message to ret 1 if Ok and 0 if error.
13460>>>>>    //
13460>>>>>    Function LoadXML String sXML Returns Integer
13462>>>>>        Integer bRetVal
13462>>>>>        // for some reason the parser will not work properly with embedded double quotes.
13462>>>>>        // Change all " to ' in document.
13462>>>>>        //Move (replaces('"',sXML,"'")) to sXML  // removed this. Bad Idea.
13462>>>>>        Forward Get LoadXml sXML to bRetVal
13464>>>>>        If (bRetVal = 0) ;            Function_Return True
13467>>>>>        Else;            Function_Return False
13469>>>>>    End_Function
13470>>>>>    
13470>>>>>    // Load an XML string from an address. This aguments the C message to ret 1 if Ok and 0 if error.
13470>>>>>    //
13470>>>>>    Function LoadXMLFromAddress Pointer pXML Returns Integer
13472>>>>>        Integer bRetVal
13472>>>>>        Forward Get LoadXmlFromAddress pXML to bRetVal
13474>>>>>        If (bRetVal = 0) ;            Function_Return True
13477>>>>>        Else;            Function_Return False
13479>>>>>    End_Function
13480>>>>>    
13480>>>>>    
13480>>>>>    // Allow Nodes and Node node lists to get the parent document.
13480>>>>>    
13480>>>>>    Function DocumentObject Returns Handle
13482>>>>>        Function_Return Self
13483>>>>>    End_Function
13484>>>>>    
13484>>>>>    // Access to the root node allows for searches and iterations.
13484>>>>>    // The root node is a cNode.
13484>>>>>    
13484>>>>>    Function DocumentElement Returns Handle
13486>>>>>        Handle hNewNode       // Object ID of Root Node
13486>>>>>        Handle infcNode   // XML Element Interface
13486>>>>>        Get phDocumentElement to infcNode
13487>>>>>        If infcNode Begin
13489>>>>>            Get CreateXMLObject U_cXMLDOMElement infcNode to hNewNode
13490>>>>>            Set phPrivateDocumentElement to hNewNode // we no longer use this at all
13491>>>>>        End
13491>>>>>>
13491>>>>>        Function_Return hNewNode
13492>>>>>    End_Function
13493>>>>>    
13493>>>>>    //  CreateRootNode is used to set up the first element in a document.
13493>>>>>    //  It should only be used when creating new files.
13493>>>>>    
13493>>>>>    Function CreateDocumentElement String sTagName Returns Handle
13495>>>>>        Handle hNewNode       // Object ID of Root Node
13495>>>>>        Handle infcNode   // XML Element Interface
13495>>>>>        // Call XML to create an element in the document.
13495>>>>>        Get CreateElement sTagName to infcNode
13496>>>>>        // Tie the element interface to the DataFlex object.
13496>>>>>        If infcNode ;            Get CreateXMLObject U_cXMLDOMElement infcNode to hNewNode
13499>>>>>        // Call XML to set the root element of the document.
13499>>>>>        Set phDocumentElement to infcNode
13500>>>>>        Set phPrivateDocumentElement to hNewNode
13501>>>>>        Function_Return hNewNode
13502>>>>>    End_Function
13503>>>>>    
13503>>>>>    Function CreateDocumentElementNS String sNamespace String sTagName Returns Handle
13505>>>>>        Handle hNewNode       // Object ID of Root Node
13505>>>>>        Handle infcNode iType  // XML Element Interface
13505>>>>>        Get CreateElementNodeNS sNameSpace sTagName "" to hNewNode
13506>>>>>        Get XmlInterface of hNewNode to infcNode
13507>>>>>        Set phDocumentElement to infcNode
13508>>>>>        Set phPrivateDocumentElement to hNewNode
13509>>>>>        Function_Return hNewNode
13510>>>>>    End_Function
13511>>>>>    
13511>>>>>    
13511>>>>>    
13511>>>>>    // return the DocType as a document-type object. Returns 0 if no dtd
13511>>>>>    // Access to information from the doc type object is limited. Use get psXML
13511>>>>>    Function DocTypeNode Returns Handle
13513>>>>>        Handle hinfcDocType hoDocType
13513>>>>>        Get phDocType to hinfcDocType
13514>>>>>        If hinfcDocType ;            Get CreateXMLObject U_cXMLDOMDocumentType hinfcDocType to hoDocType
13517>>>>>        Function_Return hoDocType
13518>>>>>    End_Function
13519>>>>>    
13519>>>>>    Function phXMLErrorObject Returns Handle
13521>>>>>        Handle hoParseErrorObject
13521>>>>>        Handle hInfcParseError
13521>>>>>        Get phParseError to hInfcParseError
13522>>>>>        If hInfcParseError ;            Get CreateXMLObject U_cXMLDOMParseError hinfcParseError to hoParseErrorObject
13525>>>>>        Function_Return hoParseErrorObject
13526>>>>>    End_Function
13527>>>>>    
13527>>>>>    //  The following procedure is meant to be overridden by one provided by the developer.
13527>>>>>    
13527>>>>>    Procedure BasicParseErrorReport
13529>>>>>        String sProblem
13529>>>>>        String sLinePosition
13529>>>>>        String sDescr
13529>>>>>        String sReason
13529>>>>>        String sSource
13529>>>>>        Handle hoParseErrorObject
13529>>>>>        Get phXMLErrorObject to hoParseErrorObject
13530>>>>>        If hoParseErrorObject Begin
13532>>>>>            Move (SFormat(C_$CannotLoad, psDocumentName(Self)) + "."+character(13)+character(10)) to sProblem
13533>>>>>            Move (SFormat(C_$ParsingError, piLine(hoParseErrorObject), piLinePos(hoParseErrorObject))) to sLinePosition
13534>>>>>            Move (sLinePosition +character(13)+character(10)) to sLinePosition
13535>>>>>            
13535>>>>>            Move (C_$Reason + ":" * (psReason(hoParseErrorObject))  +character(13)+character(10)) to sReason
13536>>>>>            Move (C_$Source + ":" * (psSrcText(hoParseErrorObject))) to sSource
13537>>>>>            Move (sProblem + sLinePosition + sReason + sSource) to sDescr
13538>>>>>            Error DFERR_XML_INTERNAL_ERROR sDescr
13539>>>>>>
13539>>>>>            Send Destroy of hoParseErrorObject
13540>>>>>        End
13540>>>>>>
13540>>>>>        Else ;            Error DFERR_XML_INTERNAL_ERROR C_$NotCreatedParseObject
13542>>>>>    End_Procedure
13543>>>>>    
13543>>>>>    // bind an xml interface node to the passed XML object. If the
13543>>>>>    // object type is of the wrong type, we will destroy it and recreate it
13543>>>>>    // which is why hoNode is passed byRef.
13543>>>>>    // to use this you'd have to use the lower level private messages to get the
13543>>>>>    // xml interface handles and then bind them to an object. Just like in COM you could
13543>>>>>    // bind these to the same object, which might save some parsing time. This is made private
13543>>>>>    // because the time savings would probably be small and would not justify the extra
13543>>>>>    // complexity.
13543>>>>>    // It is a programming error to pass this a zero handle.
13543>>>>>    Procedure BindXMLInfc Handle hInfc Handle ByRef hoNode
13545>>>>>        Integer iType iClassId iType2
13545>>>>>        Get piNodeType of hoNode to iType2 // type of the DF XML object
13546>>>>>        
13546>>>>>        // Get the node type of the infc handle w/o creating a DF object
13546>>>>>        Move (invokexml(DF_IXMLDOMNODE, GET_piNodeType, hinfc, 0, 0, 0, 0)) to iType
13547>>>>>        Move (invokexml(DF_IXMLDOMNODE, GET_ChangeNodeType, hinfc, iType, 1, 0, 0)) to hInfc
13548>>>>>        If (hinfc=0) Begin
13550>>>>>            // this should not happen and we would need to know about this.
13550>>>>>            Error DFERR_XML_INTERNAL_ERROR (C_$XmlFailedNoDocObject + String(iType))
13551>>>>>>
13551>>>>>            Procedure_Return 0
13552>>>>>        End
13552>>>>>>
13552>>>>>        // if the type is the same we can reuse the current object and binding it to the interface pointer
13552>>>>>        If (iType=iType2) Begin
13554>>>>>            // resuse Self and return
13554>>>>>            Set XMLInterface of hoNode to hInfc
13555>>>>>        End
13555>>>>>>
13555>>>>>        // if diffrent type, destroy the existing object and recreate it
13555>>>>>        Else Begin
13556>>>>>            Send Destroy of hoNode
13557>>>>>            Get NodeClassId iType to iClassId
13558>>>>>            Get CreateXMLObject iClassId hInfc to hoNode
13559>>>>>        End
13559>>>>>>
13559>>>>>    End_Procedure
13560>>>>>    
13560>>>>>    Function ValidateDocument Returns Handle
13562>>>>>        Handle hParseErrorIntf hoParseError
13562>>>>>        Forward Get ValidateDocument to hParseErrorIntf
13564>>>>>        If hParseErrorIntf Begin
13566>>>>>            Get CreateXMLObject U_cXMLDOMParseError hParseErrorIntf to hoParseError
13567>>>>>        End
13567>>>>>>
13567>>>>>        Function_Return hoParseError
13568>>>>>    End_Function
13569>>>>>    
13569>>>>>    Function AddExternalSchemaDocument String sSchema Handle hoSchema Returns Boolean
13571>>>>>        Handle hInfc
13571>>>>>        Boolean bOk
13571>>>>>        Get XmlInterface of hoSchema to hInfc
13572>>>>>        Forward Get AddExternalSchemaDocument sSchema hInfc to bOk
13574>>>>>        Function_Return (not(bOk))
13575>>>>>    End_Function
13576>>>>>    
13576>>>>>    Function AddExternalSchemaFile String sSchema String sFile Returns Boolean
13578>>>>>        Boolean bOk
13578>>>>>        Forward Get AddExternalSchemaFile sSchema sFile to bOk
13580>>>>>        Function_Return (not(bOk))
13581>>>>>    End_Function
13582>>>>>    
13582>>>>>    Procedure Set psSelectionNamespaces String sNamespaces
13584>>>>>        Set psDomSecondLevelProperty "SelectionNamespaces" to sNamespaces
13585>>>>>    End_Procedure
13586>>>>>    
13586>>>>>    Function psSelectionNamespaces Returns String
13588>>>>>        String  sNamespaces
13588>>>>>        Get psDomSecondLevelProperty "SelectionNamespaces" to sNamespaces
13589>>>>>        Function_Return sNamespaces
13590>>>>>    End_Function
13591>>>>>    
13591>>>>>    Procedure Set pbMultipleErrorMessages Boolean bMultipleErrors
13593>>>>>        Set pbDomSecondLevelProperty "MultipleErrorMessages" to bMultipleErrors
13594>>>>>    End_Procedure
13595>>>>>    
13595>>>>>    Function pbMultipleErrorMessages Returns Boolean
13597>>>>>        Boolean bMultipleErrors
13597>>>>>        Get pbDomSecondLevelProperty "MultipleErrorMessages" to bMultipleErrors
13598>>>>>        Function_Return bMultipleErrors
13599>>>>>    End_Function
13600>>>>>    
13600>>>>>    Procedure ErrorCreatingXMLObject
13602>>>>>        Error DFERR_XML_INTERNAL_ERROR "Could not create XML COM object. MSXML6 may not be properly installed and registered."
13603>>>>>>
13603>>>>>    End_Procedure
13604>>>>>    
13604>>>>>    // returns the last parse error. If 0, you know everything parsed. This can be
13604>>>>>    // used along wit pbReadyState to load XML documents in async mode.
13604>>>>>    Function LastParseError Returns Integer
13606>>>>>        Integer iErr
13606>>>>>        Handle hoParseErrorReport
13606>>>>>        Get phXMLErrorObject to hoParseErrorReport
13607>>>>>        Get piErrorCode of hoParseErrorReport to iErr
13608>>>>>        Send Destroy of hoParseErrorReport
13609>>>>>        Function_Return iErr
13610>>>>>    End_Function
13611>>>>>    
13611>>>>>    
13611>>>>>End_Class
13612>>>Use WinKern.pkg
13612>>>Use cThriftlyService.pkg
Including file: cThriftlyService.pkg    (C:\Users\marce\OneDrive\Documentos\Thriftly Developer\Dataflex\Library_x64\AppSrc\cThriftlyService.pkg)
13612>>>>>Use UI
13612>>>>>
13612>>>>>Object oSessionManager is a cObject
13614>>>>>End_Object
13615>>>>>
13615>>>>>Class cThriftlyService is a cComEvoServiceRuntime
13616>>>>>    
13616>>>>>    Procedure Construct_Object
13618>>>>>        // The cBaseWebService class is not used to run Thriftly, it's used to help
13618>>>>>        // analyze the exposed functions.
13618>>>>>        Property Handle phoBaseWebService (Create(Self, U_cBaseWebService))
13619>>>>>        Property Handle phoSessionManager
13620>>>>>        Property String psServiceName ""
13621>>>>>        Property String psCustomErrorStructName ""
13622>>>>>        Property Handle  Main_DD 0
13623>>>>>        Property Boolean pbDefaultSecured True
13624>>>>>        Forward Send Construct_Object
13626>>>>>        
13626>>>>>        Set phoSessionManager to oSessionManager
13627>>>>>    End_Procedure
13628>>>>>    
13628>>>>>    Procedure Custom_Error_Report Handle hoRuntime ErrorData errinfo
13630>>>>>        Send ComSetErrorInfoWithData of hoRuntime errinfo.Description errinfo
13631>>>>>    End_Procedure
13632>>>>>    
13632>>>>>    Procedure End_Construct_Object
13634>>>>>        Forward Send End_Construct_Object
13636>>>>>        If (psServiceName(Self) = "") Begin
13638>>>>>            // If the first character is a lowercase "o" and the next letter is uppercase, then this is probably camel case hungarian notation
13638>>>>>            // so fix it up.
13638>>>>>            If (Left(Object_Label(Self), 1) = "o" and ("ABCDEFGHIJKLMNOPQRSTUVWXYZ" contains Mid(Object_Label(Self), 1, 2))) ;                Set psServiceName to (Remove(Object_Label(Self), 1, 1))
13641>>>>>            Else Set psServiceName to (Object_Label(Self)) 
13643>>>>>        End
13643>>>>>>
13643>>>>>        Send RegisterService of (Parent(Self)) Self
13644>>>>>    End_Procedure
13645>>>>>
13645>>>>>    Procedure RegisterInterface Integer iMsg String sMsgName String sParams String sComment Integer llFlags
13647>>>>>        // Evolution is case insensitive.
13647>>>>>        Move (Lowercase(sParams)) to sParams
13648>>>>>        Send RegisterInterface of (phoBaseWebService(Self)) iMsg (String(llFlags) + sMsgName) sParams sComment
13649>>>>>    End_Procedure
13650>>>>>    
13650>>>>>    Procedure Set CustomErrorObject String struct_name
13652>>>>>        Integer cnt
13652>>>>>        ServiceErrorType[] sets
13652>>>>>        ServiceErrorType[] sets
13653>>>>>        
13653>>>>>        Set psCustomErrorStructName to struct_name
13654>>>>>        Get pServicesCustomErrorTypes of (Parent(Self)) to sets
13655>>>>>        Move (SizeOfArray(sets)) to cnt
13656>>>>>        Move (psServiceName(Self)) to sets[cnt].serviceName
13657>>>>>        Move (struct_name) to sets[cnt].customErrorStructName
13658>>>>>        Set pServicesCustomErrorTypes of (Parent(Self)) to sets
13659>>>>>        
13659>>>>>        Send RegisterInterface of (phoBaseWebService(Self)) 0 "THRIFTLY_ERROR" (struct_name + " param") "" 
13660>>>>>    End_Procedure
13661>>>>>
13661>>>>>    Function CompareVariantStrings Variant val1 Variant val2 Returns Integer
13663>>>>>        If  (String(val1) = String (val2)) Function_Return (EQ)
13666>>>>>    End_Function
13667>>>>>    
13667>>>>>    Procedure ProcessInterfaces Handle hoEvoInterface Handle hoServiceBuilder Handle hoStructBuilder Handle hoTypeBuilder
13669>>>>>        Integer iMsgCount iMsgLoop iParamCount iParamLoop iType iArrayIndex iDim iMsgId iFlags
13669>>>>>        String sMsgName sParamName sReturnType sParamTypeName
13669>>>>>        String sErrorMessage
13669>>>>>        Handle hoWS
13669>>>>>        Handle hoDocObj
13669>>>>>        Variant[][] vStructs
13670>>>>>        Variant vPrototype
13670>>>>>        Variant vType
13670>>>>>        
13670>>>>>        Get phoBaseWebService to hoWS
13671>>>>>        Move (oThriftlyDocumentation(Self)) to hoDocObj
13672>>>>>        
13672>>>>>        Get ProcessTypes of (Parent(Self)) hoWS hoEvoInterface hoStructBuilder hoTypeBuilder to vStructs
13673>>>>>        
13673>>>>>        Get InterfaceMessageCount of hoWS to iMsgCount
13674>>>>>        
13674>>>>>        For iMsgLoop from 0 to (iMsgCount-1)
13680>>>>>>
13680>>>>>            Get InterfaceMessageParamCount of hoWS iMsgLoop to iParamCount
13681>>>>>            Get InterfaceMessageName of hoWS iMsgLoop to sMsgName
13682>>>>>            If (trim(uppercase(sMsgName)) = "THRIFTLY_ERROR") Break Begin
13685>>>>>
13685>>>>>            Get FindMessageID of hoWS sMsgName to iMsgId
13686>>>>>
13686>>>>>            Move (Integer(Left(sMsgName, 1))) to iFlags
13687>>>>>            Move (Mid(sMsgName, Length(sMsgName)-1, 2)) to sMsgName
13688>>>>>
13688>>>>>            Set pvComObject of hoStructBuilder to (ComNewStruct(hoEvoInterface))
13689>>>>>            
13689>>>>>// I'm using FindMessageID a few lines earlier instead of InterfaceMessageID because starting with DF20
13689>>>>>// this call causes a crash for some unknown reason. - OLI
13689>>>>>//            Get InterfaceMessageId of hoWS iMsgLoop to iMsgId
13689>>>>>            Send ComAddPrivateField of hoStructBuilder 1 "MessageId" "" (ComCreateInt32(hoTypeBuilder)) iMsgId
13690>>>>>            Send ComAddPrivateField of hoStructBuilder 2 "MessageName" "" (ComCreateString(hoTypeBuilder)) sMsgName
13691>>>>>            
13691>>>>>            // Because of the private fields, we need to add 2 to iParamLoop where it is used to add a field...
13691>>>>>            For iParamLoop from 1 to iParamCount
13697>>>>>>
13697>>>>>                Get InterfaceMessageParamType of hoWS iMsgLoop (iParamLoop-1) to iType
13698>>>>>                Get InterfaceMessageParamName of hoWS iMsgLoop (iParamLoop-1) to sParamName
13699>>>>>                Get InterfaceMessageParamTypeName of hoWS iMsgLoop (iParamLoop-1) to sParamTypeName
13700>>>>>                Get InterfaceMessageParamDimCount of hoWS iMsgLoop (iParamLoop-1) to iDim
13701>>>>>                
13701>>>>>                Case Begin
13701>>>>>                    Case (iType = xsBoolean or iType = xsBit)
13703>>>>>                        If (iDim = 0) Get ComCreateBool of hoTypeBuilder to vType
13706>>>>>                        Else Move (ComCreateList(hoTypeBuilder, ComCreateBool(hoTypeBuilder))) to vType
13708>>>>>                        Case Break
13709>>>>>                    Case (iType = xsUchar)
13712>>>>>                        If (iDim = 0) Get ComCreateByte of hoTypeBuilder to vType
13715>>>>>                        Else Move (ComCreateBinary(hoTypeBuilder)) to vType
13717>>>>>                        Case Break
13718>>>>>                    Case (iType = xsShort)
13721>>>>>                        If (iDim = 0) Get ComCreateInt16 of hoTypeBuilder to vType
13724>>>>>                        Else Move (ComCreateList(hoTypeBuilder, ComCreateInt16(hoTypeBuilder))) to vType
13726>>>>>                        Case Break
13727>>>>>                    Case (iType = xsInteger  or iType = 26)  // Thriftly.x64 TEMPORARY code
13730>>>>>                        If (iDim = 0) Get ComCreateInt32 of hoTypeBuilder to vType
13733>>>>>                        Else Move (ComCreateList(hoTypeBuilder, ComCreateInt32(hoTypeBuilder))) to vType
13735>>>>>                        Case Break
13736>>>>>                    Case (iType = xsBigint)
13739>>>>>                        If (iDim = 0) Get ComCreateInt64 of hoTypeBuilder to vType
13742>>>>>                        Else Move (ComCreateList(hoTypeBuilder, ComCreateInt64(hoTypeBuilder))) to vType
13744>>>>>                        Case Break
13745>>>>>                    Case (iType = xsNumber or iType = xsDecimal)
13748>>>>>                        If (iDim = 0) Get ComCreateDecimal of hoTypeBuilder to vType
13751>>>>>                        Else Begin
13752>>>>>                            Error 301 ("The data type of the parameter " * sParamName * "(" + sParamTypeName + "[ ])" * "in" * sMsgName * "is unsupported in Thriftly. Please consider using a REAL[ ] type instead. Program will now abort.")
13753>>>>>>
13753>>>>>                            Abort
13754>>>>>>
13754>>>>>                        End
13754>>>>>>
13754>>>>>                        Case Break
13755>>>>>                    Case (iType = xsReal or iType = xsFloat)
13758>>>>>                        If (iDim = 0) Get ComCreateDouble of hoTypeBuilder to vType
13761>>>>>                        Else Move (ComCreateList(hoTypeBuilder, ComCreateDouble(hoTypeBuilder))) to vType
13763>>>>>                        Case Break
13764>>>>>                    Case (iType = xsDate)
13767>>>>>                        If (iDim = 0) Get ComCreateDate of hoTypeBuilder to vType
13770>>>>>                        Else Move (ComCreateList(hoTypeBuilder, ComCreateDate(hoTypeBuilder))) to vType
13772>>>>>                        Case Break
13773>>>>>                    Case (iType = xsDatetime)
13776>>>>>                        If (iDim = 0) Get ComCreateDateTime of hoTypeBuilder to vType
13779>>>>>                        Else Move (ComCreateList(hoTypeBuilder, ComCreateDateTime(hoTypeBuilder))) to vType
13781>>>>>                        Case Break
13782>>>>>                    Case (iType = xsString)
13785>>>>>                        If (iDim = 0) Get ComCreateString of hoTypeBuilder to vType
13788>>>>>                        Else Move (ComCreateList(hoTypeBuilder, ComCreateString(hoTypeBuilder))) to vType
13790>>>>>                        Case Break
13791>>>>>                    Case (iType = xsStruct)
13794>>>>>                        Move (SearchArray(sParamTypeName, vStructs[0], Self, GET_CompareVariantStrings)) to iArrayIndex
13795>>>>>                        If (iDim = 0) Move vStructs[1][iArrayIndex] to vType
13798>>>>>                        Else Move (ComCreateList(hoTypeBuilder, vStructs[1][iArrayIndex])) to vType
13800>>>>>                        Case Break
13801>>>>>                    Case Else
13801>>>>>                        Error 300 ("The data type of the parameter " * sParamName * "(" + sParamTypeName + ")" * "in" * sMsgName * "is unsupported in Thriftly. Please choose a different data type. Program will now abort.")
13802>>>>>>
13802>>>>>                        Abort
13803>>>>>>
13803>>>>>                Case End
13803>>>>>                Send ComAddField of hoStructBuilder (iParamLoop+2) sParamName (ParameterDescription(hoDocObj, psServiceName(Self), sMsgName, sParamName)) vType True
13804>>>>>            Loop
13805>>>>>>
13805>>>>>
13805>>>>>            // Now that we've processed all the parameters, it's time to create the function/procedure definition and deal with the return type.
13805>>>>>
13805>>>>>            Move (Remove(sMsgName, 1, 4)) to sMsgName  // this removes the get_ or msg_
13806>>>>>            Get InterfaceMessageParamTypeName of hoWS iMsgLoop iParamCount to sReturnType
13807>>>>>            Get InterfaceMessageParamType of hoWS iMsgLoop iParamCount to iType
13808>>>>>            Get InterfaceMessageParamName of hoWS iMsgLoop iParamCount to sParamName
13809>>>>>            Get InterfaceMessageParamDimCount of hoWS iMsgLoop iParamCount to iDim
13810>>>>>            Get ComCreatePrototype of hoStructBuilder to vPrototype
13811>>>>>            If (iType = -1) Begin
13813>>>>>                // This means we have a procedure, not a function, so no return type
13813>>>>>                Send ComAddProcedure to hoServiceBuilder (iMsgLoop+1) sMsgName (MethodDescription(hoDocObj, psServiceName(Self), sMsgName)) vPrototype iFlags
13814>>>>>            End
13814>>>>>>
13814>>>>>            Else Begin
13815>>>>>                Case Begin
13815>>>>>                    Case (iType = xsBoolean or iType = xsBit)
13817>>>>>                        If (iDim = 0) Get ComCreateBool of hoTypeBuilder to vType
13820>>>>>                        Else Move (ComCreateList(hoTypeBuilder, ComCreateBool(hoTypeBuilder))) to vType
13822>>>>>                        Case Break
13823>>>>>                    Case (iType = xsUchar)
13826>>>>>                        If (iDim = 0) Get ComCreateByte of hoTypeBuilder to vType
13829>>>>>                        Else Move (ComCreateBinary(hoTypeBuilder)) to vType
13831>>>>>                        Case Break
13832>>>>>                    Case (iType = xsShort)
13835>>>>>                        If (iDim = 0) Get ComCreateInt16 of hoTypeBuilder to vType
13838>>>>>                        Else Move (ComCreateList(hoTypeBuilder, ComCreateInt16(hoTypeBuilder))) to vType
13840>>>>>                        Case Break
13841>>>>>                    Case (iType = xsInteger or iType = 26)  // Thriftly.x64 TEMPORARY code
13844>>>>>                        If (iDim = 0) Get ComCreateInt32 of hoTypeBuilder to vType
13847>>>>>                        Else Move (ComCreateList(hoTypeBuilder, ComCreateInt32(hoTypeBuilder))) to vType
13849>>>>>                        Case Break
13850>>>>>                    Case (iType = xsBigint)
13853>>>>>                        If (iDim = 0) Get ComCreateInt64 of hoTypeBuilder to vType
13856>>>>>                        Else Move (ComCreateList(hoTypeBuilder, ComCreateInt64(hoTypeBuilder))) to vType
13858>>>>>                        Case Break
13859>>>>>                    Case (iType = xsNumber or iType = xsDecimal)
13862>>>>>                        If (iDim = 0) Get ComCreateDecimal of hoTypeBuilder to vType
13865>>>>>                        Else Begin
13866>>>>>                            Error 301 ("The return type of the function" * sMsgName * "(" + sReturnType + "[ ])" * "is unsupported in Thriftly. Please consider using a REAL[ ] type instead. Program will now abort.")
13867>>>>>>
13867>>>>>                            Abort
13868>>>>>>
13868>>>>>                        End
13868>>>>>>
13868>>>>>                        Case Break
13869>>>>>                    Case (iType = xsReal or iType = xsFloat)
13872>>>>>                        If (iDim = 0) Get ComCreateDouble of hoTypeBuilder to vType
13875>>>>>                        Else Move (ComCreateList(hoTypeBuilder, ComCreateDouble(hoTypeBuilder))) to vType
13877>>>>>                        Case Break
13878>>>>>                    Case (iType = xsDate)
13881>>>>>                        If (iDim = 0) Get ComCreateDate of hoTypeBuilder to vType
13884>>>>>                        Else Move (ComCreateList(hoTypeBuilder, ComCreateDate(hoTypeBuilder))) to vType
13886>>>>>                        Case Break
13887>>>>>                    Case (iType = xsDatetime)
13890>>>>>                        If (iDim = 0) Get ComCreateDateTime of hoTypeBuilder to vType
13893>>>>>                        Else Move (ComCreateList(hoTypeBuilder, ComCreateDateTime(hoTypeBuilder))) to vType
13895>>>>>                        Case Break
13896>>>>>                    Case (iType = xsString)
13899>>>>>                        If (iDim = 0) Get ComCreateString of hoTypeBuilder to vType
13902>>>>>                        Else Move (ComCreateList(hoTypeBuilder, ComCreateString(hoTypeBuilder))) to vType
13904>>>>>                        Case Break
13905>>>>>                    Case (iType = xsStruct)
13908>>>>>                        Move (SearchArray(sReturnType, vStructs[0], Self, GET_CompareVariantStrings)) to iArrayIndex
13909>>>>>                        If (iDim = 0) Move vStructs[1][iArrayIndex] to vType
13912>>>>>                        Else Move (ComCreateList(hoTypeBuilder, vStructs[1][iArrayIndex])) to vType
13914>>>>>                        Case Break
13915>>>>>                    Case Else
13915>>>>>                        Error 300 ("The return type of the function " * sMsgName * "(" + sReturnType + ")" * "is unsupported in Thriftly. Please choose a different data type. Program will now abort.")
13916>>>>>>
13916>>>>>                        Abort
13917>>>>>>
13917>>>>>                Case End
13917>>>>>    
13917>>>>>                Send ComAddFunction to hoServiceBuilder (iMsgLoop+1) sMsgName (MethodDescription(hoDocObj, psServiceName(Self), sMsgName)) vType (ReturnDescription(hoDocObj, psServiceName(Self), sMsgName)) vPrototype iFlags
13918>>>>>            End
13918>>>>>>
13918>>>>>        Loop
13919>>>>>>
13919>>>>>    End_Procedure
13920>>>>>
13920>>>>>    Procedure ServiceException String error_message ErrorData exception
13922>>>>>        String[] callstack
13923>>>>>        String sCallstack call loc
13923>>>>>        Variant vRuntime
13923>>>>>        Handle hoRuntime
13923>>>>>        
13923>>>>>        Get ComRuntime to vRuntime
13924>>>>>        Get Create U_cComIEvoRuntime to hoRuntime
13925>>>>>        Set pvComObject of hoRuntime to vRuntime
13926>>>>>
13926>>>>>        // We don't EVER want a callstack in these types of errors, so empty out the array
13926>>>>>        Move (ResizeArray(exception.CallStack, 0)) to exception.CallStack
13927>>>>>
13927>>>>>        CallStackDump sCallStack
13928>>>>>        Get StringToArray of Error_object_ID sCallStack C_CRLF to callstack
13929>>>>>        
13929>>>>>        // The Second item ([1]) in the array will be the function that threw the error
13929>>>>>        // since this function was called from there. The first 4 characters are always
13929>>>>>        // "GET_" or "MSG_", so we remove those. And then we want the name of the
13929>>>>>        // function or procedure, so cut that part out. We also want the "address" at
13929>>>>>        // the end which is the line of code that threw the exception.
13929>>>>>        Move (Remove(callstack[1], 1, 4)) to call
13930>>>>>        Move (Left(call, Pos(" ", call)-1)) to exception.CallStack[0]
13931>>>>>        Move (Right(call, length(call) - RightPos(" ", call))) to loc
13932>>>>>        Move (Integer(loc)) to exception.LineNumber
13933>>>>>        
13933>>>>>        // For Service Exceptions we always consider them "handled", so make sure it is marked that way
13933>>>>>        Move False to exception.Unhandled
13934>>>>>        
13934>>>>>        Send ComSetErrorInfoWithData of hoRuntime error_message exception
13935>>>>>
13935>>>>>        Set pvComObject of hoRuntime to (NullComObject())
13936>>>>>        Send Destroy_Object of hoRuntime
13937>>>>>    End_Procedure
13938>>>>>    
13938>>>>>    Procedure EventDispatcher Integer iMsgId String sMsgName Variant vParam1 Variant vParam2 Variant vParam3 Variant vParam4 ;                              Variant vParam5 Variant vParam6 Variant vParam7 Variant vParam8 Variant vParam9 Variant vParam10 ;                              Variant vParam11 Variant vParam12 Variant vParam13 Variant vParam14
13940>>>>>        String get_or_msg
13940>>>>>        Integer iType
13940>>>>>        Variant vElement
13940>>>>>        
13940>>>>>        // This very unusual line of code is to fix a bug where DataFlex loses the DATE4_STATE setting when in a reentrant
13940>>>>>        // windows message. The setting is restored after the com event finishes. This is based on customer report and 
13940>>>>>        // this thread:
13940>>>>>        //
13940>>>>>        // http://support.dataaccess.com/Forums/showthread.php?34372-This-is-how-users-can-enter-dates-with-2-digit-years
13940>>>>>        //
13940>>>>>        // Thank you Jorgen Munster for your sleuthing. - OLI
13940>>>>>        //
13940>>>>>        Set_Date_Attribute Date4_State to True
WARNING: 4533 Obsolete Command Obsolete command: Set_Date_Attribute. Use Set_Attribute DF_DATE_FORMAT ON LINE: 293 (13940) OF FILE: C:\Users\marce\OneDrive\Documentos\Thriftly Developer\Dataflex\Library_x64\AppSrc\cThriftlyService.pkg
13941>>>>>        
13941>>>>>        Move Self to EVO_CURRENT_SERVICE
13942>>>>>        
13942>>>>>        If (num_arguments = 2) Begin
13944>>>>>            // this can only be a procedure with 2 argument, nothing returned, nothing sent
13944>>>>>            Send iMsgId  
13945>>>>>            Procedure_Return
13946>>>>>        End
13946>>>>>>
13946>>>>>        Move (Left(sMsgName, 3)) to get_or_msg
13947>>>>>        
13947>>>>>        If (num_arguments = 3) Begin
13949>>>>>            If (get_or_msg = "get") Get iMsgId to vParam1
13952>>>>>            Else Send iMsgId vParam1
13954>>>>>            
13954>>>>>            Procedure_Return
13955>>>>>        End
13955>>>>>>
13955>>>>>        If (num_arguments = 4) Begin
13957>>>>>            If (get_or_msg = "get") Get iMsgId vParam1 to vParam2
13960>>>>>            Else Send iMsgId vParam1 vParam2
13962>>>>>            
13962>>>>>            Procedure_Return 
13963>>>>>        End
13963>>>>>>
13963>>>>>        If (num_arguments = 5) Begin
13965>>>>>            If (get_or_msg = "get") Get iMsgId vParam1 vParam2 to vParam3
13968>>>>>            Else Send iMsgId vParam1 vParam2 vParam3
13970>>>>>
13970>>>>>            Procedure_Return 
13971>>>>>        End
13971>>>>>>
13971>>>>>        If (num_arguments = 6) Begin
13973>>>>>            If (get_or_msg = "get") Get iMsgId vParam1 vParam2 vParam3 to vParam4
13976>>>>>            Else Send iMsgId vParam1 vParam2 vParam3 vParam4
13978>>>>>            
13978>>>>>            Procedure_Return 
13979>>>>>        End
13979>>>>>>
13979>>>>>        If (num_arguments = 7) Begin
13981>>>>>            If (get_or_msg = "get") Get iMsgId vParam1 vParam2 vParam3 vParam4 to vParam5
13984>>>>>            Else Send iMsgId vParam1 vParam2 vParam3 vParam4 vParam5
13986>>>>>            
13986>>>>>            Procedure_Return 
13987>>>>>        End
13987>>>>>>
13987>>>>>        If (num_arguments = 8) Begin
13989>>>>>            If (get_or_msg = "get") Get iMsgId vParam1 vParam2 vParam3 vParam4 vParam5 to vParam6
13992>>>>>            Else Send iMsgId vParam1 vParam2 vParam3 vParam4 vParam5 vParam6
13994>>>>>            
13994>>>>>            Procedure_Return 
13995>>>>>        End
13995>>>>>>
13995>>>>>        If (num_arguments = 9) Begin
13997>>>>>            If (get_or_msg = "get") Get iMsgId vParam1 vParam2 vParam3 vParam4 vParam5 vParam6 to vParam7
14000>>>>>            Else Send iMsgId vParam1 vParam2 vParam3 vParam4 vParam5 vParam6 vParam7
14002>>>>>            
14002>>>>>            Procedure_Return 
14003>>>>>        End
14003>>>>>>
14003>>>>>        If (num_arguments = 10) Begin
14005>>>>>            If (get_or_msg = "get") Get iMsgId vParam1 vParam2 vParam3 vParam4 vParam5 vParam6 vParam7 to vParam8
14008>>>>>            Else Send iMsgId vParam1 vParam2 vParam3 vParam4 vParam5 vParam6 vParam7 vParam8
14010>>>>>            
14010>>>>>            Procedure_Return 
14011>>>>>        End
14011>>>>>>
14011>>>>>        If (num_arguments = 11) Begin
14013>>>>>            If (get_or_msg = "get") Get iMsgId vParam1 vParam2 vParam3 vParam4 vParam5 vParam6 vParam7 vParam8 to vParam9
14016>>>>>            Else Send iMsgId vParam1 vParam2 vParam3 vParam4 vParam5 vParam6 vParam7 vParam8 vParam9
14018>>>>>            
14018>>>>>            Procedure_Return 
14019>>>>>        End
14019>>>>>>
14019>>>>>        If (num_arguments = 12) Begin
14021>>>>>            If (get_or_msg = "get") Get iMsgId vParam1 vParam2 vParam3 vParam4 vParam5 vParam6 vParam7 vParam8 vParam9 to vParam10
14024>>>>>            Else Send iMsgId vParam1 vParam2 vParam3 vParam4 vParam5 vParam6 vParam7 vParam8 vParam9 vParam10
14026>>>>>            
14026>>>>>            Procedure_Return 
14027>>>>>        End
14027>>>>>>
14027>>>>>        If (num_arguments = 13) Begin
14029>>>>>            If (get_or_msg = "get") Get iMsgId vParam1 vParam2 vParam3 vParam4 vParam5 vParam6 vParam7 vParam8 vParam9 vParam10 to vParam11
14032>>>>>            Else Send iMsgId vParam1 vParam2 vParam3 vParam4 vParam5 vParam6 vParam7 vParam8 vParam9 vParam10 vParam11
14034>>>>>            
14034>>>>>            Procedure_Return 
14035>>>>>        End
14035>>>>>>
14035>>>>>        If (num_arguments = 14) Begin
14037>>>>>            If (get_or_msg = "get") Get iMsgId vParam1 vParam2 vParam3 vParam4 vParam5 vParam6 vParam7 vParam8 vParam9 vParam10 vParam11 to vParam12
14040>>>>>            Else Send iMsgId vParam1 vParam2 vParam3 vParam4 vParam5 vParam6 vParam7 vParam8 vParam9 vParam10 vParam11 vParam12
14042>>>>>            
14042>>>>>            Procedure_Return 
14043>>>>>        End
14043>>>>>>
14043>>>>>        If (num_arguments = 15) Begin
14045>>>>>            If (get_or_msg = "get") Get iMsgId vParam1 vParam2 vParam3 vParam4 vParam5 vParam6 vParam7 vParam8 vParam9 vParam10 vParam11 vParam12 to vParam13
14048>>>>>            Else Send iMsgId vParam1 vParam2 vParam3 vParam4 vParam5 vParam6 vParam7 vParam8 vParam9 vParam10 vParam11 vParam12 vParam13
14050>>>>>            
14050>>>>>            Procedure_Return 
14051>>>>>        End
14051>>>>>>
14051>>>>>        If (num_arguments = 16) Begin
14053>>>>>            If (get_or_msg = "get") Get iMsgId vParam1 vParam2 vParam3 vParam4 vParam5 vParam6 vParam7 vParam8 vParam9 vParam10 vParam11 vParam12 vParam13 to vParam14
14056>>>>>            Else Send iMsgId vParam1 vParam2 vParam3 vParam4 vParam5 vParam6 vParam7 vParam8 vParam9 vParam10 vParam11 vParam12 vParam13 vParam14
14058>>>>>            
14058>>>>>            Procedure_Return 
14059>>>>>        End
14059>>>>>>
14059>>>>>    End_Procedure
14060>>>>>    
14060>>>>>    Procedure RegisterDynamicEvents
14062>>>>>        Handle hoWS
14062>>>>>        Integer iMsgCount iMsgLoop
14062>>>>>        String sMsgName
14062>>>>>        
14062>>>>>        Get phoBaseWebService to hoWS
14063>>>>>        Get InterfaceMessageCount of hoWS to iMsgCount
14064>>>>>        
14064>>>>>        For iMsgLoop from 0 to (iMsgCount-1)
14070>>>>>>
14070>>>>>            Send RegisterComEvent (iMsgLoop+1) msg_EventDispatcher
14071>>>>>        Loop
14072>>>>>>
14072>>>>>    End_Procedure
14073>>>>>
14073>>>>>    Function JWTPayload Returns Variant
14075>>>>>        Variant vPayload
14075>>>>>        Get JWTPayload of (Parent(Self)) to vPayload
14076>>>>>        Function_Return vPayload
14077>>>>>    End_Function
14078>>>>>    
14078>>>>>    Function JWSPayload Returns String
14080>>>>>        String sPayload
14080>>>>>        Get JWSPayload of (Parent(Self)) to sPayload
14081>>>>>        Function_Return sPayload
14082>>>>>    End_Function
14083>>>>>
14083>>>>>    Procedure Heartbeat 
14085>>>>>        Send Heartbeat of (Parent(Self)) 
14086>>>>>    End_Procedure
14087>>>>>
14087>>>>>End_Class
14088>>>
14088>>>Struct tMSG
14088>>>    Handle hWnd
14088>>>    Integer Message
14088>>>    DWord wParam
14088>>>    DWord pad1
14088>>>    DWord lParam
14088>>>    DWord pad2
14088>>>    DWord Time
14088>>>    DWord pad3
14088>>>    Integer XCoord
14088>>>    DWord pad4
14088>>>    Integer YCoord
14088>>>    DWord pad5
14088>>>End_Struct
14088>>>
14088>>>//Struct tMSG
14088>>>//    Handle hWnd
14088>>>//    Integer Message
14088>>>//    DWord wParam
14088>>>//    DWord lParam
14088>>>//    DWord Time
14088>>>//    Integer XCoord
14088>>>//    Integer YCoord
14088>>>//End_Struct
14088>>>
14088>>>External_Function PeekMessage "PeekMessageA" User32.dll ;    Pointer lpMsgStruct;    Handle hWnd ;    UInteger MsgFilterMin ;    UInteger MsgFilterMax ;    UInteger RemoveMsg ;    Returns Integer
14089>>>
14089>>>                                                       
14089>>>    External_Function GetMessage "GetMessageW" User32.dll ;        Pointer lpMsgStruct;        Handle hWnd ;        UInteger MsgFilterMin ;        UInteger MsgFilterMax ;        Returns Integer
14090>>>
14090>>>External_Function TranslateMessage "TranslateMessage" User32.dll Pointer lpMsg Returns Integer
14091>>>
14091>>>External_Function DispatchMessage "DispatchMessageA" User32.dll Pointer lpMsg Returns Integer
14092>>>
14092>>>//External_Function DllCanUnloadNow "DllCanUnloadNow" C:\Evolution\Evolution.Interface\Release\Evolution.Interface.dll Returns Integer
14092>>>
14092>>>Class cThriftlyServer is a Array //cObject
14093>>>    
14093>>>    Procedure Construct_Object
14095>>>        Property Handle phoGenericAutomation (Create(Self, U_DfComAutomationObject))
14096>>>        
14096>>>        Property Handle phOldErrorObject
14097>>>        
14097>>>        Property Handle phoServer
14098>>>        
14098>>>        Property Handle[] phoServices
14099>>>        
14099>>>        Property Variant[][] pvStructs
14100>>>        
14100>>>        Property Handle phoErrorSys (Create(Self, U_cThriftlyErrorSystem))
14101>>>        
14101>>>        Property ServiceErrorType[] pServicesCustomErrorTypes
14102>>>        
14102>>>        Forward Send Construct_Object
14104>>>    End_Procedure
14105>>>    
14105>>>    Procedure RegisterService Handle hoService
14107>>>        Handle[] services
14108>>>        
14108>>>        Get phoServices to services
14109>>>        Move hoService to services[SizeOfArray(services)]
14110>>>        Set phoServices to services
14111>>>    End_Procedure
14112>>>
14112>>>    Function CompareVariantStrings Variant val1 Variant val2 Returns Integer
14114>>>        If (String(val1) = String (val2)) Function_Return (EQ)
14117>>>        Function_Return (0)
14118>>>    End_Function
14119>>>
14119>>>    Function ProcessType Handle hoBaseStructs Handle hoStructNode Variant[][] ByRef vStructs Handle hoEvoInterface Handle hoStructBuilder Handle hoTypeBuilder Returns Variant
14121>>>        String sStructName sElementName sElementType sElementArrayCount sElementTypeRef
14121>>>        String sErrorMessage
14121>>>        Integer iNodeListLength iNode iArrayIndex iStructNode
14121>>>        Handle hoNode hoChildStruct
14121>>>        Variant vStruct vThisStructBuilder vType
14121>>>        Variant[] temp
14122>>>        Handle hoDocObj
14122>>>        Move (oThriftlyDocumentation(Self)) to hoDocObj
14123>>>
14123>>>        Get AttributeValue of hoStructNode "name" to sStructName
14124>>>        
14124>>>        // Let's see if this Struct is already defined, if it is, just return it
14124>>>        Send Ignore_Error of Error_Object_Id 4509
14125>>>        Move False to err
14126>>>        Move vStructs[0] to temp
14127>>>        If (not(Err)) Begin
14129>>>            Send Trap_Error of Error_Object_Id 4509
14130>>>            Move (SearchArray(sStructName, vStructs[0], Self, GET_CompareVariantStrings)) to iArrayIndex
14131>>>            If (iArrayIndex > -1) Function_Return vStructs[1][iArrayIndex]
14134>>>        End
14134>>>>
14134>>>        
14134>>>        Send Trap_Error of Error_Object_Id 4509
14135>>>        
14135>>>        Set pvComObject of hoStructBuilder to (ComNewStruct(hoEvoInterface))
14136>>>        
14136>>>        Get ElementNodes of hoStructNode "*" to hoStructNode
14137>>>        Get NodeListLength of hoStructNode to iNodeListLength
14138>>>        
14138>>>        For iNode from 0 to (iNodeListLength-1)
14144>>>>
14144>>>            Get CollectionNode of hoStructNode iNode to hoNode
14145>>>            Get AttributeValue of hoNode "name" to sElementName
14146>>>            Get AttributeValue of hoNode "type" to sElementType
14147>>>            Get AttributeValue of hoNode "arrayDimCount" to sElementArrayCount
14148>>>            Get AttributeValue of hoNode "typeRef" to sElementTypeRef
14149>>>            
14149>>>            // If this class of data type is an array, then go through the supported types to map to Evolution.
14149>>>            // If the type isn't here AND it doesn't appear to be a struct, then throw a runtime message and quit.
14149>>>
14149>>>            Case Begin
14149>>>                Case (sElementType = "boolean")
14151>>>                    Move (ComCreateBool(hoTypeBuilder)) to vType
14152>>>                    If (sElementArrayCount <> "") Move (ComCreateList(hoTypeBuilder, vType)) to vType
14155>>>                    Case Break
14156>>>                Case (sElementType = "uchar" or sElementType = "char")
14159>>>                    If (sElementArrayCount <> "" and sElementType = "char") Begin
14161>>>                        Error 301 ("The data type of the element" * sElementName * "(" + sElementType + "[ ])" * "in" * sStructName * "is unsupported in Thriftly. Please consider using a REAL[ ] type instead. Program will now abort.")
14162>>>>
14162>>>                        Abort
14163>>>>
14163>>>                    End
14163>>>>
14163>>>                    If (sElementArrayCount <> "") Move (ComCreateBinary(hoTypeBuilder)) to vType
14166>>>                    Else Move (ComCreateByte(hoTypeBuilder)) to vType
14168>>>                    Case Break
14169>>>                Case (sElementType = "short")
14172>>>                    Move (ComCreateInt16(hoTypeBuilder)) to vType
14173>>>                    If (sElementArrayCount <> "") Move (ComCreateList(hoTypeBuilder, vType)) to vType
14176>>>                    Case Break
14177>>>                Case (sElementType = "integer")
14180>>>                    Move (ComCreateInt32(hoTypeBuilder)) to vType
14181>>>                    If (sElementArrayCount <> "") Move (ComCreateList(hoTypeBuilder, vType)) to vType
14184>>>                    Case Break
14185>>>                Case (sElementType = "bigint")
14188>>>                    Move (ComCreateInt64(hoTypeBuilder)) to vType
14189>>>                    If (sElementArrayCount <> "") Move (ComCreateList(hoTypeBuilder, vType)) to vType
14192>>>                    Case Break
14193>>>                Case (sElementType = "number" or sElementType = "decimal")
14196>>>                    If (sElementArrayCount <> "") Begin
14198>>>                        Error 301 ("The data type of the element" * sElementName * "(" + sElementType + "[ ])" * "in" * sStructName * "is unsupported in Thriftly. Please consider using a REAL[ ] type instead. Program will now abort.")
14199>>>>
14199>>>                        Abort
14200>>>>
14200>>>                    End
14200>>>>
14200>>>                    Else Move (ComCreateDecimal(hoTypeBuilder)) to vType
14202>>>                    Case Break
14203>>>                Case (sElementType = "real" or sElementType = "float")
14206>>>                    Move (ComCreateDouble(hoTypeBuilder)) to vType
14207>>>                    If (sElementArrayCount <> "") Move (ComCreateList(hoTypeBuilder, vType)) to vType
14210>>>                    Case Break
14211>>>                Case (sElementType = "date")
14214>>>                    Move (ComCreateDate(hoTypeBuilder)) to vType
14215>>>                    If (sElementArrayCount <> "") Move (ComCreateList(hoTypeBuilder, vType)) to vType
14218>>>                    Case Break
14219>>>                Case (sElementType = "datetime")
14222>>>                    Move (ComCreateDateTime(hoTypeBuilder)) to vType
14223>>>                    If (sElementArrayCount <> "") Move (ComCreateList(hoTypeBuilder, vType)) to vType
14226>>>                    Case Break
14227>>>                Case (sElementType = "string")
14230>>>                    Move (ComCreateString(hoTypeBuilder)) to vType
14231>>>                    If (sElementArrayCount <> "") Move (ComCreateList(hoTypeBuilder, vType)) to vType
14234>>>                    Case Break
14235>>>                Case (sElementTypeRef = "")
14238>>>                    Error 300 ("The data type of the element" * sElementName * "(" + sElementType + "[ ])" * "in" * sStructName * "is unsupported in Thriftly. Please choose a different data type. Program will now abort.")
14239>>>>
14239>>>                    Abort
14240>>>>
14240>>>                    Case Break
14241>>>                Case Else // this means it's probably a struct
14241>>>                    Move sElementTypeRef to sElementType
14242>>>                    // Let's see if this Struct is already defined, if it is, search it
14242>>>                    Send Ignore_Error of Error_Object_Id 4509
14243>>>                    Move False to err
14244>>>                    Move vStructs[0] to temp
14245>>>                    If (not(Err)) Begin
14247>>>                        Send Trap_Error of Error_Object_Id 4509
14248>>>                        Move (SearchArray(sElementType, vStructs[0], Self, GET_CompareVariantStrings)) to iArrayIndex
14249>>>                    End
14249>>>>
14249>>>                    Else Move -1 to iArrayIndex
14251>>>                    If (iArrayIndex > -1) Begin
14253>>>                        Move vStructs[1][iArrayIndex] to vType
14254>>>                        If (sElementArrayCount <> "") Move (ComCreateList(hoTypeBuilder, vType)) to vType
14257>>>                    End
14257>>>>
14257>>>                    Else Begin
14258>>>                        // Save the Struct Variant we're working on
14258>>>                        Get pvComObject of hoStructBuilder to vThisStructBuilder
14259>>>                        Get FindNode of hoBaseStructs (SFormat("//ns:struct[@name='%1']", sElementType)) to hoChildStruct
14260>>>                        Get ProcessType hoBaseStructs hoChildStruct (&vStructs) hoEvoInterface hoStructBuilder hoTypeBuilder to vStruct
14261>>>                        Set pvComObject of hoStructBuilder to vThisStructBuilder
14262>>>                        Move vStruct to vType
14263>>>                        If (sElementArrayCount <> "") Move (ComCreateList(hoTypeBuilder, vType)) to vType
14266>>>                    End
14266>>>>
14266>>>            Case End
14266>>>
14266>>>            Send ComAddField of hoStructBuilder (iNode + 1) sElementName (StructElementDescription(hoDocObj, sStructName, sElementName)) vType False
14267>>>        Loop
14268>>>>
14268>>>        
14268>>>        Move sStructName to vStructs[0][(SizeOfArray(vStructs[0]))]
14269>>>        Move (ComCreateStruct(hoStructBuilder, sStructName, StructDescription(hoDocObj, sStructName))) to vStruct
14270>>>        Move vStruct to vStructs[1][(SizeOfArray(vStructs[1]))]
14271>>>        
14271>>>        Function_Return vStruct
14272>>>    End_Function
14273>>>
14273>>>    Function ProcessTypes Handle hoWS Handle hoEvoInterface Handle hoStructBuilder Handle hoTypeBuilder Returns Variant[][]
14275>>>        String sTypesXML sElementName sElementType sElementArrayCount sStructName 
14275>>>        Handle hoXML hoRoot hoBaseStructs hoStructNode hoNode
14275>>>        Integer iNodeListLength iNode iStructNodeListLength iStructNode iArrayIndex sets_size cnt
14275>>>        Boolean bRetval
14275>>>        Variant[][] vStructs
14276>>>        Variant vStruct
14276>>>        
14276>>>        ServiceErrorType[] sets
14276>>>        ServiceErrorType[] sets
14277>>>        Get pServicesCustomErrorTypes to sets
14278>>>        Move (SizeOfArray(sets)-1) to sets_size
14279>>>        
14279>>>        Get pvStructs to vStructs
14280>>>        Get InterfaceTypeDefinitions of hoWS "ns" "http://tempuri.org" to sTypesXML
14281>>>        
14281>>>        Get Create U_cXMLDOMDocument to hoXML
14282>>>        Get LoadXML of hoXML sTypesXML to bRetval
14283>>>        If (bRetval) Begin
14285>>>                Set psSelectionNamespaces of hoXML to "xmlns:ns='http://tempuri.org'"
14286>>>            Get DocumentElement of hoXML to hoRoot
14287>>>            Get ElementNodes of hoRoot "ns:struct" to hoBaseStructs
14288>>>            Get NodeListLength of hoBaseStructs to iStructNodeListLength
14289>>>            
14289>>>            While (iStructNode < iStructNodeListLength and iStructNodeListLength > 0)
14293>>>                Get CollectionNode of hoBaseStructs iStructNode to hoStructNode
14294>>>                Get AttributeValue of hoStructNode "name" to sStructName
14295>>>
14295>>>                Get ProcessType hoBaseStructs hoStructNode (&vStructs) hoEvoInterface hoStructBuilder hoTypeBuilder to vStruct
14296>>>                
14296>>>                For cnt from 0 to sets_size
14302>>>>
14302>>>                    If (uppercase(sets[cnt].customErrorStructName) = uppercase(sStructName)) Move vStruct to sets[cnt].errorStruct
14305>>>                Loop
14306>>>>
14306>>>
14306>>>                Increment iStructNode    
14307>>>            Loop
14308>>>>
14308>>>        End
14308>>>>
14308>>>        Set pServicesCustomErrorTypes to sets
14309>>>        Set pvStructs to vStructs
14310>>>        
14310>>>        Function_Return vStructs
14311>>>    End_Function
14312>>>    
14312>>>    Function CreateErrorStructure Handle hoStructBuilder Handle hoTypeBuilder Handle hoEvoInterface Returns Variant
14314>>>        Variant vStruct
14314>>>        Set pvComObject of hoStructBuilder to (ComNewStruct(hoEvoInterface))
14315>>>        
14315>>>        Send ComAddField of hoStructBuilder 1 "Unhandled"   "" (ComCreateBool(hoTypeBuilder)) True
14316>>>        Send ComAddField of hoStructBuilder 2 "ErrorNumber" "" (ComCreateInt32(hoTypeBuilder)) True
14317>>>        Send ComAddField of hoStructBuilder 3 "LineNumber"  "" (ComCreateInt32(hoTypeBuilder)) True
14318>>>        Send ComAddField of hoStructBuilder 4 "IsCritical"  "" (ComCreateBool(hoTypeBuilder)) True
14319>>>        Send ComAddField of hoStructBuilder 5 "Value"       "" (ComCreateString(hoTypeBuilder)) True
14320>>>        Send ComAddField of hoStructBuilder 6 "Description" "" (ComCreateString(hoTypeBuilder)) False
14321>>>        Send ComAddField of hoStructBuilder 7 "Caption"     "" (ComCreateString(hoTypeBuilder)) False
14322>>>        Send ComAddField of hoStructBuilder 8 "CallStack"   "" (ComCreateList(hoTypeBuilder, ComCreateString(hoTypeBuilder))) False
14323>>>        
14323>>>        Function_Return (ComCreateStruct(hoStructBuilder, "ErrorData", ""))
14324>>>    End_Function
14325>>>    
14325>>>    // Event
14325>>>    Procedure OnPreSimpleServerStart Handle hoSettings
14327>>>    End_Procedure
14328>>>    
14328>>>    Procedure StartServer Boolean bSimpleServer
14330>>>        Handle hoEvoInterface hoServiceBuilder hoStructBuilder hoTypeBuilder
14330>>>        Handle hoPrototype hoStruct hoServer hoService hoServiceRuntime hoEvoService 
14330>>>        Handle[] services
14331>>>        Variant vServicesCollection vErrorStruct
14331>>>        Handle hoServicesCollection
14331>>>        Handle hoTimer
14331>>>        Handle hoSettings
14331>>>        Variant vSettings
14331>>>        Variant[][] vStructs
14332>>>        String sCurrDir
14332>>>        Integer iter
14332>>>        ServiceErrorType[] sets
14332>>>        ServiceErrorType[] sets
14333>>>        Integer sets_size
14333>>>        Integer cnt
14333>>>        Variant vAppliedErrorStruct
14333>>>        
14333>>>        // So the ErrorSystem class has this nasty bug/feature where it overwrites Error_Object_Id
14333>>>        // during construct_object...so anytime another error object is instantiated it replaces
14333>>>        // the prior error object. Because this is taking place in a procedure that MUST be forwarded
14333>>>        // we can't fix the behaviour in our subclass. Most developers probably don't care about it,
14333>>>        // but in our case we DON'T want our error class to kick in until Evolution has been
14333>>>        // start successfully. We want startup errors to use the standard error handler. So, after
14333>>>        // creating our error object and putting it in the property above, we reset the error
14333>>>        // object back to the standard one.
14333>>>        Move Error_Info_Object to Error_Object_Id        
14334>>>        
14334>>>        Get Create U_cComEvoInterface to hoEvoInterface
14335>>>        Send CreateComObject of hoEvoInterface
14336>>>
14336>>>        Get Create U_cComIEvoServiceBuilder to hoServiceBuilder
14337>>>        Get Create U_cComIEvoStructBuilder to hoStructBuilder
14338>>>        Get Create U_cComIEvoTypeBuilder to hoTypeBuilder
14339>>>        Set pvComObject of hoTypeBuilder to (ComNewType(hoEvoInterface))
14340>>>        
14340>>>        // We add a timer so that the GetMessage loop down below doesn't hang indefinitely and 
14340>>>        // we get a chance to check for things that should cause the app to quit.
14340>>>//#IF (!@ > 179)
14340>>>        Get Create U_cTimer to hoTimer
14341>>>        Set piTimeout of hoTimer to 2
14342>>>        Set pbEnabled of hoTimer to True
14343>>>//#ENDIF
14343>>>
14343>>>        // Because the error structure isn't "used" by any call, the code used to analyze a structure won't
14343>>>        // work here since DF doesn't know about this structure via the BaseWebService class. So instead
14343>>>        // we have to describe the structure defined at the top of this file.
14343>>>        Get CreateErrorStructure hoStructBuilder hoTypeBuilder hoEvoInterface to vErrorStruct
14344>>>        
14344>>>        // We now add this to our list of structs because custom error structs will most likely
14344>>>        // embed an ErrorData struct (although not technically required). By adding it here, when
14344>>>        // ProcessType is called and recursively analyzes other structs, if those structs include
14344>>>        // ErrorData, they won't try to add another copy of it causing an error.
14344>>>        Move "ErrorData" to vStructs[0][(SizeOfArray(vStructs[0]))]
14345>>>        Move vErrorStruct to vStructs[1][(SizeOfArray(vStructs[1]))]
14346>>>        Set pvStructs to vStructs
14347>>>            
14347>>>        Get phoServices to services
14348>>>        For iter from 0 to (SizeOfArray(services)-1)
14354>>>>
14354>>>            Move services[iter] to hoEvoService
14355>>>            
14355>>>            Send CreateComObject of hoEvoService
14356>>>            
14356>>>            Set pvComObject of hoServiceBuilder to (ComNewService(hoEvoInterface))
14357>>>            Send ProcessInterfaces of services[iter] hoEvoInterface hoServiceBuilder hoStructBuilder hoTypeBuilder
14358>>>            Get Create U_cComIEvoService to hoService
14359>>>            
14359>>>            // If we have a custom error structure, make sure to use it
14359>>>            Get pServicesCustomErrorTypes to sets
14360>>>            Move (SizeOfArray(sets)-1) to sets_size
14361>>>            Move vErrorStruct to vAppliedErrorStruct
14362>>>            For cnt from 0 to sets_size
14368>>>>
14368>>>                If (sets[cnt].serviceName = psServiceName(hoEvoService)) Move sets[cnt].errorStruct to vAppliedErrorStruct
14371>>>            Loop
14372>>>>
14372>>>            
14372>>>            Set pvComObject of hoService to (ComCreateServiceWithCustomExceptionData(hoServiceBuilder, psServiceName(hoEvoService), "", vAppliedErrorStruct))
14373>>>
14373>>>            Send RegisterDynamicEvents of hoEvoService          
14374>>>
14374>>>            Set ComService of hoEvoService to (pvComObject(hoService))
14375>>>            If (iter = 0) Begin
14377>>>                Get ComWrap of hoEvoService to vServicesCollection
14378>>>                Get Create U_cComIEvoServiceRuntimeCollection to hoServicesCollection
14379>>>                Set pvComObject of hoServicesCollection to vServicesCollection
14380>>>            End
14380>>>>
14380>>>            Else Begin
14381>>>                Send ComAdd of hoServicesCollection (pvComObject(hoEvoService))
14382>>>            End
14382>>>>
14382>>>            
14382>>>            Send ReleaseComObject of hoServiceBuilder
14383>>>        Loop
14384>>>>
14384>>>        
14384>>>        Send ReleaseComObject of hoTypeBuilder
14385>>>        Send ReleaseComObject of hoStructBuilder
14386>>>        Send ReleaseComObject of hoEvoInterface
14387>>>        
14387>>>        If (IsDebuggerPresent()) Begin
14389>>>            If (num_arguments = 1 AND bSimpleServer) Begin
14391>>>                Get Create U_cComEvoSimpleServer to hoServer
14392>>>                Send CreateComObject of hoServer
14393>>>                Get ComSettings of hoServer to vSettings
14394>>>                Get Create U_cComIEvoSimpleServerSettings to hoSettings
14395>>>                Set pvComObject of hoSettings to vSettings
14396>>>                
14396>>>                Set ComIncomingJwtConfigurations of hoSettings to "none"
14397>>>                Set ComOutgoingJwtConfiguration of hoSettings to "none"
14398>>>                Set ComTcpPort of hoSettings to 8080
14399>>>                Set ComServerProtocol of hoSettings to OLEEVO_JSON_RPC
14400>>>                Set ComServerTransport of hoSettings to OLEEVO_TRANSPORT_HTTP
14401>>>                Set ComLocalizeDatetime of hoSettings to True
14402>>>                Set ComStringEncoding of hoSettings to OLEEVO_ENCODING_ANSI
14403>>>                
14403>>>                Send OnPreSimpleServerStart hoSettings
14404>>>                Send ComStart of hoServer (pvComObject(hoServicesCollection)) OLEEVO_RECORDS_AND_ARRAYS
14405>>>            End
14405>>>>
14405>>>            Else Begin
14406>>>                Get Create U_cComEvoConsoleConnection to hoServer
14407>>>                Send CreateComObject of hoServer
14408>>>                Send ComConnect of hoServer (pvComObject(hoServicesCollection)) OLEEVO_RECORDS_AND_ARRAYS
14409>>>            End
14409>>>>
14409>>>        End
14409>>>>
14409>>>        Else Begin
14410>>>            Send Ignore_Error of Error_Object_Id 4399
14411>>>            Get Create U_cComEvoDispatchConnection to hoServer
14412>>>            Send CreateComObject of hoServer
14413>>>            
14413>>>            Send ComConnect of hoServer (pvComObject(hoServicesCollection)) OLEEVO_RECORDS_AND_ARRAYS
14414>>>            If ((Err) and LastErr = 4399) Begin
14416>>>                Get Create U_cComEvoConsoleConnection to hoServer
14417>>>                Send CreateComObject of hoServer
14418>>>                Send ComConnect of hoServer (pvComObject(hoServicesCollection)) OLEEVO_RECORDS_AND_ARRAYS
14419>>>            End
14419>>>>
14419>>>            Send Trap_Error of Error_Object_Id 4399
14420>>>        End
14420>>>>
14420>>>        
14420>>>        Set phoServer to hoServer
14421>>>        Set phOldErrorObject to Error_Object_Id
14422>>>        Move (phoErrorSys(Self)) to Error_Object_Id
14423>>>
14423>>>        // We have to run our own message loop so that DF stays running. Pretty standard stuff here...GetMessage 
14423>>>        // will pause waiting for something to come in and then do the standard Translate->Dispatch cycle and go 
14423>>>        // back to sleep.
14423>>>        tMSG msg
14423>>>        tMSG msg
14423>>>        Move 0 to msg.hwnd
14424>>>        Integer retval
14424>>>        Integer ticks elapsed_ticks
14424>>>        Move 0 to ticks
14425>>>        
14425>>>        While (True)
14429>>>            Move (GetMessage(AddressOf(msg), 0, 0, 0)) to retval
14430>>>            If (retval > 0) Begin
14432>>>                Move ((GetTickCount()) - ticks) to elapsed_ticks
14433>>>                If ((elapsed_ticks > 1500) or elapsed_ticks < 0) Begin
14435>>>                    Move (GetTickCount()) to ticks
14436>>>                    If (not(ComIsConnected(hoServer))) Begin
14438>>>                        Abort
14439>>>>
14439>>>                    End
14439>>>>
14439>>>                End
14439>>>>
14439>>>                Move (TranslateMessage(AddressOf(msg))) to windowindex
14440>>>                Move (DispatchMessage(AddressOf(msg))) to windowindex
14441>>>            End
14441>>>>
14441>>>            Else Abort
14443>>>        Loop
14444>>>>
14444>>>        
14444>>>        Abort
14445>>>>
14445>>>    End_Procedure
14446>>>    
14446>>>    Function JWTPayload Returns Variant
14448>>>        Variant vRuntime vPayload
14448>>>        Handle hoRuntime hoEvoService
14448>>>        Handle[] services
14449>>>        Integer iter
14449>>>        String stokenJWS
14449>>>                
14449>>>        // Search the Service which has the active JWT
14449>>>        Get phoServices to services
14450>>>        For iter from 0 to (SizeOfArray(services)-1)
14456>>>>
14456>>>            Move services[iter] to hoEvoService
14457>>>
14457>>>            Get ComRuntime of hoEvoService to vRuntime
14458>>>            Get Create U_cComIEvoRuntime to hoRuntime
14459>>>            Set pvComObject of hoRuntime to vRuntime
14460>>>            
14460>>>            // Look first for JWS
14460>>>            Move "" to stokenJWS
14461>>>            Get ComJWS of hoRuntime to stokenJWS
14462>>>            If (stokenJWS <> "") Begin
14464>>>                // Retrieve JWT and return
14464>>>                Get ComJWT of hoRuntime to vPayload
14465>>>                Move (SizeOfArray(services)) to iter
14466>>>            End
14466>>>>
14466>>>
14466>>>            Set pvComObject of hoRuntime to (NullComObject())
14467>>>            Send Destroy_Object of hoRuntime
14468>>>        Loop                                                       
14469>>>>
14469>>>                        
14469>>>        Function_Return vPayload
14470>>>    End_Function
14471>>>                        
14471>>>    Function JWSPayload Returns Variant
14473>>>        Variant vRuntime
14473>>>        Handle hoRuntime hoEvoService
14473>>>        Handle[] services
14474>>>        Integer iter
14474>>>        String sPayload
14474>>>                
14474>>>        // Search the Service which has the active JWT                
14474>>>        Get phoServices to services
14475>>>        For iter from 0 to (SizeOfArray(services)-1)
14481>>>>
14481>>>            Move services[iter] to hoEvoService
14482>>>
14482>>>            Get ComRuntime of hoEvoService to vRuntime
14483>>>            Get Create U_cComIEvoRuntime to hoRuntime
14484>>>            Set pvComObject of hoRuntime to vRuntime
14485>>>            
14485>>>            // Retrieve JWS and return            
14485>>>            Move "" to sPayload
14486>>>            Get ComJWS of hoRuntime to sPayload
14487>>>            If (sPayload <> "") Begin
14489>>>                Move (SizeOfArray(services)) to iter
14490>>>            End
14490>>>>
14490>>>
14490>>>            Set pvComObject of hoRuntime to (NullComObject())
14491>>>            Send Destroy_Object of hoRuntime
14492>>>        Loop                                                       
14493>>>>
14493>>>                        
14493>>>        Function_Return sPayload
14494>>>    End_Function
14495>>>       
14495>>>    Procedure Heartbeat
14497>>>        Variant vRuntime
14497>>>        Handle hoRuntime hoEvoService
14497>>>        Handle[] services
14498>>>        
14498>>>        Get phoServices to services
14499>>>        Move services[0] to hoEvoService
14500>>>        Get ComRuntime of hoEvoService to vRuntime
14501>>>        Get Create U_cComIEvoRuntime to hoRuntime
14502>>>        Set pvComObject of hoRuntime to vRuntime            
14503>>>        
14503>>>        Send ComHeartBeat of hoRuntime
14504>>>
14504>>>        Set pvComObject of hoRuntime to (NullComObject())
14505>>>        Send Destroy_Object of hoRuntime        
14506>>>    End_Procedure
14507>>>    
14507>>>    Procedure Set pbErrorsIncludeStackTrace Boolean bValue
14509>>>        Handle hoErrorSys
14509>>>        
14509>>>        Get phoErrorSys to hoErrorSys
14510>>>        Set pbErrorsIncludeStackTrace of hoErrorSys to bValue
14511>>>    End_Procedure
14512>>>    
14512>>>    Function pbErrorsIncludeStackTrace Returns Boolean
14514>>>        Handle hoErrorSys
14514>>>        
14514>>>        Get phoErrorSys to hoErrorSys
14515>>>        Function_Return (pbErrorsIncludeStackTrace(hoErrorSys))
14516>>>    End_Function
14517>>>End_Class
14518>
14518>Object oApplication is a cApplication
14520>    Set pbPreserveEnvironment to False
14521>End_Object
14522>
14522>Object oThriftly is a cThriftlyServer
14524>    Use PrimitivesService.pkg
Including file: PrimitivesService.pkg    (C:\Users\marce\OneDrive\Documentos\Thriftly Developer\Dataflex\Library_x64\AppSrc\PrimitivesService.pkg)
14524>>>Use cThriftlyService.pkg
14524>>>
14524>>>Struct token
14524>>>    DateTime expires_at
14524>>>    Integer level
14524>>>End_Struct
14524>>>
14524>>>Object oTestPrimitives is a cThriftlyService
14526>>>    Set psServiceName to "Primitives"
14527>>>    
14527>>>    Function LoginUser String user_name String password Returns token
#REM SEND REGISTERINTERFACE |CI5452 "get_LoginUser" "String user_name String password Returns token" ""
14531>>>        token toke
14531>>>        token toke
14531>>>        TimeSpan expir
14531>>>        If (lowercase(user_name) = "thriftly" and lowercase(password) = "thriftly") Begin
14533>>>            Move (DateSetMinute(expir, 30)) to expir
14534>>>            Move (CurrentDateTime() + expir) to toke.expires_at
14535>>>            Move 4 to toke.level
14536>>>            Function_Return toke
14537>>>        End
14537>>>>
14537>>>        Else Error 300 'You are not authorized! Try "thriftly" for the username and password.'
14539>>>    End_Function
14540>>>    
14540>>>    Function AuthMethod Integer iMethodID String sMethodName token toke Returns token
#REM SEND REGISTERINTERFACE |CI5453 "get_AuthMethod" "Integer iMethodID String sMethodName token toke Returns token" ""
14544>>>        TimeSpan expir
14544>>>        If (CurrentDateTime() < toke.expires_at) Begin
14546>>>            Move (DateSetMinute(expir, 30)) to expir
14547>>>            Move (CurrentDateTime() + expir) to toke.expires_at
14548>>>            Function_Return toke
14549>>>        End
14549>>>>
14549>>>        Else Error 300 "Your login has expired, please login again."
14551>>>    End_Function
14552>>>    
14552>>>    Function AddStrings String first_str String second_str Returns String
#REM SEND REGISTERINTERFACE |CI5454 "get_AddStrings" "String first_str String second_str Returns String" ""
14556>>>        token toke
14556>>>        token toke
14556>>>        Get JWTPayload to toke
14557>>>        
14557>>>        If (toke.level >= 4) Begin
14559>>>            Function_Return (first_str + second_str)
14560>>>        End
14560>>>>
14560>>>        Else Error 300 (SFormat("Sorry, this function requires level %1 access, you only have level %2 access", 4, toke.level))
14562>>>    End_Function
14563>>>
14563>>>    Function XOR Boolean first_bool Boolean second_bool Returns Boolean
#REM SEND REGISTERINTERFACE |CI5455 "get_XOR" "Boolean first_bool Boolean second_bool Returns Boolean" ""
14567>>>        Function_Return ((first_bool and not(second_bool)) or (not(first_bool) and second_bool))             
14568>>>    End_Function
14569>>>
14569>>>    Function AddChars UChar first_char UChar second_char Returns UChar
#REM SEND REGISTERINTERFACE |CI5456 "get_AddChars" "UChar first_char UChar second_char Returns UChar" ""
14573>>>        Function_Return (first_char + second_char)
14574>>>    End_Function
14575>>>    
14575>>>    Function AddShorts Short first_short Short second_short Returns Short
#REM SEND REGISTERINTERFACE |CI5457 "get_AddShorts" "Short first_short Short second_short Returns Short" ""
14579>>>        Function_Return (first_short + second_short)
14580>>>    End_Function
14581>>>
14581>>>    Function AddIntegers Integer first_int Integer second_int Returns Integer
#REM SEND REGISTERINTERFACE |CI5458 "get_AddIntegers" "Integer first_int Integer second_int Returns Integer" ""
14585>>>        Function_Return (first_int + second_int)
14586>>>    End_Function
14587>>>
14587>>>    Function AddBigInts BigInt first_bigint BigInt second_bigint Returns BigInt
#REM SEND REGISTERINTERFACE |CI5459 "get_AddBigInts" "BigInt first_bigint BigInt second_bigint Returns BigInt" ""
14591>>>        Function_Return (first_bigint + second_bigint)
14592>>>    End_Function
14593>>>
14593>>>    Function AddNumbers Number first_number Number second_number Returns Number
#REM SEND REGISTERINTERFACE |CI5460 "get_AddNumbers" "Number first_number Number second_number Returns Number" ""
14597>>>        Function_Return (first_number + second_number)
14598>>>    End_Function
14599>>>    
14599>>>    Function AddDaysToDate Date start_date Integer num_days Returns Date
#REM SEND REGISTERINTERFACE |CI5461 "get_AddDaysToDate" "Date start_date Integer num_days Returns Date" ""
14603>>>        Function_Return (start_date + num_days)
14604>>>    End_Function
14605>>>    
14605>>>    Function AddMilliSecondsToDateTime DateTime start_datetime BigInt milliseconds Returns DateTime
#REM SEND REGISTERINTERFACE |CI5462 "get_AddMilliSecondsToDateTime" "DateTime start_datetime BigInt milliseconds Returns DateTime" ""
14609>>>        Function_Return (start_datetime + (cast(milliseconds, number)/1000.0))
14610>>>    End_Function
14611>>>End_Object
14612>    Use ArraysService.pkg
Including file: ArraysService.pkg    (C:\Users\marce\OneDrive\Documentos\Thriftly Developer\Dataflex\Library_x64\AppSrc\ArraysService.pkg)
14612>>>Use cThriftlyService.pkg
14612>>>Use set.pkg
Including file: set.pkg    (C:\Program Files\DataFlex 26.0\Pkg\set.pkg)
14612>>>>>Use VDFBase.pkg
14612>>>>>
14612>>>>>Class Set is an ARRAY
14613>>>>>    
14613>>>>>    Function Find_Element String ElemStr Returns Integer
14615>>>>>        Integer ndx retVal ArrMax
14615>>>>>        String ArrVal
14615>>>>>        Get item_count to ArrMax
14616>>>>>        Move -1 to retVal
14617>>>>>        Move 0 to ndx
14618>>>>>        While (ndx < ArrMax and retVal = -1)
14622>>>>>            Get array_value  ndx to ArrVal
14623>>>>>            If (ArrVal = ElemStr) ;                Move ndx to retVal
14626>>>>>            Move (ndx + 1) to ndx
14627>>>>>        loop
14628>>>>>>
14628>>>>>        Function_Return retVal
14629>>>>>    End_Function
14630>>>>>    
14630>>>>>    Procedure Add_Element String Elem_Str Returns Integer
14632>>>>>        Integer Ret_Val
14632>>>>>        
14632>>>>>        Get Find_Element Elem_Str to Ret_Val
14633>>>>>        
14633>>>>>        If (Ret_Val < 0) ;            Get Item_Count to Ret_Val
14636>>>>>        
14636>>>>>        Set Array_Value  Ret_Val to Elem_Str
14637>>>>>        
14637>>>>>        Procedure_Return Ret_Val
14638>>>>>    End_Procedure
14639>>>>>    
14639>>>>>    Procedure Remove_Element String sElement
14641>>>>>        Integer iIndex
14641>>>>>        Get Find_Element sElement to iIndex
14642>>>>>        If (iIndex > -1) ;            Send delete_item iIndex
14645>>>>>    End_Procedure
14646>>>>>    
14646>>>>>    
14646>>>>>End_Class
14647>>>>>
14647>>>>>//
14647>>>>>// global function to create set instances at random
14647>>>>>//
14647>>>>>Function make_set for cDesktop Returns Integer
14649>>>>>    Integer retval
14649>>>>>    Object SetTemplate is a Set
14651>>>>>        Move Self to retval
14652>>>>>    End_Object
14653>>>>>    Function_Return retval
14654>>>>>End_Function
14655>>>>>
14655>>>>>
14655>>>>>
14655>>>
14655>>>// ===========================================================================
14655>>>//
14655>>>// The ROUND_NUMBER global function has been designed to return the rounded
14655>>>// value of a given 'numeric' argument at a specified rounding precision.
14655>>>//
14655>>>// The function requires two arguments, as follows:-
14655>>>//
14655>>>// (a) The numeric value to be rounded, where the range of valid values is
14655>>>//     +/- 99,999,999,999,999.99999999.
14655>>>//
14655>>>// (b) The rounding precision required.  This must be an integer value in the
14655>>>//     range -13 to +8.  If a value outside this range is used, the nearest
14655>>>//     threshold value is substituted.
14655>>>//
14655>>>//     Values in the range +1 to +7 perform rounding on the decimal part of
14655>>>//     the number.  A value of +8 will perform no rounding at all.  A zero
14655>>>//     value will round to the nearest whole number.  Values -1 to -13 will
14655>>>//     round progressively to the left of the decimal point (a frequent
14655>>>//     requirement in financial reporting).
14655>>>//
14655>>>// If the result of the rounding produces a value outside the valid numeric
14655>>>// range (+/- 99,999,999,999,999.99999999) then a zero value is returned.
14655>>>//
14655>>>// Assumptions:-  The only assumptions made have been that the range of
14655>>>// numeric values and the limit of eight decimal places are unlikely to change
14655>>>// in the forseeable future.
14655>>>//
14655>>>// Examples:-
14655>>>//
14655>>>//  1st Argument      2nd Argument   Return Value
14655>>>//  ------------      ------------   ------------
14655>>>//  123456.87654321         8         123456.87654321
14655>>>//  123456.87654321         2         123456.88
14655>>>// -123456.87654321         2        -123456.88
14655>>>//  123456.98765432         0         123457
14655>>>// -123456.98765432        -1        -123460
14655>>>//  123456.98765432        -2         123500
14655>>>//  123456.98765432        -3         123000
14655>>>//  987654                 -4         990000
14655>>>//  987654                 -5        1000000
14655>>>//  987654                 -6        1000000
14655>>>//  987654                 -7              0
14655>>>//
14655>>>// ===========================================================================
14655>>>
14655>>>
14655>>> Function Round_Number Global Number nVal Integer iRnd Returns Number
14657>>>   // If the rounding precision falls in the range -5 to +8, then return:-
14657>>>   If (iRnd >= -5) Function_Return ;   (Number(Abs(nVal) / nVal) * 0.5 / (Number(10 ^ (iRnd min 8))) + nVal ;     / (Number(10 ^ (8 - (iRnd min 8)))) * (Number(10 ^ (8 - (iRnd min 8)))))
14660>>>   // Else, where the rounding precision is in the range -6 to -13, return:-
14660>>>   Function_Return ;     (Number(Abs(nVal) / nVal) * 0.5 * (Number(10 ^ (Abs(iRnd) min 13))) ;       + nVal / (Number(10 ^ 13)) / (Number(10 ^ ((Abs(iRnd) - 5) min 8))) ;         * (Number(10 ^ 13)) * (Number(10 ^ ((Abs(iRnd) - 5) min 8))))
14661>>> End_Function
14662>>> 
14662>>>Object oTestArrays is a cThriftlyService
14664>>>    Set psServiceName to "Arrays"
14665>>>
14665>>>    Function SubtractFirstFromSecond String[] first_str_array String[] second_str_array Returns String[]
#REM SEND REGISTERINTERFACE |CI5467 "get_SubtractFirstFromSecond" "String[] first_str_array String[] second_str_array Returns String[]" ""
14669>>>        Integer cnt i
14669>>>        Move (SizeOfArray(first_str_array)) to cnt
14670>>>        
14670>>>        For i from 0 to (cnt-1)
14676>>>>
14676>>>            Move (RemoveFromArray(second_str_array, SearchArray(first_str_array[i], second_str_array))) to second_str_array
14677>>>        Loop
14678>>>>
14678>>>        Function_Return second_str_array
14679>>>    End_Function
14680>>>
14680>>>    Function BitFlipper Boolean[] bits Returns Boolean[]
#REM SEND REGISTERINTERFACE |CI5468 "get_BitFlipper" "Boolean[] bits Returns Boolean[]" ""
14684>>>        Integer cnt i
14684>>>        Move (SizeOfArray(bits)) to cnt
14685>>>        
14685>>>        For i from 0 to (cnt-1)
14691>>>>
14691>>>            Move (not(bits[i])) to bits[i]
14692>>>        Loop
14693>>>>
14693>>>        Function_Return bits
14694>>>    End_Function
14695>>>
14695>>>    Function NegateShortArray Short[] shorts Returns Short[]
#REM SEND REGISTERINTERFACE |CI5469 "get_NegateShortArray" "Short[] shorts Returns Short[]" ""
14699>>>        Integer cnt i
14699>>>        Move (SizeOfArray(shorts)) to cnt
14700>>>        
14700>>>        For i from 0 to (cnt-1)
14706>>>>
14706>>>            Move (-1 * shorts[i]) to shorts[i]
14707>>>        Loop
14708>>>>
14708>>>        Function_Return shorts
14709>>>    End_Function
14710>>>
14710>>>    Function AddIntegerArrays Integer[] first_int_array Integer[] second_int_array Returns Integer[]
#REM SEND REGISTERINTERFACE |CI5470 "get_AddIntegerArrays" "Integer[] first_int_array Integer[] second_int_array Returns Integer[]" ""
14714>>>        Integer cnt i
14714>>>        Move (ResizeArray(first_int_array, (SizeOfArray(first_int_array) max SizeOfArray(second_int_array)))) to first_int_array
14715>>>        Move (ResizeArray(second_int_array, (SizeOfArray(first_int_array) max SizeOfArray(second_int_array)))) to second_int_array
14716>>>        Move (SizeOfArray(first_int_array)) to cnt
14717>>>        
14717>>>        For i from 0 to (cnt-1)
14723>>>>
14723>>>            Move (first_int_array[i] + second_int_array[i]) to first_int_array[i]
14724>>>        Loop
14725>>>>
14725>>>        Function_Return first_int_array
14726>>>    End_Function
14727>>>
14727>>>    Function SetOfIntegers Integer[] first_int_array Integer[] second_int_array Returns Integer[]
#REM SEND REGISTERINTERFACE |CI5471 "get_SetOfIntegers" "Integer[] first_int_array Integer[] second_int_array Returns Integer[]" ""
14731>>>        Handle hoSet
14731>>>        Integer cnt i
14731>>>
14731>>>        Get Create U_Set to hoSet
14732>>>
14732>>>        Move (SizeOfArray(first_int_array)) to cnt
14733>>>        For i from 0 to (cnt-1)
14739>>>>
14739>>>            Send add_element of hoSet first_int_array[i]
14740>>>        Loop
14741>>>>
14741>>>        
14741>>>        Move (SizeOfArray(second_int_array)) to cnt
14742>>>        For i from 0 to (cnt-1)
14748>>>>
14748>>>            Send add_element of hoSet second_int_array[i]
14749>>>        Loop
14750>>>>
14750>>>        
14750>>>        Integer[] retval
14751>>>        Get Item_Count of hoSet to cnt
14752>>>        For i from 0 to (cnt-1)
14758>>>>
14758>>>            Get Value of hoSet i to retval[i]
14759>>>        Loop
14760>>>>
14760>>>        Function_Return retval
14761>>>    End_Function
14762>>>
14762>>>    Function AddBigIntArrays BigInt[] first_bigint_array BigInt[] second_bigint_array Returns BigInt[]
#REM SEND REGISTERINTERFACE |CI5472 "get_AddBigIntArrays" "BigInt[] first_bigint_array BigInt[] second_bigint_array Returns BigInt[]" ""
14766>>>        Integer cnt i
14766>>>        Move (ResizeArray(first_bigint_array, (SizeOfArray(first_bigint_array) max SizeOfArray(second_bigint_array)))) to first_bigint_array
14767>>>        Move (ResizeArray(second_bigint_array, (SizeOfArray(first_bigint_array) max SizeOfArray(second_bigint_array)))) to second_bigint_array
14768>>>        Move (SizeOfArray(first_bigint_array)) to cnt
14769>>>        
14769>>>        For i from 0 to (cnt-1)
14775>>>>
14775>>>            Move (first_bigint_array[i] + second_bigint_array[i]) to first_bigint_array[i]
14776>>>        Loop
14777>>>>
14777>>>        Function_Return first_bigint_array
14778>>>    End_Function
14779>>>
14779>>>    Function RoundReals Real[] numbers Integer[] decimal_places Returns Real[]
#REM SEND REGISTERINTERFACE |CI5473 "get_RoundReals" "Real[] numbers Integer[] decimal_places Returns Real[]" ""
14783>>>        Integer cnt i
14783>>>        Number nVal
14783>>>        Move (ResizeArray(decimal_places, SizeOfArray(numbers))) to decimal_places
14784>>>        Move (SizeOfArray(numbers)) to cnt
14785>>>        
14785>>>        For i from 0 to (cnt-1)
14791>>>>
14791>>>            If (decimal_places[i] < -13) Move -13 to decimal_places[i]
14794>>>            If (decimal_places[i] > 8) Move 8 to decimal_places[i]
14797>>>            
14797>>>            // For some reason Dataflex dies when I pass a value to round_number using the array
14797>>>            // so instead we move the value to a local var and it all works.
14797>>>            Move numbers[i] to nVal
14798>>>            Move (Round_Number(nVal, decimal_places[i])) to numbers[i]
14799>>>        Loop
14800>>>>
14800>>>        
14800>>>        Function_Return numbers
14801>>>    End_Function
14802>>>    
14802>>>    Function AddDaysToDates Date[] dates Integer[] num_days Returns Date[]
#REM SEND REGISTERINTERFACE |CI5474 "get_AddDaysToDates" "Date[] dates Integer[] num_days Returns Date[]" ""
14806>>>        Integer cnt i
14806>>>        Move (ResizeArray(num_days, SizeOfArray(dates))) to num_days
14807>>>        Move (SizeOfArray(dates)) to cnt
14808>>>        
14808>>>        For i from 0 to (cnt-1)
14814>>>>
14814>>>            Move (dates[i] + num_days[i]) to dates[i]
14815>>>        Loop
14816>>>>
14816>>>        
14816>>>        Function_Return dates
14817>>>    End_Function
14818>>>    
14818>>>    Function FindDateOfClosestDayOfWeek DateTime[] datetimes Integer[] day_of_week Returns DateTime[]
#REM SEND REGISTERINTERFACE |CI5475 "get_FindDateOfClosestDayOfWeek" "DateTime[] datetimes Integer[] day_of_week Returns DateTime[]" ""
14822>>>        Integer cnt i dow diff
14822>>>        Move (ResizeArray(day_of_week, SizeOfArray(datetimes))) to day_of_week
14823>>>        Move (SizeOfArray(datetimes)) to cnt
14824>>>
14824>>>        For i from 0 to (cnt-1)
14830>>>>
14830>>>            Move (DateGetDayOfWeek(datetimes[i])) to dow
14831>>>            Move (Abs(day_of_week[i])) to day_of_week[i]
14832>>>            Move (6 min day_of_week[i]) to day_of_week[i]
14833>>>            Move (day_of_week[i] - dow) to diff
14834>>>            If (diff < 0) Move (diff + 7) to diff
14837>>>            Move (datetimes[i]+diff) to datetimes[i]
14838>>>        Loop
14839>>>>
14839>>>        
14839>>>        Function_Return datetimes
14840>>>    End_Function
14841>>>    
14841>>>    Function ThriftlyLogo Returns UChar[]
#REM SEND REGISTERINTERFACE |CI5476 "get_ThriftlyLogo" "Returns UChar[]" ""
14845>>>        UChar[] file
14846>>>        
14846>>>        Direct_Input ("BINARY:" + GetApplicationPath(ghoApplication) + "\thriftly-logo-500.png")
14847>>>            Read_Block file -1
14848>>>        Close_Input
14849>>>        
14849>>>        Function_Return file    
14850>>>    End_Function
14851>>>End_Object
14852>>>    
14852>    Use StructsService.pkg
Including file: StructsService.pkg    (C:\Users\marce\OneDrive\Documentos\Thriftly Developer\Dataflex\Library_x64\AppSrc\StructsService.pkg)
14852>>>Use cThriftlyService.pkg
14852>>>
14852>>>Struct tAllPrimitives
14852>>>    Boolean bool_val
14852>>>    Char char_val
14852>>>    Short short_val
14852>>>    Integer int_val
14852>>>    BigInt bigint_val
14852>>>    Number num_val
14852>>>    Date date_val
14852>>>    DateTime datetime_val
14852>>>    String string_val
14852>>>End_Struct
14852>>>
14852>>>Struct tPrimitiveArrays
14852>>>    Boolean[] bool_val
14852>>>    Short[] short_val
14852>>>    Integer[] int_val
14852>>>    BigInt[] bigint_val
14852>>>    Real[] num_val
14852>>>    Date[] date_val
14852>>>    DateTime[] datetime_val
14852>>>    String[] string_val
14852>>>End_Struct
14852>>>
14852>>>Struct tStructOfStructs
14852>>>    tAllPrimitives primitive
14852>>>    tAllPrimitives primitive
14852>>>    tPrimitiveArrays primitive_arrays
14852>>>    tPrimitiveArrays primitive_arrays
14852>>>End_Struct
14852>>>
14852>>>Object oTestStructs is a cThriftlyService
14854>>>    Set psServiceName to "Structs"
14855>>>
14855>>>    Function GetPrimitiveStruct Returns tAllPrimitives
#REM SEND REGISTERINTERFACE |CI5477 "get_GetPrimitiveStruct" "Returns tAllPrimitives" ""
14859>>>        tAllPrimitives prims
14859>>>        tAllPrimitives prims
14859>>>        DateTime dtNow
14859>>>        Move (CurrentDateTime()) to dtNow
14860>>>        Move (Random(1)) to prims.bool_val
14861>>>        Move (DateGetSecond(dtNow)) to prims.char_val
14862>>>        Move (DateGetDayOfYear(dtNow)) to prims.short_val
14863>>>        Move ((DateGetDayOfYear(dtNow) * 24 * 60 * 60) + (DateGetHour(dtNow) * 60 * 60) + (DateGetMinute(dtNow) * 60) + DateGetSecond(dtNow)) to prims.int_val
14864>>>        Move ((prims.int_val * 1000) + DateGetMillisecond(dtNow)) to prims.bigint_val
14865>>>        Move (Number(prims.int_val) + (Number(DateGetMillisecond(dtNow))/1000.0)) to prims.num_val
14866>>>        Move dtNow to prims.date_val
14867>>>        Move dtNow to prims.datetime_val
14868>>>        Move dtNow to prims.string_val
14869>>>        
14869>>>        Function_Return prims
14870>>>    End_Function
14871>>>    
14871>>>    Function TestPrimitiveStruct tAllPrimitives primitive_struct Returns tAllPrimitives
#REM SEND REGISTERINTERFACE |CI5478 "get_TestPrimitiveStruct" "tAllPrimitives primitive_struct Returns tAllPrimitives" ""
14875>>>        DateTime dtNow
14875>>>        Move (CurrentDateTime()) to dtNow
14876>>>        Move (not(primitive_struct.bool_val)) to primitive_struct.bool_val
14877>>>        Move (128 min (primitive_struct.char_val + Random(64))) to primitive_struct.char_val
14878>>>        Move (32767 min (primitive_struct.short_val + Random(8192))) to primitive_struct.short_val
14879>>>        Move (2147483647 min (primitive_struct.int_val + Random(536870912))) to primitive_struct.int_val
14880>>>        Move (primitive_struct.bigint_val * Random(256)) to primitive_struct.bigint_val
14881>>>        Move (primitive_struct.date_val + Random(30)) to primitive_struct.date_val
14882>>>        Move (dtNow + Random(365)) to primitive_struct.datetime_val
14883>>>        Move (String(dtNow + Random(365)) + " - " + primitive_struct.string_val) to primitive_struct.string_val
14884>>>        
14884>>>        Function_Return primitive_struct
14885>>>    End_Function
14886>>>    
14886>>>    Procedure MovePrimToArrElement tAllPrimitives prim tPrimitiveArrays ByRef primarr Integer i
14889>>>        Move (not(prim.bool_val)) to primarr.bool_val[i]
14890>>>        Move (prim.short_val+i) to primarr.short_val[i]
14891>>>        Move (prim.int_val+i) to primarr.int_val[i]
14892>>>        Move (prim.bigint_val+i) to primarr.bigint_val[i]
14893>>>        Move (prim.num_val+Number(i)) to primarr.num_val[i]
14894>>>        Move (prim.date_val+i) to primarr.date_val[i]
14895>>>        Move (prim.datetime_val) to primarr.datetime_val[i]
14896>>>        Move (prim.string_val + " i = " + String(i)) to primarr.string_val[i]
14897>>>    End_Function
14898>>>
14898>>>    Function GetPrimitiveArraysStruct Returns tPrimitiveArrays
#REM SEND REGISTERINTERFACE |CI5480 "get_GetPrimitiveArraysStruct" "Returns tPrimitiveArrays" ""
14902>>>        tPrimitiveArrays primarr
14902>>>        tPrimitiveArrays primarr
14902>>>        tAllPrimitives prim
14902>>>        tAllPrimitives prim
14902>>>        Integer i
14902>>>        
14902>>>        For i from 0 to 9
14908>>>>
14908>>>            Get GetPrimitiveStruct to prim
14909>>>            Send MovePrimToArrElement prim (&primarr) i
14910>>>        Loop
14911>>>>
14911>>>        Function_Return primarr
14912>>>    End_Function
14913>>>
14913>>>    Function GetStructOfStructs Returns tStructOfStructs
#REM SEND REGISTERINTERFACE |CI5481 "get_GetStructOfStructs" "Returns tStructOfStructs" ""
14917>>>        tStructOfStructs strofstr
14917>>>        tStructOfStructs strofstr
14917>>>        
14917>>>        Get GetPrimitiveStruct to strofstr.primitive
14918>>>        Get GetPrimitiveArraysStruct to strofstr.primitive_arrays
14919>>>        Function_Return strofstr
14920>>>    End_Function
14921>>>    
14921>>>    Function GetArrayOfStructs tAllPrimitives[] primitives Returns tAllPrimitives[]
#REM SEND REGISTERINTERFACE |CI5482 "get_GetArrayOfStructs" "tAllPrimitives[] primitives Returns tAllPrimitives[]" ""
14925>>>        tAllPrimitives[] prims
14925>>>        tAllPrimitives[] prims
14926>>>        Integer i
14926>>>        
14926>>>        For i from 0 to 9
14932>>>>
14932>>>            Get GetPrimitiveStruct to prims[i]
14933>>>        Loop
14934>>>>
14934>>>        
14934>>>        Function_Return prims
14935>>>    End_Function
14936>>>    
14936>>>    Function AddStrings String first_str String second_str Returns String
#REM SEND REGISTERINTERFACE |CI5454 "get_AddStrings" "String first_str String second_str Returns String" ""
14940>>>        token toke
14940>>>        token toke
14940>>>        Get JWTPayload to toke
14941>>>        
14941>>>        If (toke.level >= 3) Begin
14943>>>            Function_Return (first_str + second_str)
14944>>>        End
14944>>>>
14944>>>        Else Error 300 (SFormat("Sorry, this function requires level %1 access, you only have level %2 access", 3, toke.level))
14946>>>    End_Function    
14947>>>    
14947>>>    Function JWS Returns String
#REM SEND REGISTERINTERFACE |CI5483 "get_JWS" "Returns String" ""
14951>>>        token toke
14951>>>        token toke
14951>>>        String stoke
14951>>>        Get JWTPayload to toke
14952>>>        
14952>>>        If (toke.level >= 4) Begin
14954>>>            Get JWSPayload to stoke
14955>>>            Function_Return (stoke)
14956>>>        End
14956>>>>
14956>>>        Else Error 300 (SFormat("Sorry, this function requires level %1 access, you only have level %2 access", 4, toke.level))
14958>>>    End_Function   
14959>>>    
14959>>>    Function AuthMethod Integer iMethodID String sMethodName token toke Returns token
#REM SEND REGISTERINTERFACE |CI5453 "get_AuthMethod" "Integer iMethodID String sMethodName token toke Returns token" ""
14963>>>        TimeSpan expir
14963>>>        If (CurrentDateTime() < toke.expires_at) Begin
14965>>>            Move (DateSetMinute(expir, 30)) to expir
14966>>>            Move (CurrentDateTime() + expir) to toke.expires_at
14967>>>            Function_Return toke
14968>>>        End
14968>>>>
14968>>>        Else Error 300 "Your login has expired, please login again."
14970>>>    End_Function    
14971>>>    
14971>>>End_Object
14972>>>
14972>>>
14972>    Use ErrorsService.pkg
Including file: ErrorsService.pkg    (C:\Users\marce\OneDrive\Documentos\Thriftly Developer\Dataflex\Library_x64\AppSrc\ErrorsService.pkg)
14972>>>Use cThriftlyService.pkg
14972>>>
14972>>>Object oTestErrors is a cThriftlyService
14974>>>    Set psServiceName to "Errors"
14975>>>
14975>>>    Function ThrowInvalidExpression Returns String
#REM SEND REGISTERINTERFACE |CI5484 "get_ThrowInvalidExpression" "Returns String" ""
14979>>>        Move "This is a test" to WindowIndex
14980>>>        Function_Return ""
14981>>>    End_Function
14982>>>
14982>>>    Function ErrorCommand Returns String
#REM SEND REGISTERINTERFACE |CI5485 "get_ErrorCommand" "Returns String" ""
14986>>>        Error 411 "This is an error command."
14987>>>>
14987>>>        Function_Return ""
14988>>>    End_Function
14989>>>
14989>>>    Function ThrowServiceException Returns String
#REM SEND REGISTERINTERFACE |CI5486 "get_ThrowServiceException" "Returns String" ""
14993>>>        ErrorData exception
14993>>>        ErrorData exception
14993>>>
14993>>>        Move "This is an Error Description. The Value should be 'blah' and error number is 10000. Callstack will contain just the name of this function and line number is the line the exception was thrown on." to exception.Description
14994>>>        Move "Blah" to exception.Value
14995>>>        Move 10000 to exception.ErrorNumber
14996>>>        Move "The caption element is something Dataflex sometimes uses" to exception.Caption
14997>>>        Send ServiceException "This is the error message" exception                
14998>>>        Function_Return ""
14999>>>    End_Function
15000>>>End_Object
15001>>>
15001>>>
15001>    
15001>    // This event is only called when using the "Simple Server". This mode is activated by passing
15001>    // True as an additional parameter on the StartServer call. Most developers will never use this,
15001>    // but just in case, these are the settings you can adjust. The Developer Helper let's you do
15001>    // all of this graphically which is much easier.
15001>    Procedure OnPreSimpleServerStart Handle hoSettings
15004>//        Set ComIncomingJwtConfigurations of hoSettings to "none"
15004>//        Set ComOutgoingJwtConfiguration of hoSettings to "none"
15004>//        Set ComTcpPort of hoSettings to 8080
15004>//        Set ComServerProtocol of hoSettings to OLEEVO_JSON_RPC
15004>//        Set ComServerTransport of hoSettings to OLEEVO_TRANSPORT_HTTP
15004>//        Set ComLocalizeDatetime of hoSettings to True
15004>//        Set ComStringEncoding of hoSettings to OLEEVO_ENCODING_ANSI
15004>    End_Procedure
15005>End_Object
15006>
15006>Send StartServer of oThriftly
15007>
Summary
Memory Available: 36797468672
Total Warnings : 1
Total Errors   : 0
Total Symbols  : 13094
Total Resources: 0
Total Commands : 15006
Total Windows  : 0
Total Pages    : 0
Static Data    : 174329
Message area   : 84731
Total Blocks   : 7839
