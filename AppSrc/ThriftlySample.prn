Compiling Program: C:\Users\marce\OneDrive\Documentos\Thriftly Developer\Dataflex\Library_x64\AppSrc\ThriftlySample.src
Memory Available: 2147483646
1>Use Windows.pkg
Using pre-compiled package WINDOWS.PKG
Including file: windows.pkd    (C:\Program Files (x86)\DataFlex 19.1\Pkg\windows.pkd)
7602>Use cApplication.pkg
Including file: cApplication.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cApplication.pkg)
7602>>>Use Windows.pkg
7602>>>
7602>>>Use LanguageText.pkg
7602>>>Use WinUser.pkg
7602>>>Use WinShell.pkg
Including file: WinShell.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\WinShell.pkg)
7602>>>>>Use DLL.pkg
7602>>>>>
7602>>>>>External_Function PathFileExists "PathFileExistsA" shlwapi.dll ;    String sPath ;    Returns Integer // Boolean
7603>>>>>
7603>>>>>External_Function PathIsRelative "PathIsRelativeA" shlwapi.dll ;    String sPath ;    Returns Integer // Boolean
7604>>>>>
7604>>>>>External_Function PathRemoveExtension "PathRemoveExtensionA" shlwapi.dll ;    Address aPath ;    Returns Integer // void
7605>>>>>
7605>>>>>External_Function PathRemoveFileSpec "PathRemoveFileSpecA" shlwapi.dll ;    Address aPath ;    Returns Integer
7606>>>>>
7606>>>>>
7606>>>>>Define URL_UNESCAPE_INPLACE                    for |CI$00100000
7606>>>>>Define URL_ESCAPE_SEGMENT_ONLY                 for |CI$00002000
7606>>>>>
7606>>>>>External_Function UrlUnescape "UrlUnescapeA" shlwapi.dll;    Pointer pszURL;    Pointer pszUnescaped;    Pointer pcchUnescaped;    DWord dwFlags;    Returns Integer // S_OK if succesfull
7607>>>>>
7607>>>>>External_Function UrlEscape "UrlEscapeA" shlwapi.dll;    Pointer pszUrl;    Pointer pszEscaped;    Pointer pcchEscaped;    DWord dwFlags;    Returns Integer
7608>>>>>
7608>>>Use cWorkspace.pkg
Including file: cWorkspace.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cWorkspace.pkg)
7608>>>>>Use VdfBase.pkg
7608>>>>>Use tWinStructs.pkg
7608>>>>>Use LanguageText.pkg
7608>>>>>Use WinShell.pkg // Shell API functions
7608>>>>>Use seq_chnl.pkg
Including file: seq_chnl.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\seq_chnl.pkg)
7608>>>>>>>Use LanguageText.pkg
7608>>>>>>>Use VDFBase.pkg
Including file: errornum.inc    (C:\Program Files (x86)\DataFlex 19.1\Pkg\errornum.inc)
7608>>>>>>>>
7608>>>>>>>>//
7608>>>>>>>>// these will get defined in fmac
7608>>>>>>>>//
7608>>>>>>>>// already defined
7608>>>>>>>>//    #REPLACE DFERR_COMP_BAD_IMAGE_NAME                 |CI4293
7608>>>>>>>>//    #REPLACE DFERR_COMP_CONSTANT_EXPECTED              |CI4299
7608>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_RETURN_TYPE            |CI4310
7608>>>>>>>>//    #REPLACE DFERR_COMP_IMAGE_NOT_FOUND                |CI4311
7608>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_DATATYPE               |CI4315
7608>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_TYPE                   |CI4317
7608>>>>>>>>//    #REPLACE DFERR_COMP_MISSING_ARGUMENT               |CI4320
7608>>>>>>>>//    #REPLACE DFERR_COMP_MISSING_END_OBJECT             |CI4323
7608>>>>>>>>//    #REPLACE DFERR_COMP_UNDEFINED_SYMBOL_IN_ARGUMENT   |CI4328
7608>>>>>>>>//    #REPLACE DFERR_COMP_SYMBOL_ALREADY_DEFINED         |CI4332
7608>>>>>>>>//    #REPLACE DFERR_COMP_TOO_MANY_MESSAGES              |CI4339
7608>>>>>>>>//    #REPLACE DFERR_COMP_UNRESOVLED_CONTROL_BLOCK       |CI4348
7608>>>>>>>>// new compiler errors used by fmac
7608>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_OBJECT_DEFINTION       |CI4388 // object name used is not valid
7608>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_PROPERTY_DEFINTION     |CI4389 // property name cannot be used
7608>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_METHOD_DEFINTION       |CI4390 // method name cannot be used
7608>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_CODE_PLACEMENT         |CI4391 // Location of code, nesting, is wrong
7608>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_METHOD_SYNTAX          |CI4392 // syntax is incorrect for method definition
7608>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_MESSAGE_SYNTAX         |CI4393 // sysntax is incorrect for sending message
7608>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_OBJECT_REFERENCE       |CI4394 // object named in message is invalid
7608>>>>>>>>//    #REPLACE DFERR_COMP_OBSOLETE_UNSUPPORTED_FEATURE   |CI4395 // Obsolete - was 101 (Moveused by fmac)
7608>>>>>>>>//    #REPLACE DFERR_COMP_INVALID_ARGUMENT               |CI4396 // Agument in line is incorrect
7608>>>>>>>>//    #REPLACE DFERR_COMP_ILLEGAL_EXTERNAL_FUNCTION_DEFINITION |CI4397 // name cannot be used
7608>>>>>>>>//    #REPLACE DFERR_COMP_MISSING_DEBUG_INFORMATION      |CI4500 // debug information is not provided
7608>>>>>>>>//    #REPLACE DFERR_COMP_INCOMPATIBLE_DEBUG_INFORMATION |CI4501 // debug inforamtion is is not correct
7608>>>>>>>>//    #REPLACE DFERR_COMP_RECURSIVE_STRUCT_DECLARATION   |CI4513 // recursive struct definition
7608>>>>>>>>//    #REPLACE DFERR_COMP_AMBIGUOUS_SYNTAX               |CI4514 // either Left of "'[' is not array, use '(' if indicator" or "Left of '.' is not of type struct or table"
7608>>>>>>>>
7608>>>>>>>>
7608>>>>>>>>
7608>>>>>>>
7608>>>>>>>Define DF_SEQ_CHANNEL_NOT_AVAILABLE for -2
7608>>>>>>>Define DF_SEQ_CHANNEL_ERROR         for -1
7608>>>>>>>Define DF_SEQ_CHANNEL_MIN           for 0
7608>>>>>>>Define DF_SEQ_CHANNEL_MAX           for 9
7608>>>>>>>Define DF_SEQ_START_CHANNEL         for 2 // leave 0 and 1 til last
7608>>>>>>>// so that programs that use direct_input/output
7608>>>>>>>// w/o specifying a channel will work.
7608>>>>>>>Enum_List
7608>>>>>>>    Define DF_SEQ_CHANNEL_MODE_CLOSED
7608>>>>>>>    Define DF_SEQ_CHANNEL_MODE_OPEN
7608>>>>>>>    Define DF_SEQ_CHANNEL_MODE_OUTPUT
7608>>>>>>>    Define DF_SEQ_CHANNEL_MODE_INPUT
7608>>>>>>>End_Enum_List
7608>>>>>>>
7608>>>>>>>Enum_List
7608>>>>>>>    Define DF_SEQ_CHANNEL_ERROR_MODE_NONE
7608>>>>>>>    Define DF_SEQ_CHANNEL_ERROR_MODE_ALL
7608>>>>>>>End_Enum_List
7608>>>>>>>
7608>>>>>>>Integer Seq$Channel$Error$Mode
7608>>>>>>>
7608>>>>>>>Procedure Set Seq_Channel_Error_Mode Global Integer Mode
7610>>>>>>>    Move Mode to Seq$Channel$Error$Mode
7611>>>>>>>End_Procedure
7612>>>>>>>
7612>>>>>>>Function Seq_Channel_Error_Mode Global Returns Integer
7614>>>>>>>    Function_Return Seq$Channel$Error$Mode
7615>>>>>>>End_Function
7616>>>>>>>
7616>>>>>>>Object Seq_Channel_List is an Array
7618>>>>>>>    Procedure Initialize
7621>>>>>>>        Integer Itm
7621>>>>>>>        
7621>>>>>>>        Move DF_SEQ_CHANNEL_MIN to Itm
7622>>>>>>>        
7622>>>>>>>        While Itm LE DF_SEQ_CHANNEL_MAX
7626>>>>>>>            Set Array_Value  Itm to DF_SEQ_CHANNEL_MODE_CLOSED
7627>>>>>>>            Increment Itm
7628>>>>>>>        Loop
7629>>>>>>>>
7629>>>>>>>    End_Procedure
7630>>>>>>>    
7630>>>>>>>    Send Initialize
7631>>>>>>>End_Object
7632>>>>>>>
7632>>>>>>>Set Seq_Channel_Error_Mode to DF_SEQ_CHANNEL_ERROR_MODE_ALL
7633>>>>>>>
7633>>>>>>>Function Seq_Channel_Mode Global Integer Chnl Returns Integer
7635>>>>>>>    Function_Return (Integer_Value(Seq_Channel_List(Self), Chnl))
7636>>>>>>>End_Function
7637>>>>>>>
7637>>>>>>>Procedure Set Seq_Channel_Mode Global Integer Chnl Integer Mode
7639>>>>>>>    Set Array_Value of (Seq_Channel_List(Self))  Chnl to Mode
7640>>>>>>>End_Procedure
7641>>>>>>>
7641>>>>>>>Function Seq_New_Channel Global Returns Integer
7643>>>>>>>    Integer Obj Chnl
7643>>>>>>>    
7643>>>>>>>    Move DF_SEQ_START_CHANNEL to Chnl
7644>>>>>>>    
7644>>>>>>>    While Chnl LE DF_SEQ_CHANNEL_MAX
7648>>>>>>>        If (Seq_Channel_Mode(Chnl) = DF_SEQ_CHANNEL_MODE_CLOSED) Begin
7650>>>>>>>            Set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_OPEN
7651>>>>>>>            Function_Return Chnl
7652>>>>>>>        End
7652>>>>>>>>
7652>>>>>>>        
7652>>>>>>>        Increment Chnl
7653>>>>>>>    Loop
7654>>>>>>>>
7654>>>>>>>    
7654>>>>>>>    // wrap back to beginning
7654>>>>>>>    Move 0 to Chnl
7655>>>>>>>    
7655>>>>>>>    While Chnl LT DF_SEQ_START_CHANNEL
7659>>>>>>>        If (Seq_Channel_Mode(Chnl) = DF_SEQ_CHANNEL_MODE_CLOSED) Begin
7661>>>>>>>            Set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_OPEN
7662>>>>>>>            Function_Return Chnl
7663>>>>>>>        End
7663>>>>>>>>
7663>>>>>>>        
7663>>>>>>>        Increment Chnl
7664>>>>>>>    Loop
7665>>>>>>>>
7665>>>>>>>    
7665>>>>>>>    Function_Return DF_SEQ_CHANNEL_NOT_AVAILABLE
7666>>>>>>>End_Function
7667>>>>>>>
7667>>>>>>>Procedure Seq_Release_Channel Global Integer Chnl
7669>>>>>>>    If ((Chnl >= DF_SEQ_CHANNEL_MIN) and (Chnl <= DF_SEQ_CHANNEL_MAX)) ;        Set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_CLOSED
7672>>>>>>>End_Procedure
7673>>>>>>>
7673>>>>>>>Function Seq_Open_Input_Channel Global String Dvc Returns Integer
7675>>>>>>>    Integer Chnl
7675>>>>>>>    
7675>>>>>>>    Move (Seq_New_Channel()) to Chnl
7676>>>>>>>    
7676>>>>>>>    If (Chnl <= DF_SEQ_CHANNEL_ERROR) Begin
7678>>>>>>>        If (Seq_Channel_Error_Mode() = DF_SEQ_CHANNEL_ERROR_MODE_ALL) ;            Error DFERR_CANT_OPEN_INPUT_FILE (Dvc + ":" *C_$NoOpenChannels)
7681>>>>>>>        Function_Return Chnl
7682>>>>>>>    End
7682>>>>>>>>
7682>>>>>>>    
7682>>>>>>>    Move False to Err
7683>>>>>>>    Direct_Input channel Chnl Dvc
7685>>>>>>>    
7685>>>>>>>    If (Err) Begin
7687>>>>>>>        Send Seq_Release_Channel Chnl
7688>>>>>>>        Function_Return DF_SEQ_CHANNEL_ERROR
7689>>>>>>>    End
7689>>>>>>>>
7689>>>>>>>    
7689>>>>>>>    Set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_INPUT
7690>>>>>>>    
7690>>>>>>>    Function_Return Chnl
7691>>>>>>>End_Function
7692>>>>>>>
7692>>>>>>>Function Seq_Open_Output_Channel Global String Dvc Returns Integer
7694>>>>>>>    Integer Chnl
7694>>>>>>>    
7694>>>>>>>    Move (Seq_New_Channel()) to Chnl
7695>>>>>>>    
7695>>>>>>>    If (Chnl <= DF_SEQ_CHANNEL_ERROR) Begin
7697>>>>>>>        If (Seq_Channel_Error_Mode() = DF_SEQ_CHANNEL_ERROR_MODE_ALL) Begin
7699>>>>>>>            Error DFERR_CANT_OPEN_OUTPUT_FILE (Dvc + ":" *C_$ChannelNotAvailable)
7700>>>>>>>>
7700>>>>>>>            Move DF_SEQ_CHANNEL_ERROR to Chnl
7701>>>>>>>        End
7701>>>>>>>>
7701>>>>>>>        
7701>>>>>>>        Function_Return Chnl
7702>>>>>>>    End
7702>>>>>>>>
7702>>>>>>>    
7702>>>>>>>    Move False to Err
7703>>>>>>>    Direct_Output channel Chnl Dvc
7705>>>>>>>    
7705>>>>>>>    If (Err) Begin
7707>>>>>>>        Send Seq_Release_Channel Chnl
7708>>>>>>>        Function_Return DF_SEQ_CHANNEL_ERROR
7709>>>>>>>    End
7709>>>>>>>>
7709>>>>>>>    
7709>>>>>>>    Set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_OUTPUT
7710>>>>>>>    
7710>>>>>>>    Function_Return Chnl
7711>>>>>>>End_Function
7712>>>>>>>
7712>>>>>>>Function Seq_Append_Output_Channel Global String Dvc Returns Integer
7714>>>>>>>    Integer Chnl
7714>>>>>>>    
7714>>>>>>>    Move (Seq_New_Channel()) to Chnl
7715>>>>>>>    
7715>>>>>>>    If (Chnl <= DF_SEQ_CHANNEL_ERROR) Begin
7717>>>>>>>        If (Seq_Channel_Error_Mode() = DF_SEQ_CHANNEL_ERROR_MODE_ALL) Begin
7719>>>>>>>            Error DFERR_CANT_OPEN_OUTPUT_FILE (Dvc + ":" *C_$ChannelNotAvailable)
7720>>>>>>>>
7720>>>>>>>            Move DF_SEQ_CHANNEL_ERROR to Chnl
7721>>>>>>>        End
7721>>>>>>>>
7721>>>>>>>        
7721>>>>>>>        Function_Return Chnl
7722>>>>>>>    End
7722>>>>>>>>
7722>>>>>>>    
7722>>>>>>>    Move False to Err
7723>>>>>>>    Append_Output channel Chnl Dvc
7725>>>>>>>    
7725>>>>>>>    If (Err) Begin
7727>>>>>>>        Send Seq_Release_Channel Chnl
7728>>>>>>>        Function_Return DF_SEQ_CHANNEL_ERROR
7729>>>>>>>    End
7729>>>>>>>>
7729>>>>>>>    
7729>>>>>>>    Set Seq_Channel_Mode Chnl to DF_SEQ_CHANNEL_MODE_OUTPUT
7730>>>>>>>    
7730>>>>>>>    Function_Return Chnl
7731>>>>>>>End_Function
7732>>>>>>>
7732>>>>>>>Procedure Seq_Close_Channel Global Integer Chnl
7734>>>>>>>    Integer Mode
7734>>>>>>>    
7734>>>>>>>    If ((Chnl >= DF_SEQ_CHANNEL_MIN) and (Chnl <= DF_SEQ_CHANNEL_MAX)) Begin
7736>>>>>>>        Move (Seq_Channel_Mode(Chnl)) to Mode
7737>>>>>>>        
7737>>>>>>>        If (Mode = DF_SEQ_CHANNEL_MODE_OUTPUT) ;            Close_Output channel Chnl
7741>>>>>>>        Else If (Mode = DF_SEQ_CHANNEL_MODE_INPUT) ;            Close_Input channel Chnl
7746>>>>>>>        // If channel not open, release it! No (fatal) Error.
7746>>>>>>>        Send Seq_Release_Channel Chnl
7747>>>>>>>    End
7747>>>>>>>>
7747>>>>>>>End_Procedure
7748>>>>>>>
7748>>>>>Use GlobalFunctionsProcedures.pkg
7748>>>>>
7748>>>>>Register_Function IsRegistered String sWorkspace Returns Boolean
7748>>>>>Register_Function VdfSystemDfPath   Returns String
7748>>>>>Register_Function VdfSystemMakePath Returns String
7748>>>>>
7748>>>>>Enum_List
7748>>>>>    Define wsWorkspaceOpened       // WS opened ok
7748>>>>>    Define wsWorkspaceNotFound     // the named WS was not found in the global list
7748>>>>>    Define wsWorkspaceFileNotFound // the WS file was not found
7748>>>>>    Define wsDataPathEmpty         // the DataPath entry was empty
7748>>>>>    Define wsFileListEmpty         // The FileList entry was empty
7748>>>>>    Define wsFileListNotExist      // The FileList.cfg file could not be found
7748>>>>>End_Enum_List
7748>>>>>
7748>>>>>Define INVALID_HANDLE_VALUE for -1
7748>>>>>Define MAX_PATH for 260   // Symbol for maximum length of a path
7748>>>>>
7748>>>>>
7748>>>>>External_Function winFindFirstFile "FindFirstFileA" Kernel32.dll ;    String sFileSpec Pointer lpsWin32FindData Returns Handle
7749>>>>>
7749>>>>>External_Function winFindNextFile "FindNextFileA" Kernel32.dll ;    Handle hFindFile Pointer lpsWin32FindData Returns Handle
7750>>>>>
7750>>>>>External_Function winFindClose "FindClose" Kernel32.dll ;    Handle hOpenFile Returns Integer
7751>>>>>
7751>>>>>Function DoesFileExist Global String sFilename Returns Boolean
7753>>>>>    tWIN32_FIND_DATA Win32FindData
7753>>>>>    tWIN32_FIND_DATA Win32FindData
7753>>>>>    String sMask
7753>>>>>    Integer iVoid
7753>>>>>    Handle hFileFind
7753>>>>>    
7753>>>>>    Move (winFindFirstFile(ToAnsi(sFilename), AddressOf(Win32FindData))) to hFileFind   // JVH 8.3.8.0 must pass Ansi filename
7754>>>>>    If (hFileFind <> INVALID_HANDLE_VALUE) Begin
7756>>>>>        Move (winFindClose(hFileFind)) to iVoid
7757>>>>>    End
7757>>>>>>
7757>>>>>    
7757>>>>>    Function_Return (hFileFind <> INVALID_HANDLE_VALUE)
7758>>>>>End_Function
7759>>>>>
7759>>>>>
7759>>>>>Use cIniFile.pkg
Including file: cIniFile.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cIniFile.pkg)
7759>>>>>>>Use Dll.pkg
7759>>>>>>>Use errornum.inc
7759>>>>>>>Use LanguageText.pkg
7759>>>>>>>Use GlobalFunctionsProcedures.pkg
7759>>>>>>>
7759>>>>>>>// it is important that psFileName is defined. If blank, the registry may be accessed. We will check all WritePrivateProfileString
7759>>>>>>>// and GetPrivateProfileString to make sure that a file is defined.
7759>>>>>>>External_Function WritePrivateProfileString "WritePrivateProfileStringA" Kernel32.dll ;    String sSection String sKeyName String sValue String sFileName Returns Integer
7760>>>>>>>
7760>>>>>>>External_Function GetPrivateProfileString "GetPrivateProfileStringA" Kernel32.dll ;    Address aSection Address aKeyName Address aDefault Pointer lpsValue Integer nSize String sFileName Returns Integer
7761>>>>>>>
7761>>>>>>>Class cIniFile is a cObject
7762>>>>>>>    Procedure Construct_Object
7764>>>>>>>        Forward Send Construct_Object
7766>>>>>>>        
7766>>>>>>>        Property String psFileName
7767>>>>>>>    End_Procedure
7768>>>>>>>    
7768>>>>>>>    Procedure WriteString String sSection String sKey String sValue
7770>>>>>>>        Boolean bSuccess
7770>>>>>>>        
7770>>>>>>>        If (trim(psFileName(Self))="") Begin
7772>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
7773>>>>>>>>
7773>>>>>>>            Procedure_Return
7774>>>>>>>        End
7774>>>>>>>>
7774>>>>>>>        Move (WritePrivateProfileString(ToAnsi(sSection), ToAnsi(sKey), ToAnsi(sValue), ToAnsi(psFilename(Self)))) to bSuccess
7775>>>>>>>        If (bSuccess = False) ;            Error DFERR_INI_FILE C_$CannotWriteToTheIniFile
7778>>>>>>>    End_Procedure
7779>>>>>>>    
7779>>>>>>>    Function ReadString String sSection String sKey String sDefault Returns String
7781>>>>>>>        Integer iNumChars iSizeValue
7781>>>>>>>        String sValue
7781>>>>>>>        
7781>>>>>>>        Move (ToAnsi(sSection)) to sSection
7782>>>>>>>        Move (ToAnsi(sKey))     to sKey
7783>>>>>>>        Move (ToAnsi(sDefault)) to sDefault
7784>>>>>>>        
7784>>>>>>>        Move 2047 to iSizeValue
7785>>>>>>>        
7785>>>>>>>        Move (Pad(" ",iSizeValue)) to sValue
7786>>>>>>>        
7786>>>>>>>        If (trim(psFileName(Self))="") Begin
7788>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
7789>>>>>>>>
7789>>>>>>>            Function_Return ''
7790>>>>>>>        End
7790>>>>>>>>
7790>>>>>>>        Move (GetPrivateProfileString(AddressOf(sSection), AddressOf(sKey), AddressOf(sDefault), AddressOf(sValue), iSizeValue, ToAnsi(psFilename(Self)))) to iNumChars
7791>>>>>>>        Function_Return  (ToOem(CString(sValue)))
7792>>>>>>>    End_Function
7793>>>>>>>    
7793>>>>>>>    Function SectionExists String sSection Returns Boolean
7795>>>>>>>        // A section exists only if it has at least one Key. A section with no keys is said not to exist
7795>>>>>>>        Handle hoKeys
7795>>>>>>>        Integer icKey iKey
7795>>>>>>>        
7795>>>>>>>        Get Create U_ARRAY to hoKeys
7796>>>>>>>        Send ReadSection sSection hoKeys
7797>>>>>>>        Get Item_Count of hoKeys to icKey
7798>>>>>>>        Send Destroy of hoKeys
7799>>>>>>>        
7799>>>>>>>        Function_Return (icKey >0)
7800>>>>>>>    End_Function
7801>>>>>>>    
7801>>>>>>>    Procedure ReadSection String sSection Handle hoArray
7803>>>>>>>        Integer iNumChars iSizeValue iPos
7803>>>>>>>        Pointer lpsKeys
7803>>>>>>>        String sKeys sKey
7803>>>>>>>        
7803>>>>>>>        Move 16384 to iSizeValue
7804>>>>>>>        Move (Repeat(character(0),  iSizeValue)) to sKeys
7805>>>>>>>        
7805>>>>>>>        Move (AddressOf(sKeys)) to lpsKeys
7806>>>>>>>        
7806>>>>>>>        Move (ToAnsi(sSection)) to sSection
7807>>>>>>>        
7807>>>>>>>        If (trim(psFileName(Self))="") Begin
7809>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
7810>>>>>>>>
7810>>>>>>>            Procedure_Return
7811>>>>>>>        End
7811>>>>>>>>
7811>>>>>>>        Move (GetPrivateProfileString(AddressOf(sSection), 0, 0, lpsKeys, Length(sKeys), ToAnsi(psFilename(Self)))) to iNumChars
7812>>>>>>>        If (iNumChars >0) Begin
7814>>>>>>>            Repeat
7814>>>>>>>>
7814>>>>>>>                Move (Pos(Character(0),sKeys)) to iPos
7815>>>>>>>                If (iPos >1) Begin
7817>>>>>>>                    Move (Left(sKeys,iPos -1))  to sKey
7818>>>>>>>                    Move (Right(sKeys,Length(sKeys) - iPos)) to sKeys
7819>>>>>>>                    Set Value of hoArray (Item_Count(hoArray)) to (ToOem(sKey))
7820>>>>>>>                End
7820>>>>>>>>
7820>>>>>>>            Until (iPos <=1)
7822>>>>>>>        End
7822>>>>>>>>
7822>>>>>>>    End_Procedure
7823>>>>>>>    
7823>>>>>>>    Procedure ReadSections Handle hoArray
7825>>>>>>>        Integer iNumChars iSizeValue iPos
7825>>>>>>>        Pointer lpsSections
7825>>>>>>>        String sSections sSection
7825>>>>>>>        
7825>>>>>>>        Move 16384 to iSizeValue
7826>>>>>>>        
7826>>>>>>>        Move (Repeat(character(0),  iSizeValue)) to sSections
7827>>>>>>>        Move (AddressOf(sSections)) to lpsSections
7828>>>>>>>        
7828>>>>>>>        If (trim(psFileName(Self))="") Begin
7830>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
7831>>>>>>>>
7831>>>>>>>            Procedure_Return
7832>>>>>>>        End
7832>>>>>>>>
7832>>>>>>>        Move (GetPrivateProfileString(0, 0, 0, lpsSections, Length(sSections), ToAnsi(psFilename(Self)))) to iNumChars
7833>>>>>>>        If (iNumChars >0) Begin
7835>>>>>>>            Repeat
7835>>>>>>>>
7835>>>>>>>                Move (Pos(Character(0),sSections)) to iPos
7836>>>>>>>                If (iPos >1) Begin
7838>>>>>>>                    Move (Left(sSections,iPos -1)) to sSection
7839>>>>>>>                    Move (Right(sSections, Length(sSections) - iPos)) to sSections
7840>>>>>>>                    Set Value of hoArray (Item_Count(hoArray)) to (ToOem(sSection))
7841>>>>>>>                End
7841>>>>>>>>
7841>>>>>>>            Until (iPos <=1)
7843>>>>>>>        End
7843>>>>>>>>
7843>>>>>>>        
7843>>>>>>>    End_Procedure
7844>>>>>>>    
7844>>>>>>>    Procedure DeleteSection String sSection
7846>>>>>>>        
7846>>>>>>>        If (trim(psFileName(Self))="") Begin
7848>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
7849>>>>>>>>
7849>>>>>>>            Procedure_Return
7850>>>>>>>        End
7850>>>>>>>>
7850>>>>>>>        If (WritePrivateProfileString(ToAnsi(sSection), "", "", ToAnsi(psFilename(Self))) = 0) ;            Error DFERR_INI_FILE C_$CanNotDeleteSection
7853>>>>>>>    End_Procedure
7854>>>>>>>    
7854>>>>>>>    Procedure DeleteKey String sSection String sKey
7856>>>>>>>        Integer iVoid
7856>>>>>>>        If (trim(psFileName(Self))="") Begin
7858>>>>>>>            Error DFERR_INI_FILE "Ini file name not defined"
7859>>>>>>>>
7859>>>>>>>            Procedure_Return
7860>>>>>>>        End
7860>>>>>>>>
7860>>>>>>>        Move (WritePrivateProfileString(ToAnsi(sSection), ToAnsi(sKey), "", ToAnsi(psFilename(Self)))) to iVoid
7861>>>>>>>    End_Procedure
7862>>>>>>>    
7862>>>>>>>    Function KeyExists String sSection String sKey Returns Boolean
7864>>>>>>>        Handle hoKeys
7864>>>>>>>        Integer iKey
7864>>>>>>>        Boolean bExists
7864>>>>>>>        
7864>>>>>>>        Move (False) to bExists
7865>>>>>>>        
7865>>>>>>>        Move (ToAnsi(Uppercase(sKey))) to sKey
7866>>>>>>>        
7866>>>>>>>        Get Create U_ARRAY to hoKeys
7867>>>>>>>        
7867>>>>>>>        Send ReadSection sSection hoKeys
7868>>>>>>>        For iKey from 0 to (Item_Count(hoKeys) -1)
7874>>>>>>>>
7874>>>>>>>            If (sKey = Uppercase(Value(hoKeys, iKey))) Begin
7876>>>>>>>                Move (True) to bExists
7877>>>>>>>            End
7877>>>>>>>>
7877>>>>>>>        Loop
7878>>>>>>>>
7878>>>>>>>        
7878>>>>>>>        Send Destroy of hoKeys
7879>>>>>>>        
7879>>>>>>>        Function_Return bExists
7880>>>>>>>    End_Function
7881>>>>>>>    
7881>>>>>>>End_Class
7882>>>>>
7882>>>>>Class cWorkspace is a cObject
7883>>>>>    
7883>>>>>    Procedure Construct_Object
7885>>>>>        Forward Send Construct_Object
7887>>>>>        
7887>>>>>        
7887>>>>>        Property String psAppSrcPath
7888>>>>>        Property String psBitmapPath
7889>>>>>        Property String psDataPath
7890>>>>>        Property String psDdSrcPath
7891>>>>>        Property String psDescription
7892>>>>>        Property String psFileList
7893>>>>>        Property String psHelpPath
7894>>>>>        Property String psHome
7895>>>>>        Property String psIdeSrcPath
7896>>>>>        Property String psProgramPath
7897>>>>>        Property String psAppHtmlPath
7898>>>>>        Property String psWorkspaceName
7899>>>>>        Property String psWorkspaceWSFile
7900>>>>>        Property String psConnectionIni
7901>>>>>        
7901>>>>>        Property String psSystemDfPath // took from the Registry!
7902>>>>>        Property String psSystemMakePath // took from the Registry!
7903>>>>>        Property String psDfPath        // Calculated
7904>>>>>        
7904>>>>>        Property Boolean pbWorkspaceOpened False // used internally to tell if we are switching workspaces
7905>>>>>        
7905>>>>>    End_Procedure
7906>>>>>    
7906>>>>>    Function FullPathNames String sShortPathNames Returns String
7908>>>>>        String sFileName
7908>>>>>        String sFullPathNames sFullPathName sShortPathName
7908>>>>>        Pointer lpsFilePart
7908>>>>>        Integer icChar // the number of characters returned
7908>>>>>        Integer iPos
7908>>>>>        
7908>>>>>        Move (Pos(";", sShortPathNames)) to iPos
7909>>>>>        While (length(sShortPathNames) >0)
7913>>>>>            If (iPos =0) Begin
7915>>>>>                Move sShortPathNames to sShortPathName
7916>>>>>                Move "" to sShortPathNames
7917>>>>>            End
7917>>>>>>
7917>>>>>            Else Begin // multiple paths
7918>>>>>                Move (Left(sShortPathNames, iPos -1)) to sShortPathName
7919>>>>>                Move (Right(sShortPathNames, length(sShortPathNames) -iPos)) to sShortPathNames // remove this path from the paths
7920>>>>>            End
7920>>>>>>
7920>>>>>            Move (Repeat(character(0), 4096)) to sFullPathName
7921>>>>>            Move -1 to lpsFilePart
7922>>>>>            Move (GetFullPathName(sShortPathName, 4096, AddressOf(sFullPathName), AddressOf(lpsFilePart))) to icChar
7923>>>>>            Append sFullPathNames (CString(sFullPathName))
7924>>>>>            If (sShortPathNames <>"") ;                Append sFullPathNames ";"
7927>>>>>            Move (Pos(";", sShortPathNames)) to iPos
7928>>>>>        Loop
7929>>>>>>
7929>>>>>        
7929>>>>>        Function_Return sFullPathNames
7930>>>>>    End_Function
7931>>>>>    
7931>>>>>    Function GetApplicationPath Returns String
7933>>>>>        // Returns the path of the Application (no trailing "\")
7933>>>>>        String sApplicationFileName sPath
7933>>>>>        Boolean bRemoved
7933>>>>>        Integer iNumChars
7933>>>>>        String sFilename
7933>>>>>        
7933>>>>>        Move (Repeat(Character(0), 1024)) to sApplicationFileName
7934>>>>>        Move (GetModuleFileName(0, AddressOf(sApplicationFileName), 1024)) to iNumChars
7935>>>>>        Move (CString(sApplicationFileName)) to sApplicationFileName
7936>>>>>        
7936>>>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to bRemoved
7937>>>>>        Move (CString(sApplicationFileName)) to sPath
7938>>>>>        
7938>>>>>        If (Right(sPath, 1) ="\") ;            Move (Left(sPath, Length(sPath) -1)) to sPath
7941>>>>>        Function_Return sPath
7942>>>>>    End_Function
7943>>>>>    
7943>>>>>    Procedure DoClearPaths
7945>>>>>        // Call this prior to changing from one WorkspAce to another
7945>>>>>        // if you don't, OpenWorkspaceFile will ignore the new paths.
7945>>>>>        Set psHome           to ""
7946>>>>>        Set psAppSrcPath     to ""
7947>>>>>        Set psBitmapPath     to ""
7948>>>>>        Set psDataPath       to ""
7949>>>>>        Set psDdSrcPath      to ""
7950>>>>>        Set psDescription    to ""
7951>>>>>        Set psFileList       to ""
7952>>>>>        Set psHelpPath       to ""
7953>>>>>        Set psIdeSrcPath     to ""
7954>>>>>        Set psAppHtmlPath    to ""
7955>>>>>        Set psProgramPath    to ""
7956>>>>>        Set psWorkspaceName  to ""
7957>>>>>        Set psSystemDfPath   to ""
7958>>>>>        Set psSystemMakePath to ""
7959>>>>>        Set psWorkspaceWSFile to ""
7960>>>>>        Set psConnectionIni to ""
7961>>>>>    End_Procedure
7962>>>>>    
7962>>>>>    Function OpenWorkspaceFile String sWorkspaceFile Returns Integer
7964>>>>>        String sApplicationStartPath
7964>>>>>        String sWsName // name of Workspace is inferred from the Workspacefile name
7964>>>>>        Boolean bRemoved
7964>>>>>        Handle hoIniFile
7964>>>>>        Boolean bSuccess // call succeeded?
7964>>>>>        String sOldDirectory
7964>>>>>        String sSystemDfPath sSystemMakePath
7964>>>>>        Boolean bExist // does the WS file exist?
7964>>>>>        Boolean bChangingWorkspace
7964>>>>>        
7964>>>>>        String sHome sAppSrcPath sBitmapPath sDataPath sDdSrcPath sDescription sAppHtmlPath
7964>>>>>        String sFileList sHelpPath sIdeSrcPath sProgramPath sWorkspaceName sConnectionIni
7964>>>>>        
7964>>>>>        Set psWorkspaceWSFile to ""
7965>>>>>        If (sWorkspaceFile ="") ;            Function_Return wsWorkspaceFileNotFound
7968>>>>>        
7968>>>>>        // Append extension if not supplied...
7968>>>>>        If (Uppercase(Right(Trim(sWorkspaceFile),3)) <> ".WS") Begin
7970>>>>>            Move (sWorkspaceFile-".ws") to sWorkspaceFile
7971>>>>>        End
7971>>>>>>
7971>>>>>        
7971>>>>>        Get pbWorkspaceOpened to bChangingWorkspace // if we had an existing workspace. We are changing
7972>>>>>        
7972>>>>>        If (IsFilenameQualified(sWorkspaceFile) = False) Begin
7974>>>>>            // Set the properties to the paths of the Workspace
7974>>>>>            // Find the WS file (with program)...
7974>>>>>            Get GetApplicationPath to sApplicationStartPath
7975>>>>>            
7975>>>>>            Move sWorkspaceFile to sWsName
7976>>>>>            Move (sApplicationStartPath +"\" +sWorkspaceFile) to sWorkspaceFile
7977>>>>>        End
7977>>>>>>
7977>>>>>        Else Begin
7978>>>>>            Move (ExtractFileName(sWorkspaceFile)) to sWsName
7979>>>>>            
7979>>>>>            Move sWorkspaceFile to sApplicationStartPath
7980>>>>>            Move (PathRemoveFileSpec(AddressOf(sApplicationStartPath))) to bRemoved
7981>>>>>        End
7981>>>>>>
7981>>>>>        
7981>>>>>        // Ensure that the file can be found...
7981>>>>>        //File_Exist (ToAnsi(sWorkspaceFile)) bExist        // [JVH] 8.3.8.0 Convert filename to Ansi
7981>>>>>        // [JVH] Turn off support for
7981>>>>>        // Ansi extended characters in workspace until we can
7981>>>>>        // resolve all open issues
7981>>>>>        Set psWorkspaceWSFile to sWorkspaceFile
7982>>>>>        File_Exist sWorkspaceFile bExist
7983>>>>>        If (bExist = False) ;            Function_Return wsWorkspaceFileNotFound
7986>>>>>        
7986>>>>>        Get psHome           to sHome
7987>>>>>        Get psAppSrcPath     to sAppSrcPath
7988>>>>>        Get psAppHtmlPath    to sAppHtmlPath
7989>>>>>        Get psBitmapPath     to sBitmapPath
7990>>>>>        Get psDataPath       to sDataPath
7991>>>>>        Get psDdSrcPath      to sDdSrcPath
7992>>>>>        Get psDescription    to sDescription
7993>>>>>        Get psFileList       to sFileList
7994>>>>>        Get psHelpPath       to sHelpPath
7995>>>>>        Get psIdeSrcPath     to sIdeSrcPath
7996>>>>>        Get psProgramPath    to sProgramPath
7997>>>>>        Get psSystemDfPath   to sSystemDfPath
7998>>>>>        Get psSystemMakePath to sSystemMakePath
7999>>>>>        Get psWorkspaceName  to sWorkspaceName
8000>>>>>        Get psConnectionIni to sConnectionIni
8001>>>>>        
8001>>>>>        Get_Current_Directory to sOldDirectory
8002>>>>>        // Note- this conversion is temporarily rolled back
8002>>>>>        //Move (SetCurrentDirectory(ToAnsi(CString(sApplicationStartPath)))) To bSuccess    // [JVH] 8.3.8.0 Convert AppStartPath to ANSI
8002>>>>>        Move (SetCurrentDirectory(CString(sApplicationStartPath))) to bSuccess
8003>>>>>        
8003>>>>>        Get Create U_cIniFile to hoIniFile
8004>>>>>        Set psFilename of hoIniFile to sWorkspaceFile
8005>>>>>        
8005>>>>>        If (sHome ="") ;            Get ReadString of hoIniFile "Workspace" "Home" ""          to sHome
8008>>>>>        If (sAppSrcPath ="") ;            Get ReadString of hoIniFile "Workspace" "AppSrcPath" ""    to sAppSrcPath
8011>>>>>        If (sAppHtmlPath ="") ;            Get ReadString of hoIniFile "Workspace" "AppHtmlPath" ""   to sAppHtmlPath
8014>>>>>        If (sBitmapPath ="") ;            Get ReadString of hoIniFile "Workspace" "BitmapPath" ""    to sBitmapPath
8017>>>>>        If (sDataPath ="") ;            Get ReadString of hoIniFile "Workspace" "DataPath" ""      to sDataPath
8020>>>>>        If (sDdSrcPath ="") ;            Get ReadString of hoIniFile "Workspace" "DdSrcPath" ""     to sDdSrcPath
8023>>>>>        If (sDescription ="") ;            Get ReadString of hoIniFile "Workspace" "Description" ""   to sDescription
8026>>>>>        If (sFileList ="") ;            Get ReadString of hoIniFile "Workspace" "FileList" ""      to sFileList
8029>>>>>        If (sHelpPath ="") ;            Get ReadString of hoIniFile "Workspace" "HelpPath" ""      to sHelpPath
8032>>>>>        If (sIdeSrcPath ="") ;            Get ReadString of hoIniFile "Workspace" "IdeSrcPath" ""    to sIdeSrcPath
8035>>>>>        If (sProgramPath ="") ;            Get ReadString of hoIniFile "Workspace" "ProgramPath" ""   to sProgramPath
8038>>>>>        If (sWorkspaceName ="") ;            Move (Left(sWsName, Length(sWsName) -3))                   to sWorkspaceName
8041>>>>>        If (sConnectionIni ="") ;            Get ReadString of hoIniFile "Workspace" "ConnectionIni" ""   to sConnectionIni
8044>>>>>        
8044>>>>>        If (sSystemDfPath ="") ;            Set psSystemDfPath   to (VdfSystemDfPath(Self))
8047>>>>>        If (sSystemMakePath ="") ;            Set psSystemMakePath to (VdfSystemMakePath(Self))
8050>>>>>        
8050>>>>>        Set psHome          to (FullPathNames(Self, sHome))
8051>>>>>        
8051>>>>>        // Set CWD to Home...
8051>>>>>        Move (SetCurrentDirectory(sHome)) to bSuccess
8052>>>>>        Set psAppSrcPath    to (FullPathNames(Self, sAppSrcPath))
8053>>>>>        Set psAppHtmlPath   to (FullPathNames(Self, sAppHtmlPath))
8054>>>>>        Set psBitmapPath    to (FullPathNames(Self, sBitmapPath))
8055>>>>>        Set psDataPath      to (FullPathNames(Self, sDataPath))
8056>>>>>        Set psDdSrcPath     to (FullPathNames(Self, sDdSrcPath))
8057>>>>>        Set psFileList      to (FullPathNames(Self, sFileList))
8058>>>>>        Set psHelpPath      to (FullPathNames(Self, sHelpPath))
8059>>>>>        Set psIdeSrcPath    to (FullPathNames(Self, sIdeSrcPath))
8060>>>>>        Set psProgramPath   to (FullPathNames(Self, sProgramPath))
8061>>>>>        Set psConnectionIni to (FullPathNames(Self, sConnectionIni))
8062>>>>>        
8062>>>>>        Set psWorkspaceName to sWorkspaceName
8063>>>>>        Set psDescription   to sDescription
8064>>>>>        
8064>>>>>        Send Destroy of hoIniFile // destroy dynaically created inifile object
8065>>>>>        
8065>>>>>        // Restore CWD...
8065>>>>>        Move (SetCurrentDirectory(sOldDirectory)) to sOldDirectory
8066>>>>>        
8066>>>>>        // Check for error conditions:
8066>>>>>        // DataPath and FileList must be defined; the FileList entry must point to a valid FileList.cfg
8066>>>>>        If (psDataPath(Self) = "") ;            Function_Return wsDataPathEmpty
8069>>>>>        If (psFileList(Self) = "") ;            Function_Return wsFileListEmpty
8072>>>>>        
8072>>>>>        Move (DoesFileExist(psFileList(Self))) to bExist
8073>>>>>        If (bExist = False) ;            Function_Return wsFileListNotExist
8076>>>>>        
8076>>>>>        If bChangingWorkspace ;            Close DF_ALL // if there is a WS open, we must close all the files
8079>>>>>        
8079>>>>>        Send DoAssignPaths // set psDfPath
8080>>>>>        Send DoSetPaths    // Set the application's Attributes of Filelist_Name and Open_Path
8081>>>>>        Set pbWorkspaceOpened to True
8082>>>>>        
8082>>>>>        Function_Return wsWorkspaceOpened
8083>>>>>    End_Function
8084>>>>>    
8084>>>>>    Function OpenWorkspace String sWorkspace Returns Integer
8086>>>>>        // Look in the Workspaces.ini file for the name, then open it by path
8086>>>>>        
8086>>>>>        Handle hoSections hoIniFile
8086>>>>>        Integer iWorkspace eOpened
8086>>>>>        String sWorkspaceName sPath
8086>>>>>        String sVdfRootDir
8086>>>>>        
8086>>>>>        Get Create U_Array    to hoSections
8087>>>>>        Get Create U_cIniFile to hoIniFile
8088>>>>>        
8088>>>>>        Get_Profile_String "Defaults" "VdfRootDir" to sVdfRootDir
8091>>>>>        If (Right(sVdfRootDir,1) <>"\") ;            Move (sVdfRootDir +"\") to sVdfRootDir
8094>>>>>        
8094>>>>>        Set psFilename of hoIniFile to (sVdfRootDir +"bin\Workspaces.ini")
8095>>>>>        
8095>>>>>        Send ReadSections of hoIniFile hoSections
8096>>>>>        
8096>>>>>        For iWorkspace from 0 to (Item_Count(hoSections) -1)
8102>>>>>>
8102>>>>>            Get Value of hoSections iWorkspace to sWorkspaceName
8103>>>>>            If (Uppercase(sWorkspaceName) = Uppercase(sWorkspace)) Begin
8105>>>>>                Get ReadString of hoIniFile sWorkspace "Path" "" to sPath
8106>>>>>                If (Right(sPath,1) <>"\") ;                    Move (sPath +"\") to sPath
8109>>>>>                
8109>>>>>                Get OpenWorkspaceFile (sPath + sWorkspace) to eOpened
8110>>>>>                Send Destroy of hoSections
8111>>>>>                Send Destroy of hoIniFile
8112>>>>>                Function_Return eOpened
8113>>>>>            End
8113>>>>>>
8113>>>>>        Loop
8114>>>>>>
8114>>>>>        
8114>>>>>        Send Destroy of hoSections
8115>>>>>        Send Destroy of hoIniFile
8116>>>>>        Function_Return wsWorkspaceNotFound
8117>>>>>    End_Function
8118>>>>>    
8118>>>>>    Function IsRegistered String sWorkspace Returns Boolean
8120>>>>>        Boolean bRegistered
8120>>>>>        Handle hoIniFile
8120>>>>>        String sVdfRootDir
8120>>>>>        
8120>>>>>        Get Create U_cIniFile to hoIniFile
8121>>>>>        
8121>>>>>        Get_Profile_String "Defaults" "VdfRootDir" to sVdfRootDir
8124>>>>>        If (Right(sVdfRootDir,1) <>"\") ;            Move (sVdfRootDir +"\") to sVdfRootDir
8127>>>>>        Set psFilename of hoIniFile to (sVdfRootDir +"bin\Workspaces.ini")
8128>>>>>        Move (SectionExists(hoIniFile, sWorkspace)) to bRegistered
8129>>>>>        
8129>>>>>        Send Destroy of hoIniFile
8130>>>>>        
8130>>>>>        Function_Return bRegistered
8131>>>>>    End_Function
8132>>>>>    
8132>>>>>    Function VdfSystemDfPath Returns String
8134>>>>>        String sSystemDfPath
8134>>>>>        Get_Profile_String "Workspaces" "SystemDfPath" to sSystemDfPath
8137>>>>>        
8137>>>>>        Function_Return sSystemDfPath
8138>>>>>    End_Function
8139>>>>>    
8139>>>>>    Function VdfSystemMakePath Returns String
8141>>>>>        String sSystemMakePath
8141>>>>>        Get_Profile_String "Workspaces" "SystemMakePath" to sSystemMakePath
8144>>>>>        
8144>>>>>        Function_Return sSystemMakePath
8145>>>>>    End_Function
8146>>>>>    
8146>>>>>    Procedure DoAssignPaths
8148>>>>>        String sDataPath sBitmapPath sHelpPath sProgramPath sSystemDfPath
8148>>>>>        
8148>>>>>        Get psDataPath     to sDataPath
8149>>>>>        Get psBitmapPath   to sBitmapPath
8150>>>>>        Get psHelpPath     to sHelpPath
8151>>>>>        Get psProgramPath  to sProgramPath
8152>>>>>        Get psSystemDfPath to sSystemDfPath
8153>>>>>        
8153>>>>>        Set psDfPath to (sDataPath +';' + sBitmapPath +';' + sHelpPath +';' + sProgramPath +';' + sSystemDfPath)
8154>>>>>        
8154>>>>>    End_Procedure
8155>>>>>    
8155>>>>>    Procedure DoSetPaths
8157>>>>>        // [JVH] must convert paths to Ansi before setting these values
8157>>>>>        // Note- this conversion is temporarily rolled back
8157>>>>>        //Set_Attribute DF_FILELIST_NAME To (ToAnsi(psFileList(self)))
8157>>>>>        //Set_Attribute DF_OPEN_PATH     To (ToAnsi(psDfPath(self)))
8157>>>>>        Set_Attribute DF_FILELIST_NAME to (psFileList(Self))
8160>>>>>        Set_Attribute DF_OPEN_PATH     to (psDfPath(Self))
8163>>>>>    End_Procedure
8164>>>>>    
8164>>>>>    Procedure EnumerateWorkspaceData Handle hoCallBack Handle hmGeneric
8166>>>>>        String sPath
8166>>>>>        
8166>>>>>        If (psWorkspaceName(Self)="") ;            Send hmGeneric to hoCallBack C_$WorkspaceNotUsed
8169>>>>>        Else Begin
8170>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$WorkspaceDesc, psDescription(Self)))
8171>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$WorkspaceName, psWorkspaceName(Self)))
8172>>>>>            Send hmGeneric to hoCallBack ""
8173>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$Filelist, psFileList(Self)))
8174>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$DataPath, psDataPath(Self)))
8175>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$ProgramPath, psProgramPath(Self)))
8176>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$HelpPath, psHelpPath(Self)))
8177>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$BitmapsPath, psBitmapPath(Self)))
8178>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$SystemPaths, psSystemDfPath(Self)))
8179>>>>>            Send hmGeneric to hoCallBack (SFormat(C_$FullDFPath, psDfPath(Self)))
8180>>>>>        End
8180>>>>>>
8180>>>>>    End_Procedure
8181>>>>>    
8181>>>>>    Function OpenWorkspaceErrorMessage Integer eErrorCode Returns String
8183>>>>>        // Decodes the enumerated integer returned by OpenWorkspace and
8183>>>>>        // returns a corresponding message string.
8183>>>>>        String sError
8183>>>>>        
8183>>>>>        Case Begin
8183>>>>>            Case (eErrorCode = wsWorkspaceOpened)
8185>>>>>                Move C_$NoErrors to sError
8186>>>>>                Case Break
8187>>>>>            Case (eErrorCode = wsWorkspaceNotFound)
8190>>>>>                Move C_$NoWsName to sError
8191>>>>>                Case Break
8192>>>>>            Case (eErrorCode = wsWorkspaceFileNotFound)
8195>>>>>                Move C_$NoWsFileFound to sError
8196>>>>>                Case Break
8197>>>>>            Case (eErrorCode = wsDataPathEmpty)
8200>>>>>                Move C_$NoWsDataPath to sError
8201>>>>>                Case Break
8202>>>>>            Case (eErrorCode = wsFileListEmpty)
8205>>>>>                Move C_$NoWsFileList to sError
8206>>>>>                Case Break
8207>>>>>            Case (eErrorCode = wsFileListNotExist)
8210>>>>>                Move C_$NoFileListCfg to sError
8211>>>>>                Case Break
8212>>>>>            Case Else
8212>>>>>                Move C_$UnknownError to sError
8213>>>>>                Case Break
8214>>>>>        Case End
8214>>>>>        
8214>>>>>        Function_Return (sError-".")
8215>>>>>    End_Function
8216>>>>>    
8216>>>>>    Function GetWorkspaceFileName String sWorkspace Returns String
8218>>>>>        // Returns the name of the physical Workspace file for the passed Workspace name.
8218>>>>>        String sVdfRootDir
8218>>>>>        Handle hoIniFile
8218>>>>>        String sPath
8218>>>>>        String sFileName
8218>>>>>        String sWorkspacePath
8218>>>>>        
8218>>>>>        Move "" to sFileName
8219>>>>>        
8219>>>>>        Get_Profile_String "Defaults" "VdfRootDir" to sVdfRootDir
8222>>>>>        If (Right(sVdfRootDir,1) <>"\") ;            Move (sVdfRootDir +"\") to sVdfRootDir
8225>>>>>        
8225>>>>>        Get Create U_cIniFile to hoIniFile
8226>>>>>        Set psFilename of hoIniFile to (sVdfRootDir +"bin\Workspaces.ini")
8227>>>>>        Get ReadString of hoIniFile sWorkspace "Path" "" to sWorkspacePath
8228>>>>>        If (sWorkspacePath <>"") Begin
8230>>>>>            If (Right(sWorkspacePath,1) <>"\") ;                Move (sWorkspacePath +"\") to sWorkspacePath
8233>>>>>            Move (sWorkspacePath +sWorkspace +".ws") to sFileName
8234>>>>>        End
8234>>>>>>
8234>>>>>        Send Destroy of hoIniFile
8235>>>>>        
8235>>>>>        Function_Return sFileName
8236>>>>>    End_Function
8237>>>>>    
8237>>>>>    Function CountOfPaths String sPaths Returns Integer
8239>>>>>        // Returns the number of paths defined in a string of paths
8239>>>>>        Integer iChar icChar icPath
8239>>>>>        
8239>>>>>        If (sPaths ="") ;            Function_Return 0
8242>>>>>        
8242>>>>>        Move (Length(sPaths) -1) to icChar
8243>>>>>        For iChar from 1 to icChar
8249>>>>>>
8249>>>>>            If (Mid(sPaths, 1, iChar) =";") ;                Increment icPath
8252>>>>>        Loop
8253>>>>>>
8253>>>>>        
8253>>>>>        Function_Return (icPath +1)
8254>>>>>    End_Function
8255>>>>>    
8255>>>>>    Function PathAtIndex String sPaths Integer iIndex Returns String
8257>>>>>        // Returns the path at the 1-based index of passed paths.
8257>>>>>        // If the path contains a trailing "\", it will be removed
8257>>>>>        Integer iChar icPath iPath iPos
8257>>>>>        String sPath
8257>>>>>        
8257>>>>>        Move (sPaths +";") to sPaths
8258>>>>>        For iPath from 1 to iIndex
8264>>>>>>
8264>>>>>            Move (Pos(";", sPaths)) to iPos
8265>>>>>            If iPos Begin
8267>>>>>                Move (Left(sPaths, iPos -1)) to sPath
8268>>>>>                If (Right(sPath,1) = '\') ;                    Move (Left(sPath, Length(sPath) -1)) to sPath
8271>>>>>                Move (Right(sPaths, Length(sPaths) -iPos)) to sPaths
8272>>>>>            End
8272>>>>>>
8272>>>>>            Else ;                Function_Return "" // index past number of paths
8274>>>>>        Loop
8275>>>>>>
8275>>>>>        
8275>>>>>        Function_Return sPath
8276>>>>>    End_Function
8277>>>>>    
8277>>>>>End_Class
8278>>>Use cCommandLine.pkg
Including file: cCommandLine.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCommandLine.pkg)
8278>>>>>Use VDFBase.pkg
8278>>>>>
8278>>>>>Class cCommandLine is a cObject
8279>>>>>    
8279>>>>>    Procedure Construct_Object
8281>>>>>        Forward Send Construct_Object
8283>>>>>        
8283>>>>>        Property Handle phoArgs // private object-handle of internal array of arguments
8284>>>>>    End_Procedure
8285>>>>>    
8285>>>>>    Procedure Private_DoCreateArgsArray
8287>>>>>        // creates the array for holding the arguments. Created upon demand only!
8287>>>>>        Integer icArg
8287>>>>>        String sArg
8287>>>>>        
8287>>>>>        Object oArgs is an Array
8289>>>>>            Delegate Set phoArgs to Self
8291>>>>>            Repeat
8291>>>>>>
8291>>>>>                CmdLine sArg
8292>>>>>>
8292>>>>>                If (sArg <> "") Begin
8294>>>>>                    Increment icArg
8295>>>>>                    Set Value  (icArg -1) to sArg
8296>>>>>                End
8296>>>>>>
8296>>>>>            Until (sArg = "")
8298>>>>>        End_Object
8299>>>>>    End_Procedure
8300>>>>>    
8300>>>>>    Function CountOfArgs Returns Integer
8302>>>>>        //Returns the number of arguments passed
8302>>>>>        If (phoArgs(Self) =0) ;            Send Private_DoCreateArgsArray
8305>>>>>        Function_Return (Item_Count(phoArgs(Self)))
8306>>>>>    End_Function
8307>>>>>    
8307>>>>>    Function Argument Integer iIndex Returns String
8309>>>>>        //Returns the one-based argument string
8309>>>>>        If (phoArgs(Self) =0) ;            Send Private_DoCreateArgsArray
8312>>>>>        Function_Return (Value(phoArgs(Self), iIndex -1))
8313>>>>>    End_Function
8314>>>>>    
8314>>>>>End_Class
8315>>>>>
8315>>>Use cRegistry.pkg
Including file: cRegistry.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cRegistry.pkg)
8315>>>>>Use Dll.pkg
8315>>>>>Use RegistryAPI.pkg
8315>>>>>
8315>>>>>Enum_List // Registry Data types
8315>>>>>    Define rdString
8315>>>>>    Define rdDword
8315>>>>>    Define rdBinary
8315>>>>>    Define rdUnknown
8315>>>>>End_Enum_List
8315>>>>>
8315>>>>>//Prototypes
8315>>>>>Register_Function phRootKey      Returns Handle // HKEY_CURRENT_USER
8315>>>>>Register_Function pfAccessRights Returns Integer // KEY_ALL_ACCESS - what access level should be used to open a Key?
8315>>>>>Register_Function phCurrentKey   Returns Handle // low-level key
8315>>>>>Register_Function pbLazyWrite    Returns Boolean // True
8315>>>>>
8315>>>>>Register_Function CountOfSubkeys      Returns Integer
8315>>>>>Register_Function CountOfValues       Returns Integer
8315>>>>>Register_Function CreateKey           String sKeyName Returns Integer   // return=error code
8315>>>>>Register_Function DeleteKey           String sKeyName Returns Boolean       // Deleted successfully?
8315>>>>>Register_Function DeleteValue         String sValueName Returns Boolean // Deleted successfully?
8315>>>>>Register_Function GetSubkeys          Handle hoArray Returns Integer    // count of Subkeys
8315>>>>>Register_Function GetValues           Handle hoArray Returns Integer    // count of Values
8315>>>>>Register_Function KeyExists           String sKeyName Returns Boolean   // does the key exist?
8315>>>>>Register_Function LongestDataLength   Returns Integer
8315>>>>>Register_Function LongestSubkeyLength Returns Integer
8315>>>>>Register_Function LongestValueLength  Returns Integer
8315>>>>>Register_Function OpenKey             String sKeyName Returns Integer
8315>>>>>Register_Function ReadBinary          String sValueName Address aValueData Integer iDataLength Returns Boolean
8315>>>>>Register_Function ReadDword           String sValueName Returns DWord
8315>>>>>Register_Function ReadString          String sValueName Returns String
8315>>>>>Register_Function ValueExists         String sValueName Returns Integer // does the Value exist?
8315>>>>>Register_Function ValueLength         String sValueName Returns Integer
8315>>>>>Register_Function ValueType           String sValueName Returns Integer // what is the datatype of the Value?
8315>>>>>Register_Procedure CloseKey
8315>>>>>Register_Procedure WriteBinary        String sValueName Address aValueData Integer iDataLength
8315>>>>>Register_Procedure WriteDword         String sValue DWord dwValueData
8315>>>>>Register_Procedure WriteString        String sValue String sValueData
8315>>>>>
8315>>>>>
8315>>>>>Class cRegistry is a cObject
8316>>>>>    Procedure Construct_Object
8318>>>>>        Forward Send Construct_Object
8320>>>>>        
8320>>>>>        Property Handle phRootKey HKEY_CURRENT_USER
8321>>>>>        Property UInteger pfAccessRights  KEY_ALL_ACCESS // what access level should be used to open a Key?
8322>>>>>        Property Handle phCurrentKey
8323>>>>>        Property Boolean pbLazyWrite True
8324>>>>>    End_Procedure
8325>>>>>    
8325>>>>>    Function CountOfSubkeys Returns Integer
8327>>>>>        DWord dwCountOfSubkeys
8327>>>>>        Integer iError
8327>>>>>        String sError
8327>>>>>        
8327>>>>>        Move 0 to dwCountOfSubkeys
8328>>>>>        Move (RegQueryInfoKey(phCurrentKey(Self), 0, 0, 0, AddressOf(dwCountOfSubkeys), 0, 0, 0, 0, 0, 0, 0)) to iError
8329>>>>>        If iError Begin
8331>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8332>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8333>>>>>>
8333>>>>>        End
8333>>>>>>
8333>>>>>        Function_Return dwCountOfSubkeys
8334>>>>>    End_Function
8335>>>>>    
8335>>>>>    Function CountOfValues Returns Integer
8337>>>>>        DWord dwCountOfValues
8337>>>>>        Integer iError
8337>>>>>        String sError
8337>>>>>        
8337>>>>>        Move 0 to dwCountOfValues
8338>>>>>        Move (RegQueryInfoKey(phCurrentKey(Self), 0, 0, 0, 0, 0, 0, AddressOf(dwCountOfValues), 0, 0, 0, 0)) to iError
8339>>>>>        If iError Begin
8341>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8342>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8343>>>>>>
8343>>>>>        End
8343>>>>>>
8343>>>>>        
8343>>>>>        Function_Return dwCountOfValues
8344>>>>>    End_Function
8345>>>>>    
8345>>>>>    Function LongestSubkeyLength Returns Integer
8347>>>>>        DWord dwLongestSubkeyLength
8347>>>>>        Integer iError
8347>>>>>        String sError
8347>>>>>        
8347>>>>>        Move 0 to dwLongestSubkeyLength
8348>>>>>        Move (RegQueryInfoKey(phCurrentKey(Self), 0, 0, 0, 0, AddressOf(dwLongestSubkeyLength), 0, 0, 0, 0, 0, 0)) to iError
8349>>>>>        If iError Begin
8351>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8352>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8353>>>>>>
8353>>>>>        End
8353>>>>>>
8353>>>>>        
8353>>>>>        Function_Return dwLongestSubkeyLength
8354>>>>>    End_Function
8355>>>>>    
8355>>>>>    Function LongestValueLength Returns Integer
8357>>>>>        DWord dwLongestValueLength
8357>>>>>        Integer iError
8357>>>>>        String sError
8357>>>>>        
8357>>>>>        Move 0 to dwLongestValueLength
8358>>>>>        Move (RegQueryInfoKey(phCurrentKey(Self), 0, 0, 0, 0, 0, 0, 0, AddressOf(dwLongestValueLength), 0, 0, 0)) to iError
8359>>>>>        If iError Begin
8361>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8362>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8363>>>>>>
8363>>>>>        End
8363>>>>>>
8363>>>>>        
8363>>>>>        Function_Return dwLongestValueLength
8364>>>>>    End_Function
8365>>>>>    
8365>>>>>    Function LongestDataLength Returns Integer
8367>>>>>        DWord dwLongestDataLength
8367>>>>>        Integer iError
8367>>>>>        String sError
8367>>>>>        
8367>>>>>        Move 0 to dwLongestDataLength
8368>>>>>        Move (RegQueryInfoKey(phCurrentKey(Self), 0, 0, 0, 0, 0, 0, 0, 0, AddressOf(dwLongestDataLength), 0, 0)) to iError
8369>>>>>        If iError Begin
8371>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8372>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8373>>>>>>
8373>>>>>        End
8373>>>>>>
8373>>>>>        
8373>>>>>        Function_Return dwLongestDataLength
8374>>>>>    End_Function
8375>>>>>    
8375>>>>>    Function ValueType String sValueName Returns Integer
8377>>>>>        DWord dwType
8377>>>>>        Integer iError eType
8377>>>>>        String sError
8377>>>>>        
8377>>>>>        Move 0 to dwType
8378>>>>>        Move (RegQueryValueEx(phCurrentKey(Self), ToAnsi(sValueName), 0, AddressOf(dwType), 0, 0)) to iError
8379>>>>>        If iError Begin
8381>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8382>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8383>>>>>>
8383>>>>>        End
8383>>>>>>
8383>>>>>        
8383>>>>>        If (dwType = REG_SZ) ;            Move rdString to eType
8386>>>>>        Else If (dwType = REG_DWORD)  ;            Move rdDword to eType
8390>>>>>        Else If (dwType = REG_BINARY) ;            Move rdBinary to eType
8394>>>>>        Else ;            Move rdUnknown to eType
8396>>>>>        
8396>>>>>        Function_Return eType
8397>>>>>    End_Function
8398>>>>>    
8398>>>>>    Function ValueLength String sValueName Returns Integer
8400>>>>>        DWord dwSize
8400>>>>>        Integer iError
8400>>>>>        String sError
8400>>>>>        
8400>>>>>        Move 0 to dwSize
8401>>>>>        Move (RegQueryValueEx(phCurrentKey(Self), ToAnsi(sValueName), 0, 0, 0, AddressOf(dwSize))) to iError
8402>>>>>        If iError Begin
8404>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8405>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8406>>>>>>
8406>>>>>        End
8406>>>>>>
8406>>>>>        
8406>>>>>        Function_Return dwSize
8407>>>>>    End_Function
8408>>>>>    
8408>>>>>    Function CreateKey String sKeyName Returns Integer // return=error code
8410>>>>>        // Calling CreateKey for an existing Key, merely opens it without error.
8410>>>>>        Handle hKey hKeyOpened
8410>>>>>        Integer iError
8410>>>>>        String sError
8410>>>>>        
8410>>>>>        Move 0 to hKeyOpened // initialize it so we can get its address
8411>>>>>        
8411>>>>>        Get phRootKey to hKey
8412>>>>>        
8412>>>>>        Move (RegCreateKeyEx(hKey, ToAnsi(sKeyName), 0, 0, REG_OPTION_NON_VOLATILE, pfAccessRights(Self), 0, AddressOf(hKeyOpened), 0)) to iError
8413>>>>>        If (iError =0) ;            Set phCurrentKey to hKeyOpened
8416>>>>>        Else Begin
8417>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8418>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8419>>>>>>
8419>>>>>        End
8419>>>>>>
8419>>>>>        Function_Return iError
8420>>>>>    End_Function
8421>>>>>    
8421>>>>>    Procedure CloseKey
8423>>>>>        Integer iError
8423>>>>>        Handle hKey
8423>>>>>        
8423>>>>>        Get phCurrentKey to hKey
8424>>>>>        
8424>>>>>        If (hKey <>0) Begin
8426>>>>>            If (pbLazyWrite(Self)) ;                Move (RegCloseKey(hKey)) to iError
8429>>>>>            Else ;                Move (RegFlushKey(hKey)) to iError
8431>>>>>            
8431>>>>>            Set phCurrentKey to 0
8432>>>>>        End
8432>>>>>>
8432>>>>>    End_Procedure
8433>>>>>    
8433>>>>>    Function OpenKey String sKeyName Returns Boolean
8435>>>>>        Handle hKey hKeyOpened
8435>>>>>        Integer iError
8435>>>>>        
8435>>>>>        Move 0 to hKeyOpened // initialize it so we can get its address
8436>>>>>        
8436>>>>>        Get phRootKey to hKey
8437>>>>>        Move (RegOpenKeyEx(hKey, ToAnsi(sKeyName), 0, pfAccessRights(Self), AddressOf(hKeyOpened))) to iError
8438>>>>>        If (iError =0) ;            Set phCurrentKey to hKeyOpened
8441>>>>>        
8441>>>>>        Function_Return (iError=0)
8442>>>>>    End_Function
8443>>>>>    
8443>>>>>    Procedure WriteDword String sValue DWord dwValueData
8445>>>>>        Handle hKey
8445>>>>>        Integer iError
8445>>>>>        DWord dwData
8445>>>>>        String sError
8445>>>>>        
8445>>>>>        Move dwValueData to dwData
8446>>>>>        Get phCurrentKey to hKey
8447>>>>>        Move (RegSetValueEx(hKey, ToAnsi(sValue), 0, REG_DWORD, AddressOf(dwData), SizeOfType(DWord))) to iError
8448>>>>>        If iError Begin
8450>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8451>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8452>>>>>>
8452>>>>>        End
8452>>>>>>
8452>>>>>    End_Procedure
8453>>>>>    
8453>>>>>    Procedure WriteString String sValue String sValueData
8455>>>>>        Handle hKey
8455>>>>>        Integer iError cbData
8455>>>>>        String sError
8455>>>>>        
8455>>>>>        If (sValueData = "") Begin
8457>>>>>            Move (Character(0)) to sValueData
8458>>>>>            Move 1 to cbData
8459>>>>>        End
8459>>>>>>
8459>>>>>        Else Begin
8460>>>>>            Move (Length(sValueData) +1) to cbData
8461>>>>>        End
8461>>>>>>
8461>>>>>        Move (ToAnsi(sValueData)) to sValueData
8462>>>>>        Get phCurrentKey to hKey
8463>>>>>        Move (RegSetValueEx(hKey, ToAnsi(sValue), 0, REG_SZ, AddressOf(sValueData), cbData)) to iError
8464>>>>>        If iError Begin
8466>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8467>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8468>>>>>>
8468>>>>>        End
8468>>>>>>
8468>>>>>    End_Procedure
8469>>>>>    
8469>>>>>    Procedure WriteBinary String sValueName Address aValueData Integer iDataLength
8471>>>>>        Handle hKey
8471>>>>>        Integer iError
8471>>>>>        String sError
8471>>>>>        
8471>>>>>        Get phCurrentKey to hKey
8472>>>>>        Move (RegSetValueEx(hKey, ToAnsi(sValueName), 0, REG_BINARY, aValueData, iDataLength)) to iError
8473>>>>>        If iError Begin
8475>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8476>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8477>>>>>>
8477>>>>>        End
8477>>>>>>
8477>>>>>    End_Procedure
8478>>>>>    
8478>>>>>    Function ReadDword String sValueName Returns DWord
8480>>>>>        Handle hKey
8480>>>>>        Integer iError
8480>>>>>        DWord dwValueData dwValueDataLength
8480>>>>>        String sError
8480>>>>>        
8480>>>>>        Move 0           to dwValueData
8481>>>>>        Move (SizeOfType(DWord)) to dwValueDataLength
8482>>>>>        
8482>>>>>        Get phCurrentKey to hKey
8483>>>>>        Move (RegQueryValueEx(hKey, ToAnsi(sValueName), 0, 0, AddressOf(dwValueData), AddressOf(dwValueDataLength))) to iError
8484>>>>>        If iError Begin
8486>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8487>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8488>>>>>>
8488>>>>>        End
8488>>>>>>
8488>>>>>        
8488>>>>>        Function_Return dwValueData
8489>>>>>    End_Function
8490>>>>>    
8490>>>>>    Function ReadString String sValueName Returns String
8492>>>>>        Handle hKey
8492>>>>>        Integer iError
8492>>>>>        String sValueData
8492>>>>>        DWord dwValueDataLength
8492>>>>>        Pointer lpsValueData
8492>>>>>        String sError
8492>>>>>        
8492>>>>>        Move (Repeat(character(0), ValueLength(Self, sValueName))) to sValueData
8493>>>>>        Move (AddressOf(sValueData)) to lpsValueData
8494>>>>>        
8494>>>>>        Move (Length(sValueData)) to dwValueDataLength
8495>>>>>        
8495>>>>>        Get phCurrentKey to hKey
8496>>>>>        Move (RegQueryValueEx(hKey, ToAnsi(sValueName), 0, 0, lpsValueData, AddressOf(dwValueDataLength))) to iError
8497>>>>>        If iError Begin
8499>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8500>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8501>>>>>>
8501>>>>>        End
8501>>>>>>
8501>>>>>        
8501>>>>>        Function_Return (ToOem(CString(sValueData)))
8502>>>>>    End_Function
8503>>>>>    
8503>>>>>    Function ReadBinary String sValueName Address aValueData Integer iDataLength Returns Boolean
8505>>>>>        Handle hKey
8505>>>>>        Integer iError
8505>>>>>        String sError
8505>>>>>        
8505>>>>>        Get phCurrentKey to hKey
8506>>>>>        Move (RegQueryValueEx(hKey, ToAnsi(sValueName), 0, 0, aValueData, AddressOf(iDataLength))) to iError
8507>>>>>        If iError Begin
8509>>>>>            Move (FormatWinError(iError)) to sError // raise an error if the Query failed
8510>>>>>            Error DFERR_REGISTRY sError // Generic Windows Error
8511>>>>>>
8511>>>>>        End
8511>>>>>>
8511>>>>>        
8511>>>>>        Function_Return (iDataLength >0)
8512>>>>>    End_Function
8513>>>>>    
8513>>>>>    
8513>>>>>    // Private....
8513>>>>>    Function GetBaseKey Returns Handle
8515>>>>>        Handle hBaseKey
8515>>>>>        If (phCurrentKey(Self) = 0) ;            Get phRootKey to hBaseKey
8518>>>>>        Else ;            Get phCurrentKey to hBaseKey
8520>>>>>        
8520>>>>>        Function_Return hBaseKey
8521>>>>>    End_Function
8522>>>>>    
8522>>>>>    Function GetKey String sKeyName Returns Handle
8524>>>>>        Handle hKeyOpened
8524>>>>>        Integer iError
8524>>>>>        
8524>>>>>        Move 0 to hKeyOpened // initialize so we can get its address
8525>>>>>        
8525>>>>>        Move (RegOpenKeyEx(GetBaseKey(Self), ToAnsi(sKeyName), 0, pfAccessRights(Self), AddressOf(hKeyOpened))) to iError
8526>>>>>        
8526>>>>>        If (iError =0) ;            Function_Return hKeyOpened
8529>>>>>        Else ;            Function_Return 0
8531>>>>>    End_Function
8532>>>>>    
8532>>>>>    // Public
8532>>>>>    Function KeyExists String sKeyName Returns Boolean
8534>>>>>        Handle hKey
8534>>>>>        Integer iVoid
8534>>>>>        
8534>>>>>        Get GetKey sKeyName to hKey
8535>>>>>        If hKey ;            Move (RegCloseKey(hKey)) to iVoid
8538>>>>>        Function_Return (hKey <>0)
8539>>>>>    End_Function
8540>>>>>    
8540>>>>>    Function ValueExists String sValueName Returns Boolean
8542>>>>>        // Determines whether a Value exists for the currently-opened Key.
8542>>>>>        Integer iError
8542>>>>>        DWord dwDataType
8542>>>>>        Move 0 to dwDataType // must initialize the variable to get its address
8543>>>>>        
8543>>>>>        Move (RegQueryValueEx(phCurrentKey(Self), ToAnsi(sValueName), 0, AddressOf(dwDataType), 0, 0)) to iError
8544>>>>>        
8544>>>>>        Function_Return (iError=0)
8545>>>>>    End_Function
8546>>>>>    
8546>>>>>    Function DeleteKey String sKeyName Returns Boolean // Deleted successfully?
8548>>>>>        Function_Return (ShDeleteKey(phRootKey(Self), ToAnsi(sKeyName)) =0)
8549>>>>>    End_Function
8550>>>>>    
8550>>>>>    Function DeleteValue String sValueName Returns Boolean // Deleted successfully?
8552>>>>>        Function_Return (RegDeleteValue(phCurrentKey(Self), ToAnsi(sValueName)) =0)
8553>>>>>    End_Function
8554>>>>>    
8554>>>>>    Function GetSubkeys Handle hoArray Returns Integer // count of Values
8556>>>>>        Integer iError
8556>>>>>        Integer icValue iLongestSubkey
8556>>>>>        Handle hKey
8556>>>>>        DWord dwSubkeyNameLength
8556>>>>>        String sSubkeyName
8556>>>>>        tWinFileTime FileTime
8556>>>>>        tWinFileTime FileTime
8556>>>>>        
8556>>>>>        Get LongestSubkeyLength to iLongestSubkey
8557>>>>>        Move (Repeat(character(0), iLongestSubkey +1)) to sSubkeyName
8558>>>>>        
8558>>>>>        Get phCurrentKey to hKey
8559>>>>>        Repeat
8559>>>>>>
8559>>>>>            Move (iLongestSubkey +1) to dwSubkeyNameLength
8560>>>>>            
8560>>>>>            Move (RegEnumKeyEx(hKey, icValue, AddressOf(sSubkeyName), AddressOf(dwSubkeyNameLength), 0, 0, 0, AddressOf(FileTime))) to iError
8561>>>>>            If (iError =0) Begin
8563>>>>>                Increment icValue
8564>>>>>                Set Value of hoArray (Item_Count(hoArray)) to (ToOem(CString(sSubkeyName)))
8565>>>>>            End
8565>>>>>>
8565>>>>>        Until (iError)
8567>>>>>        Function_Return icValue
8568>>>>>        
8568>>>>>    End_Function
8569>>>>>    
8569>>>>>    Function GetValues Handle hoArray Returns Integer // count of Values
8571>>>>>        Integer iError
8571>>>>>        Integer icValue iLongestValue
8571>>>>>        Handle hKey
8571>>>>>        DWord dwValueNameLength
8571>>>>>        String sValueName sValueNameSize
8571>>>>>        Pointer lpsValueName
8571>>>>>        
8571>>>>>        Get LongestValueLength to iLongestValue
8572>>>>>        Move (Repeat(character(0), iLongestValue +1)) to sValueName
8573>>>>>        Move (AddressOf(sValueName)) to lpsValueName
8574>>>>>        
8574>>>>>        Get phCurrentKey to hKey
8575>>>>>        Repeat
8575>>>>>>
8575>>>>>            Move (iLongestValue +1) to dwValueNameLength
8576>>>>>            Move (RegEnumValue(hKey, icValue, lpsValueName, AddressOf(dwValueNameLength), 0, 0, 0, 0)) to iError
8577>>>>>            If (iError =0) Begin
8579>>>>>                Increment icValue
8580>>>>>                Set Value of hoArray (Item_Count(hoArray)) to (ToOem(CString(sValueName)))
8581>>>>>            End
8581>>>>>>
8581>>>>>        Until (iError)
8583>>>>>        Function_Return icValue
8584>>>>>        
8584>>>>>    End_Function
8585>>>>>    
8585>>>>>End_Class
8586>>>Use cVersionInfo.pkg
Including file: cVersionInfo.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cVersionInfo.pkg)
8586>>>>>Use VdfBase.pkg
8586>>>>>Use DLL.pkg
8586>>>>>Use tWinStructs.pkg
8586>>>>>Use WinKern.pkg
8586>>>>>
8586>>>>>Define VS_FF_DEBUG         for |CI$00000001
8586>>>>>Define VS_FF_PRERELEASE    for |CI$00000002
8586>>>>>Define VS_FF_PATCHED       for |CI$00000004
8586>>>>>Define VS_FF_PRIVATEBUILD  for |CI$00000008
8586>>>>>Define VS_FF_INFOINFERRED  for |CI$00000010
8586>>>>>Define VS_FF_SPECIALBUILD  for |CI$00000020
8586>>>>>
8586>>>>>External_Function GetFileVersionInfoSize "GetFileVersionInfoSizeA" version.dll ;    Pointer aFilename ;    Pointer lpdwHandle ;    Returns DWord
8587>>>>>
8587>>>>>External_Function GetFileVersionInfo "GetFileVersionInfoA" version.dll ;    Pointer sFilename ;    DWord dwHandle ;    DWord dwLen ;    Address aData ;    Returns Integer
8588>>>>>
8588>>>>>External_Function VerQueryValue "VerQueryValueA" version.dll ;    Address aBlock ;    Address aSubBlock ;    Address aaBuffer ;    Address puLen ;    Returns Integer
8589>>>>>
8589>>>>>
8589>>>>>Class cVersionInfo is a cObject
8590>>>>>    Procedure Construct_Object
8592>>>>>        Forward Send Construct_Object
8594>>>>>        
8594>>>>>        
8594>>>>>        Property Integer piVersionMajor
8595>>>>>        Property Integer piVersionMinor
8596>>>>>        Property Integer piVersionRelease
8597>>>>>        Property Integer piVersionBuild
8598>>>>>        
8598>>>>>        Property Boolean pbIncluded
8599>>>>>        Property Boolean pbSpecialBuild
8600>>>>>        Property Boolean pbPrivateBuild
8601>>>>>        
8601>>>>>    End_Procedure
8602>>>>>    
8602>>>>>    Procedure DoCreate String sFileName
8604>>>>>        DWord dwHandle
8604>>>>>        Integer iInfoSize iVerSize iSuccess iVersion iVoid iFlags
8604>>>>>        String sData
8604>>>>>        String sVersionBuffer
8604>>>>>        tWinVs_FixedFileInfo VsFixedFileInfo
8604>>>>>        tWinVs_FixedFileInfo VsFixedFileInfo
8604>>>>>        String sSubBlock
8604>>>>>        Address aVsFixedFileInfo
8604>>>>>        
8604>>>>>        Move 0 to aVsFixedFileInfo
8605>>>>>        Move 0 to dwHandle
8606>>>>>        Move 0 to iVerSize
8607>>>>>        
8607>>>>>        Move (GetFileVersionInfoSize(AddressOf(sFilename), AddressOf(dwHandle))) to iInfoSize
8608>>>>>        Set pbIncluded to (iInfoSize <>0)
8609>>>>>        
8609>>>>>        If (pbIncluded(Self)) Begin
8611>>>>>            Move (Repeat(Character(0), iInfoSize)) to sData
8612>>>>>            Move (GetFileVersionInfo(AddressOf(sFilename), 0, iInfoSize, AddressOf(sData))) to iSuccess
8613>>>>>            
8613>>>>>            If (iSuccess <>0) Begin
8615>>>>>                Move "\" to sSubBlock
8616>>>>>                If (VerQueryValue(AddressOf(sData), AddressOf(sSubBlock), AddressOf(aVsFixedFileInfo), AddressOf(iVerSize))) Begin
8618>>>>>                    Move (memcopy(AddressOf(VsFixedFileInfo), aVsFixedFileInfo, iVerSize)) to iVoid // copy the structure
8619>>>>>                    
8619>>>>>                    Move VsFixedFileInfo.dwFileVersionMS to iVersion
8620>>>>>                    Set piVersionMajor to (Hi(iVersion))
8621>>>>>                    Set piVersionMinor to (Low(iVersion))
8622>>>>>                    
8622>>>>>                    Move VsFixedFileInfo.dwFileVersionLS to iVersion
8623>>>>>                    Set piVersionRelease to (Hi(iVersion))
8624>>>>>                    Set piVersionBuild   to (Low(iVersion))
8625>>>>>                    
8625>>>>>                    Move VsFixedFileInfo.dwFileFlags to iFlags
8626>>>>>                    Set pbSpecialBuild    to (iFlags iand VS_FF_SPECIALBUILD)
8627>>>>>                    Set pbPrivateBuild    to (iFlags iand VS_FF_PRIVATEBUILD)
8628>>>>>                End
8628>>>>>>
8628>>>>>            End
8628>>>>>>
8628>>>>>            
8628>>>>>        End
8628>>>>>>
8628>>>>>    End_Procedure
8629>>>>>    
8629>>>>>End_Class
8630>>>Use GlobalFunctionsProcedures.pkg
8630>>>Use tWinStructs.pkg
8630>>>Use HelpSystemConstants.pkg // constants used by help system (not used by web)
8630>>>
8630>>>Register_Function phoWorkspace Returns Handle
8630>>>Register_Function phoCommandLine Returns Handle
8630>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
8630>>>Register_Function GetApplicationName Returns String
8630>>>Register_Function GetApplicationFileName Returns String
8630>>>
8630>>>Register_Function Statusbar_State Returns Integer
8630>>>Register_Function Toolbar_State Returns Integer
8630>>>Register_Procedure Set Statusbar_State
8630>>>Register_Procedure Set Toolbar_State
8630>>>
8630>>>
8630>>>Class cApplication is a cObject
8631>>>    Procedure Construct_Object
8633>>>        Forward Send Construct_Object
8635>>>        
8635>>>        Move Self to ghoApplication
8636>>>        
8636>>>        Property Handle phoVersionInfo
8637>>>        Property Handle phoWorkspace
8638>>>        Property Handle phoCommandLine
8639>>>        Property Handle phoMainPanel       // main panel will set this for us.
8640>>>        Property String psHelpFile         // type of file is determined by peHelpType
8641>>>        Property Integer peHelpType htWinHelp // htNoHelp htHtmlHelp htWinHelp
8642>>>        
8642>>>        Property String psCompany "Data Access Worldwide"
8643>>>        Property String psProduct "DataFlex Applications"
8644>>>        Property String psVersion C_DFVersion
8645>>>        Property String psProgram (Module_Name(desktop))
8646>>>        
8646>>>        // set to '' to stop the auto open workspace behavior
8646>>>        Property String psAutoOpenWorkspace 'Config.ws'
8647>>>        
8647>>>        
8647>>>        Property Boolean pbPreserveEnvironment True
8648>>>        
8648>>>        Object oCommandLine is a cCommandLine
8650>>>            Delegate Set phoCommandLine to Self
8652>>>        End_Object
8653>>>        
8653>>>        Object oWorkspace is a cWorkspace
8655>>>            Delegate Set phoWorkspace to Self
8657>>>        End_Object
8658>>>        
8658>>>        Object oVersionInfo is a cVersionInfo
8660>>>            Delegate Set phoVersionInfo to Self
8662>>>            Send DoCreate (GetApplicationFileName(parent(Self)))
8663>>>        End_Object
8664>>>        
8664>>>        Set pbUseWindowsFont to True
8665>>>        
8665>>>    End_Procedure
8666>>>    
8666>>>    Procedure Destroy_Object
8668>>>        If (ghoApplication=Self) Begin
8670>>>            Move 0 to ghoApplication
8671>>>        End
8671>>>>
8671>>>        Forward Send Destroy_Object
8673>>>    End_Procedure
8674>>>    
8674>>>    // Determines if the Enter key should act like the Tab key (and send msg_Next)
8674>>>    // The use of a global variable, gbKEnterNext, makes this an application-wide property
8674>>>    Procedure Set pbEnterKeyAsTabKey Boolean bNext
8676>>>        Move bNext to gbKEnterNext
8677>>>    End_Procedure
8678>>>    
8678>>>    Function pbEnterKeyAsTabKey Returns Boolean
8680>>>        Function_Return gbKEnterNext
8681>>>    End_Function
8682>>>    
8682>>>    Procedure DoLoadEnvironment Handle hoContainer Boolean bProgram
8684>>>// not used with webapp
8684>>>        Handle hoRegistry hoCommandBars
8684>>>        Handle hMonitor
8684>>>        Integer iError cxy
8684>>>        tWinWindowPlacement WindowPlacement
8684>>>        tWinWindowPlacement WindowPlacement
8684>>>        String sKey
8684>>>        Boolean bSuccess
8684>>>        String sObjectName
8684>>>        
8684>>>        If (pbPreserveEnvironment(Self)) Begin
8686>>>            Get Create U_cRegistry to hoRegistry
8687>>>            Set pfAccessRights of hoRegistry to KEY_READ
8688>>>            
8688>>>            Get RegistryKeyString to sKey
8689>>>            
8689>>>            If (bProgram = False) Begin
8691>>>                Move (sKey +"\WINDOWS") to sKey
8692>>>                Get Object_Label of hoContainer to sObjectName  // just get the local name
8693>>>                Move (sKey +"\" +sObjectName) to sKey
8694>>>            End
8694>>>>
8694>>>            Else ;                Move (sKey + "\Preferences") to sKey
8696>>>            
8696>>>            Get OpenKey of hoRegistry sKey to bSuccess
8697>>>            
8697>>>            If bSuccess Begin
8699>>>                If (ValueExists(hoRegistry, 'Placement')) Begin
8701>>>                    Get ReadBinary of hoRegistry "Placement" (AddressOf(WindowPlacement)) (SizeOfType(tWinWindowPlacement)) to bSuccess
8702>>>                    If bSuccess Begin
8704>>>                        // Do not restore size if the window is not resizable
8704>>>                        If (Border_Style(hoContainer) <> BORDER_THICK) Begin
8706>>>                            // restore always works with outer size
8706>>>                            Get GuiWindowSize     of hoContainer to cxy
8707>>>                            Move (WindowPlacement.NormalPosition.left + Low(cxy)) to WindowPlacement.NormalPosition.right
8708>>>                            Move (WindowPlacement.NormalPosition.top + Hi(cxy)) to WindowPlacement.NormalPosition.bottom
8709>>>                        End
8709>>>>
8709>>>                        
8709>>>                        // Test that the main window's placement location will appear on some connected monitor. If none
8709>>>                        // of the main window is visible then set the location to 0,0 and adjust the size....
8709>>>                        If (bProgram) Begin
8711>>>                            // Test the top left point
8711>>>                            Move (MonitorFromPoint(WindowPlacement.NormalPosition.left, WindowPlacement.NormalPosition.top, MONITOR_DEFAULTONNULL)) to hMonitor
8712>>>                            
8712>>>                            If (hMonitor = 0) Begin
8714>>>                                // test the bottom right point
8714>>>                                Move (MonitorFromPoint(WindowPlacement.NormalPosition.right, WindowPlacement.NormalPosition.bottom, MONITOR_DEFAULTONNULL)) to hMonitor
8715>>>                            End
8715>>>>
8715>>>                            
8715>>>                            // hMonitor = 0 means that the window location is not in any current monitor (probably the monitor layout has changed)
8715>>>                            // or that the window begins and ends outside all monitors (even though it may span across some monitor). We will adjust!
8715>>>                            If (hMonitor = 0) Begin
8717>>>                                Send ResetWindowPos (&WindowPlacement.NormalPosition)
8718>>>                            End
8718>>>>
8718>>>                        End
8718>>>>
8718>>>                        
8718>>>                        // Set the placement
8718>>>                        Move (SetWindowPlacement(Window_Handle(hoContainer), AddressOf(WindowPlacement))) to bSuccess
8719>>>                    End
8719>>>>
8719>>>                End
8719>>>>
8719>>>                If bProgram Begin
8721>>>                    Get phoCommandBars of hoContainer to hoCommandBars
8722>>>                    If not hoCommandBars Begin
8724>>>                        If (ValueExists(hoRegistry, 'IsStatusBarVisible')) ;                            Set Statusbar_State of hoContainer to (ReadDword(hoRegistry, 'IsStatusBarVisible'))
8727>>>                        If (ValueExists(hoRegistry, 'IsToolBarVisible'))   ;                            Set Toolbar_State   of hoContainer to (ReadDword(hoRegistry, 'IsToolBarVisible'))
8730>>>                    End
8730>>>>
8730>>>                End
8730>>>>
8730>>>                
8730>>>                Send CloseKey of hoRegistry
8731>>>            End
8731>>>>
8731>>>            
8731>>>            Send Destroy of hoRegistry
8732>>>        End
8732>>>>
8732>>>    End_Procedure
8733>>>    
8733>>>    Procedure DoSaveEnvironment Handle hoContainer Boolean bProgram
8735>>>// not used with webapp
8735>>>        Handle hoRegistry
8735>>>        Integer iError
8735>>>        tWinWindowPlacement WindowPlacement
8735>>>        tWinWindowPlacement WindowPlacement
8735>>>        String sKey
8735>>>        Boolean bSuccess
8735>>>        Integer eShowCmd
8735>>>        String sObjectName
8735>>>        
8735>>>        If (pbPreserveEnvironment(Self)) Begin
8737>>>            Get Create U_cRegistry to hoRegistry
8738>>>            Get RegistryKeyString to sKey
8739>>>            
8739>>>            If (bProgram = False) Begin
8741>>>                Move (sKey +"\WINDOWS") to sKey
8742>>>                Get Object_Label of hoContainer to sObjectName  // just get the local name
8743>>>                Move (sKey +"\" +sObjectName) to sKey
8744>>>            End
8744>>>>
8744>>>            Else ;                Move (sKey +"\Preferences") to sKey
8746>>>            
8746>>>            Get CreateKey of hoRegistry sKey to iError
8747>>>            If (iError = 0) Begin
8749>>>                Move (SizeOfType(tWinWindowPlacement)) to WindowPlacement.length
8750>>>                Move (GetWindowPlacement(Window_Handle(hoContainer), AddressOf(WindowPlacement))) to bSuccess
8751>>>                If bSuccess Begin
8753>>>                    // if minimized, assume restored, as we don't want to restart minimized!
8753>>>                    If (WindowPlacement.showCmd = SW_SHOWMINIMIZED) Begin
8755>>>                        Move SW_SHOWNORMAL to WindowPlacement.showCmd
8756>>>                    End
8756>>>>
8756>>>                    Send WriteBinary of hoRegistry "Placement" (AddressOf(WindowPlacement)) WindowPlacement.length
8757>>>                End
8757>>>>
8757>>>                
8757>>>                If bProgram Begin
8759>>>                    Send WriteDword of hoRegistry 'IsStatusBarVisible' (Statusbar_State(hoContainer))
8760>>>                    Send WriteDword of hoRegistry 'IsToolBarVisible'   (Toolbar_State(hoContainer))
8761>>>                End
8761>>>>
8761>>>                
8761>>>                
8761>>>                Send CloseKey of hoRegistry
8762>>>            End
8762>>>>
8762>>>            
8762>>>            Send Destroy of hoRegistry
8763>>>        End
8763>>>>
8763>>>    End_Procedure
8764>>>    
8764>>>    
8764>>>    Procedure ResetWindowPos tWinRect ByRef WindowPos
8766>>>        Integer ixySize ixSize iySize
8766>>>        Integer ixOffset iyOffset
8766>>>        
8766>>>        // first calculate the offset needed to move onto the main monitor at 0,0
8766>>>        Move (0 - WindowPos.left) to ixOffset
8767>>>        Move (0 - WindowPos.top) to iyOffset
8768>>>        
8768>>>        Move 0 to WindowPos.left
8769>>>        Move 0 to WindowPos.top
8770>>>        
8770>>>        Move (WindowPos.right + ixOffset) to WindowPos.right
8771>>>        Move (WindowPos.bottom + iyOffset) to WindowPos.bottom
8772>>>        
8772>>>        // also make sure that the size of the window is <= the size of the main monitor
8772>>>        Move (GUIScreen_Size(1)) to ixySize    // parameter of 1 means return "available" screen size
8773>>>        Move (low(ixySize))      to ixSize
8774>>>        Move (hi(ixySize))       to iySize
8775>>>        
8775>>>        Move (ixSize min WindowPos.right) to WindowPos.right
8776>>>        Move (iySize min WindowPos.bottom) to WindowPos.bottom
8777>>>    End_Procedure
8778>>>    
8778>>>    
8778>>>    Function RegistryKeyString Returns String
8780>>>        String sCompany sProduct sVersion sProgram
8780>>>        
8780>>>        Get psCompany to sCompany
8781>>>        Get psProduct to sProduct
8782>>>        Get psVersion to sVersion
8783>>>        Get psProgram to sProgram
8784>>>        
8784>>>        If (sCompany = "") ;            Move "Data Access Worldwide" to sCompany
8787>>>        If (sProduct = "") ;            Move "DataFlex Applications" to sProduct
8790>>>        If (sVersion = "") ;            Move C_DFVersion             to sVersion
8793>>>        If (sProgram ="") ;            Move (Module_Name(desktop))   to sProgram
8796>>>        
8796>>>        Function_Return ("SOFTWARE\" +sCompany +"\" +sProduct +"\" +sVersion +"\" +sProgram)
8797>>>    End_Function
8798>>>    
8798>>>    Procedure WriteString String sSubKey String sValueName String sValueData
8800>>>        String sKey
8800>>>        Handle hoRegistry
8800>>>        Integer iError
8800>>>        
8800>>>        Get Create U_cRegistry to hoRegistry
8801>>>        Get RegistryKeyString to sKey
8802>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
8805>>>        Get CreateKey of hoRegistry sKey to iError
8806>>>        If (iError = 0) Begin
8808>>>            Send WriteString of hoRegistry sValueName sValueData
8809>>>            Send CloseKey of hoRegistry
8810>>>        End
8810>>>>
8810>>>        
8810>>>        Send Destroy of hoRegistry
8811>>>    End_Procedure
8812>>>    Procedure WriteDword String sSubKey String sValueName DWord dwValueData
8814>>>        String sKey
8814>>>        Handle hoRegistry
8814>>>        Integer iError
8814>>>        
8814>>>        Get Create U_cRegistry to hoRegistry
8815>>>        Get RegistryKeyString to sKey
8816>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
8819>>>        Get CreateKey of hoRegistry sKey to iError
8820>>>        If (iError = 0) Begin
8822>>>            Send WriteDword of hoRegistry sValueName dwValueData
8823>>>            Send CloseKey of hoRegistry
8824>>>        End
8824>>>>
8824>>>        
8824>>>        Send Destroy of hoRegistry
8825>>>    End_Procedure
8826>>>    Procedure WriteBinary String sSubKey String sValueName Address aValueData Integer iDataLength
8828>>>        String sKey
8828>>>        Handle hoRegistry
8828>>>        Integer iError
8828>>>        
8828>>>        Get Create U_cRegistry to hoRegistry
8829>>>        Get RegistryKeyString to sKey
8830>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
8833>>>        Get CreateKey of hoRegistry sKey to iError
8834>>>        If (iError = 0) Begin
8836>>>            Send WriteBinary of hoRegistry sValueName aValueData iDataLength
8837>>>            Send CloseKey of hoRegistry
8838>>>        End
8838>>>>
8838>>>        
8838>>>        Send Destroy of hoRegistry
8839>>>    End_Procedure
8840>>>    
8840>>>    // returns true if both sub-key and value exists.
8840>>>    Function ValueExists String sSubKey String sValueName Returns Boolean
8842>>>        String sKey
8842>>>        Handle hoRegistry
8842>>>        Boolean bOK
8842>>>        Get Create U_cRegistry to hoRegistry
8843>>>        Get RegistryKeyString to sKey
8844>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
8847>>>        Get OpenKey of hoRegistry sKey to bOk
8848>>>        If (bOK) Begin
8850>>>            Move (ValueExists(hoRegistry, sValueName)) to bOk
8851>>>            Send CloseKey of hoRegistry
8852>>>        End
8852>>>>
8852>>>        Send Destroy of hoRegistry
8853>>>        Function_Return bOk
8854>>>    End_Function
8855>>>    
8855>>>    Function ReadString String sSubKey String sValueName String sDefault Returns String
8857>>>        String sKey sData
8857>>>        Handle hoRegistry
8857>>>        Boolean bOK
8857>>>        
8857>>>        Move sDefault to sData
8858>>>        Get Create U_cRegistry to hoRegistry
8859>>>        Get RegistryKeyString to sKey
8860>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
8863>>>        Get OpenKey of hoRegistry sKey to bOk
8864>>>        If (bOK) Begin
8866>>>            If (ValueExists(hoRegistry, sValueName)) ;                Get ReadString of hoRegistry sValueName to sData
8869>>>            Send CloseKey of hoRegistry
8870>>>        End
8870>>>>
8870>>>        
8870>>>        Send Destroy of hoRegistry
8871>>>        Function_Return sData
8872>>>    End_Function
8873>>>    
8873>>>    Function ReadDword String sSubKey String sValueName DWord dwDefault Returns DWord
8875>>>        String sKey
8875>>>        DWord dwData
8875>>>        Handle hoRegistry
8875>>>        Boolean bOK
8875>>>        
8875>>>        Move dwDefault to dwData
8876>>>        Get Create U_cRegistry to hoRegistry
8877>>>        Get RegistryKeyString to sKey
8878>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
8881>>>        Get OpenKey of hoRegistry sKey to bOk
8882>>>        If bOK Begin
8884>>>            If (ValueExists(hoRegistry, sValueName)) ;                Get ReadDword of hoRegistry sValueName to dwData
8887>>>            Send CloseKey of hoRegistry
8888>>>        End
8888>>>>
8888>>>        
8888>>>        Send Destroy of hoRegistry
8889>>>        Function_Return dwData
8890>>>    End_Function
8891>>>    
8891>>>    Function ReadBinary String sSubKey String sValueName Address aValueData Integer iDataLength Returns Boolean
8893>>>        String sKey
8893>>>        Handle hoRegistry
8893>>>        Boolean bOK bSuccess
8893>>>        
8893>>>        Get Create U_cRegistry to hoRegistry
8894>>>        Get RegistryKeyString to sKey
8895>>>        If (sSubKey <>"") ;            Move (sKey +'\' +sSubKey) to sKey
8898>>>        Get OpenKey of hoRegistry sKey to bOk
8899>>>        If bOK Begin
8901>>>            Get ReadBinary of hoRegistry sValueName aValueData iDataLength to bSuccess
8902>>>            Send CloseKey of hoRegistry
8903>>>        End
8903>>>>
8903>>>        
8903>>>        Send Destroy of hoRegistry
8904>>>        Function_Return bSuccess
8905>>>    End_Function
8906>>>    
8906>>>    Procedure DoOpenWorkspace String sWorkspace
8908>>>        // Tries to open in this order:
8908>>>        // 1) if absolute path, use that; otherwise
8908>>>        // 2) try to open in the path of the EXE; otherwise
8908>>>        // 3) load it via the Registered list
8908>>>        
8908>>>        Integer eOpened
8908>>>        String sError sWSFile
8908>>>        Handle hoWorkspace
8908>>>        Boolean bChangingWorkspace
8908>>>        
8908>>>        // As soon as an open is attempted, the application's object psAutoOpenWorkspace property
8908>>>        // is cleared. This way any attempt to manually open a workspace during its construction,
8908>>>        // which includes OnCreate, will stop the object from attempting to automatically open the
8908>>>        // workspace. This was added to make psAutoOpenWorkspace compatible with older applications.
8908>>>        // Typically these application will open a workspace in OnCreate. If this happens we assume
8908>>>        // that there should be no automatic opening of a worskpace.
8908>>>        Set psAutoOpenWorkspace to ""
8909>>>        
8909>>>        Get phoWorkspace to hoWorkspace
8910>>>        
8910>>>        Get pbWorkspaceOpened of hoWorkspace to bChangingWorkspace
8911>>>        If (bChangingWorkspace and ghoConnection) Begin
8913>>>            Send AutoDisconnect
8914>>>        End
8914>>>>
8914>>>        
8914>>>        Get OpenWorkspaceFile of hoWorkspace sWorkspace to eOpened
8915>>>        If (eOpened = wsWorkspaceFileNotFound) Begin
8917>>>            If (IsRegistered(hoWorkspace, sWorkspace) =True) Begin
8919>>>                Get OpenWorkspace of hoWorkspace sWorkspace to eOpened
8920>>>            End
8920>>>>
8920>>>        End
8920>>>>
8920>>>        If (eOpened <> wsWorkspaceOpened) Begin
8922>>>            Get OpenWorkspaceErrorMessage of hoWorkspace eOpened to sError
8923>>>            Get psWorkspaceWSFile of hoWorkspace to sWSFile
8924>>>            Error DFERR_CAPPLICATION (SFormat(C_$TheProgramCannotRun, sWorkspace) + ":\n\n" + If(sWSFile<>"",sWSfile+"\n\n","") +sError)
8925>>>>
8925>>>            Abort
8926>>>>
8926>>>        End
8926>>>>
8926>>>        Else Begin
8927>>>            Send AutoConnect
8928>>>            Send OnWorkspaceOpened
8929>>>        End
8929>>>>
8929>>>    End_Procedure
8930>>>    
8930>>>    Procedure AutoConnect
8932>>>        If (ghoConnection) Begin
8934>>>            Send AutoConnect of ghoConnection
8935>>>        End
8935>>>>
8935>>>    End_Procedure
8936>>>    
8936>>>    Procedure AutoDisconnect
8938>>>        If (ghoConnection) Begin
8940>>>            Send AutoDisconnect of ghoConnection
8941>>>        End
8941>>>>
8941>>>    End_Procedure
8942>>>    
8942>>>    // send after a workspace is successfully opened and connected
8942>>>    Procedure OnWorkspaceOpened
8944>>>    End_Procedure
8945>>>    
8945>>>    Procedure OnCreate
8947>>>        // Event called when the Application object is ready to be used
8947>>>        // to open a Workspace, etc.
8947>>>    End_Procedure
8948>>>    
8948>>>    Procedure End_Construct_Object
8950>>>        String sName
8950>>>        Forward Send End_Construct_Object
8952>>>        Send OnCreate
8953>>>        // note that psAutoOpenWorkspace will get cleared of OnCreate attempts to open a workspace
8953>>>        Get psAutoOpenWorkspace to sName
8954>>>        If (sName<>"") Begin
8956>>>            Send DoOpenWorkspace sName
8957>>>        End
8957>>>>
8957>>>    End_Procedure
8958>>>    
8958>>>    Function GetApplicationFileName Returns String
8960>>>        // Returns the filename from Windows
8960>>>        Integer iNumChars
8960>>>        String sFilename
8960>>>        
8960>>>        Move (Repeat(Character(0), 1024)) to sFileName
8961>>>        Move (GetModuleFileName(0, AddressOf(sFilename), 1024)) to iNumChars
8962>>>        
8962>>>        Function_Return (CString(sFilename))
8963>>>    End_Function
8964>>>    
8964>>>    Function GetApplicationPath Returns String
8966>>>        // Returns the path of the Application (no trailing "\")
8966>>>        String sApplicationFileName sPath
8966>>>        Boolean bRemoved
8966>>>        
8966>>>        Get GetApplicationFileName  to sApplicationFileName
8967>>>        Move (PathRemoveFileSpec(AddressOf(sApplicationFileName))) to bRemoved
8968>>>        Move (CString(sApplicationFileName)) to sPath
8969>>>        
8969>>>        If (Right(sPath, 1) ="\") ;            Move (Left(sPath, Length(sPath) -1)) to sPath
8972>>>        Function_Return sPath
8973>>>    End_Function
8974>>>    
8974>>>    Function GetApplicationName Returns String
8976>>>        // Returns the name of the Application (without its Path or Extension)
8976>>>        String sApplicationFileName sApplicationName
8976>>>        Boolean bRemoved
8976>>>        Integer iVoid
8976>>>        
8976>>>        Get GetApplicationFileName to sApplicationFileName
8977>>>        Move (ExtractFileName(sApplicationFileName)) to sApplicationName
8978>>>        Move (PathRemoveExtension(AddressOf(sApplicationName))) to iVoid
8979>>>        Function_Return (CString(sApplicationName))
8980>>>    End_Function
8981>>>    
8981>>>    Function DFRootPath Returns String
8983>>>        String sRoot
8983>>>        Get_Profile_String "Defaults" "VDFRootDir" to sRoot
8986>>>        // Ensure it does not contain a trailing "\"
8986>>>        If (Right(sRoot,1) = "\") Begin
8988>>>            Move (Left(sRoot, Length(sRoot)-1)) to sRoot
8989>>>        End
8989>>>>
8989>>>        Function_Return sRoot
8990>>>    End_Function
8991>>>    
8991>>>    Function DFBinPath Returns String
8993>>>        String sRoot
8993>>>        Get DFRootPath to sRoot
8994>>>        If (sRoot<>"") Begin
8996>>>            Move (sRoot+"\bin") to sRoot
8997>>>        End
8997>>>>
8997>>>        Else Begin
8998>>>            // if the root from the registry (vdfrootdir) is empty, we will assume that the
8998>>>            // bin path must be the same as the application path.
8998>>>            Get GetApplicationPath to sRoot
8999>>>        End
8999>>>>
8999>>>        Function_Return sRoot
9000>>>    End_Function
9001>>>    
9001>>>    // this just directs to the desktop property. If you are using an application object you are
9001>>>    // encouraged to set this here.
9001>>>    Procedure Set pbUseWindowsFont Boolean bUseWindowsFont
9003>>>        Set pbUseWindowsFont of Desktop to bUseWindowsFont
9004>>>    End_Procedure
9005>>>    
9005>>>    Function pbUseWindowsFont Returns Boolean
9007>>>        Boolean bUseWindowsFont
9007>>>        Get pbUseWindowsFont of Desktop to bUseWindowsFont
9008>>>        Function_Return bUseWindowsFont
9009>>>    End_Function
9010>>>    
9010>>>    // this just directs to the desktop property. If you are using an application object you are
9010>>>    // encouraged to set this here.
9010>>>    Procedure Set pbLegacyDialogRatio Boolean bLegacy
9012>>>        Set pbLegacyDialogRatio of Desktop to bLegacy
9013>>>    End_Procedure
9014>>>    
9014>>>    Function pbLegacyDialogRatio Returns Boolean
9016>>>        Boolean bLegacy
9016>>>        Get pbLegacyDialogRatio of Desktop to bLegacy
9017>>>        Function_Return bLegacy
9018>>>    End_Function
9019>>>End_Class
9020>>>
9020>>>
9020>Use Thriftly.pkg
Including file: Thriftly.pkg    (C:\Users\marce\OneDrive\Documentos\Thriftly Developer\Dataflex\Library_x64\AppSrc\Thriftly.pkg)
9020>>>Use UI
9020>>>Use Thriftly.Interface.pkg
Including file: Thriftly.Interface.pkg    (C:\Users\marce\OneDrive\Documentos\Thriftly Developer\Dataflex\Library_x64\AppSrc\Thriftly.Interface.pkg)
9020>>>>>// DataFlex COM proxy classes generated from C:\Program Files (x86)\Thriftly Developer\bin\Thriftly.Interface.dll
9020>>>>>Use FlexCom20.pkg
Including file: FlexCOM20.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\FlexCOM20.pkg)
9020>>>>>>>// Full Flexcom support for automation (cComAutomationObject),
9020>>>>>>>// activeX (cComActiveXControl and document objects (cComDocumentObject)
9020>>>>>>>Use FlexCOM20_Base.pkg // defines basic flexcom symbols and class cComAutomationObject
Including file: FlexCOM20_Base.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\FlexCOM20_Base.pkg)
9020>>>>>>>>>// Flexcom support for automation (cComAutomationObject).
9020>>>>>>>>>// If you want activeX and document objects use FlexCom20.pkg
9020>>>>>>>>>Use VdfBase.pkg
9020>>>>>>>>>Use ComTypes.pkg
Including file: ComTypes.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\ComTypes.pkg)
9020>>>>>>>>>>>Use Variant.pkg
Including file: Variant.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\Variant.pkg)
9020>>>>>>>>>>>>>Use ui
9020>>>>>>>>>>>>>Use errornum.inc
9020>>>>>>>>>>>>>
9020>>>>>>>>>>>>>// OLE VARENUM usage keys (from wtypes.h)
9020>>>>>>>>>>>>>
9020>>>>>>>>>>>>>
9020>>>>>>>>>>>>>External_Function SysAllocString "SysAllocString" oleaut32.dll Pointer pStr Returns Pointer
9021>>>>>>>>>>>>>External_Function SysStringLen "SysStringLen" oleaut32.dll Pointer vStr Returns Integer
9022>>>>>>>>>>>>>
9022>>>>>>>>>>>>>// Returns the character length of the variant string. 
9022>>>>>>>>>>>>>Function VariantStringLength Global Variant bStr Returns Integer
9024>>>>>>>>>>>>>    Address aVariant
9024>>>>>>>>>>>>>    Integer iLen iType
9024>>>>>>>>>>>>>
9024>>>>>>>>>>>>>    Move (AddressOf(bStr)) to aVariant
9025>>>>>>>>>>>>>    Move (DeRefW(aVariant,0)) to iType
9026>>>>>>>>>>>>>    If (iType=OLE_VT_Empty) Begin
9028>>>>>>>>>>>>>        Function_Return 0
9029>>>>>>>>>>>>>    End
9029>>>>>>>>>>>>>>
9029>>>>>>>>>>>>>    If (iType<>OLE_VT_Bstr) Begin
9031>>>>>>>>>>>>>        Error DFERR_BAD_TYPE_EXPRESSION "In variable is not a variant bstr"
9032>>>>>>>>>>>>>>
9032>>>>>>>>>>>>>        Function_Return 0
9033>>>>>>>>>>>>>    End
9033>>>>>>>>>>>>>>
9033>>>>>>>>>>>>>    Move (SysStringLen(DeRefPtr(aVariant,8))) to iLen
9034>>>>>>>>>>>>>    Function_Return iLen
9035>>>>>>>>>>>>>End_Function
9036>>>>>>>>>>>>>
9036>>>>>>>>>>>>>
9036>>>>>>>>>>>>>// returns true if char string in the buffer can fit into a string
9036>>>>>>>>>>>>>Function ValidStringBufferLength Global Address aData Returns Boolean
9038>>>>>>>>>>>>>    Integer iMax
9038>>>>>>>>>>>>>    Get_Argument_Size to iMax
9039>>>>>>>>>>>>>    Function_Return (CStringLength(aData)<=iMax)
9040>>>>>>>>>>>>>End_Function
9041>>>>>>>>>>>>>    
9041>>>>>>>>>>>
9041>>>>>>>>>>>
9041>>>>>>>>>
9041>>>>>>>>>
9041>>>>>>>>>
9041>>>>>>>>>//Enumerations for the peAutoCreate property
9041>>>>>>>>>//acNoAutoCreate - Do not automatically instantiate the COM object upon VDF object creation.
9041>>>>>>>>>//You must manually instantiate the COM object using CreateComObject. This is the default
9041>>>>>>>>>//for cComAutomation.
9041>>>>>>>>>Define acNoAutoCreate for 0
9041>>>>>>>>>//acAutoCreate - Automatically instantiate the COM object upon VDF object creation.
9041>>>>>>>>>//You won't need to manually instantiate the COM object. This is the default
9041>>>>>>>>>//for cComActiveXControl
9041>>>>>>>>>Define acAutoCreate for 1
9041>>>>>>>>>//acDeferredAutoCreate - Automatically instantiate the COM object during Page_Object,
9041>>>>>>>>>//and automatically destroy the COM object during Page_Delete. Use this setting only
9041>>>>>>>>>//if acAutoCreate causes problems.
9041>>>>>>>>>Define acDeferredAutoCreate for 2
9041>>>>>>>>>
9041>>>>>>>>>Class cComAutomationObject is a DFComAutomationObject
9042>>>>>>>>>    Procedure Construct_Object
9044>>>>>>>>>        Forward Send Construct_Object
9046>>>>>>>>>        Send RegisterComEvents
9047>>>>>>>>>    End_Procedure
9048>>>>>>>>>    
9048>>>>>>>>>    // It is expected that the Com class will augment this with useful event definitions
9048>>>>>>>>>    Procedure RegisterComEvents
9050>>>>>>>>>    End_Procedure
9051>>>>>>>>>    
9051>>>>>>>>>    // Attach the DF object to com automation object via progId.
9051>>>>>>>>>    // returns: Boolean bSuccess if Ok, If not ok, pcComObject is set to null
9051>>>>>>>>>    Function AttachActiveObject Returns Boolean
9053>>>>>>>>>        String sProgId
9053>>>>>>>>>        Variant vComObject
9053>>>>>>>>>        Boolean bSuccess
9053>>>>>>>>>        Get psProgID to sProgId
9054>>>>>>>>>        Get ComActiveObject sProgId to vComObject
9055>>>>>>>>>        Set pvComObject to vComObject
9056>>>>>>>>>        Move (not(IsNullComObject(vComObject))) to bSuccess // success of variant is not null
9057>>>>>>>>>        Function_Return bSuccess
9058>>>>>>>>>    End_Function
9059>>>>>>>>>    
9059>>>>>>>>>    // returns true if the control is created.
9059>>>>>>>>>    Function IsComObjectCreated Returns Boolean
9061>>>>>>>>>        Variant vComObject
9061>>>>>>>>>        Get pvComObject to vComObject
9062>>>>>>>>>        Function_Return (not(IsNullComObject(vComObject)))
9063>>>>>>>>>    End_Function
9064>>>>>>>>>    
9064>>>>>>>>>End_Class
9065>>>>>>>>>
9065>>>>>>>>>
9065>>>>>>>
9065>>>>>>>Use Windows.pkg
9065>>>>>>>
9065>>>>>>>Class cComDocumentObject is a DFComDocumentObject
9066>>>>>>>
9066>>>>>>>
9066>>>>>>>    Procedure Construct_Object
9068>>>>>>>        Forward Send Construct_Object
9070>>>>>>>        Send RegisterComEvents
9071>>>>>>>        Send Define_Standard_Object_Mixin
9072>>>>>>>        Send Define_Shadow_Mixin
9073>>>>>>>    End_Procedure
9074>>>>>>>
9074>>>>>>>    Import_Class_Protocol Standard_Object_Mixin
9075>>>>>>>    Import_Class_Protocol Shadow_Mixin
9076>>>>>>>
9076>>>>>>>    
9076>>>>>>>    // It is expected that the Com class will augment this with useful event definitions
9076>>>>>>>    Procedure RegisterComEvents
9078>>>>>>>    End_Procedure
9079>>>>>>>    
9079>>>>>>>    // returns true if the control is created.
9079>>>>>>>    Function IsComObjectCreated Returns Boolean
9081>>>>>>>        Variant vComObject
9081>>>>>>>        Get pvComObject to vComObject
9082>>>>>>>        Function_Return (not(IsNullComObject(vComObject)))
9083>>>>>>>    End_Function
9084>>>>>>>
9084>>>>>>>
9084>>>>>>>End_Class
9085>>>>>>>
9085>>>>>>>Class cComActiveXControl is a DFComActiveXControl
9086>>>>>>>
9086>>>>>>>    Procedure Construct_Object
9088>>>>>>>        Forward Send Construct_Object
9090>>>>>>>        Send RegisterComEvents
9091>>>>>>>
9091>>>>>>>
9091>>>>>>>        Send Define_Standard_Object_Mixin
9092>>>>>>>        Send Define_Single_Item_Navigate_Mixin
9093>>>>>>>        Send Define_Dflabel_Mixin
9094>>>>>>>
9094>>>>>>>        // internal: set true object is notified that the OCX value has changed.
9094>>>>>>>        Property Boolean pbPrivateControlChanging False
9095>>>>>>>        // Class sets this true when making a local (externally triggered) change. This is
9095>>>>>>>        // set when a Set Value change is made to prevent recursion
9095>>>>>>>        Property Boolean pbPrivateControlRefresh False
9096>>>>>>>        
9096>>>>>>>        // added to eumlate a single item form support
9096>>>>>>>        Property Boolean pbPrivateItem_Changed_State False
9097>>>>>>>        
9097>>>>>>>        // This keeps track of value, even when control is not created
9097>>>>>>>        Property String psPrivateValue ''
9098>>>>>>>        
9098>>>>>>>        // If set true, then the control will attempt to bind the value property in the object to the
9098>>>>>>>        // comValue in the control. It will try to keep these values in synch at all times. This allows a
9098>>>>>>>        // control to be used as a Form style value control. the default is true. Even when true if the
9098>>>>>>>        // get/set ComValue methods are not set up to do anything, this will do nothing.
9098>>>>>>>        Property Boolean pbBindValue True
9099>>>>>>>        
9099>>>>>>>    End_Procedure
9100>>>>>>>    
9100>>>>>>>    // It is expected that the Com class will augment this with useful event definitions
9100>>>>>>>    Procedure RegisterComEvents
9102>>>>>>>    End_Procedure
9103>>>>>>>
9103>>>>>>>    
9103>>>>>>>    // returns true if the control is created.
9103>>>>>>>    Function IsComObjectCreated Returns Boolean
9105>>>>>>>        Variant vComObject
9105>>>>>>>        Get pvComObject to vComObject
9106>>>>>>>        Function_Return (not(IsNullComObject(vComObject)))
9107>>>>>>>    End_Function
9108>>>>>>>    
9108>>>>>>>
9108>>>>>>>    Import_Class_Protocol Standard_Object_Mixin
9109>>>>>>>    Import_Class_Protocol Single_Item_Navigate_Mixin
9110>>>>>>>    Import_Class_Protocol Dflabel_Mixin
9111>>>>>>>
9111>>>>>>>    // added to eumlate a single item form support
9111>>>>>>>    Function Item_Count Returns Integer
9113>>>>>>>        Function_Return 1
9114>>>>>>>    End_Function
9115>>>>>>>    
9115>>>>>>>    // added to eumlate a single item form support
9115>>>>>>>    Procedure Set Item_Changed_State Integer iItem Integer iState
9117>>>>>>>        Set pbPrivateItem_changed_state to iState
9118>>>>>>>        If (iState and changed_state(Self)=False) ;            Set changed_state to True
9121>>>>>>>    End_Procedure
9122>>>>>>>    
9122>>>>>>>    Function Item_Changed_State Integer iItem Returns Integer
9124>>>>>>>        Function_Return (pbPrivateItem_changed_state(Self))
9125>>>>>>>    End_Function
9126>>>>>>>    
9126>>>>>>>    
9126>>>>>>>    // augment to set the label's appearance
9126>>>>>>>    Procedure Shadow_Display
9128>>>>>>>        Forward Send Shadow_display
9130>>>>>>>        Send Label_Shadow_Display
9131>>>>>>>    End_Procedure
9132>>>>>>>    
9132>>>>>>>    // Created to simulate get/Set value.
9132>>>>>>>    Procedure Set Value Integer iItem String sVal
9134>>>>>>>        If not (pbPrivateControlChanging(Self)) ;            Send OnRefreshControl sVal
9137>>>>>>>        Set psPrivateValue to sVal
9138>>>>>>>        Send OnChange
9139>>>>>>>        //Set changed_state to True
9139>>>>>>>        Set item_changed_state 0 to True
9140>>>>>>>    End_Procedure
9141>>>>>>>    
9141>>>>>>>    Function Value Integer iItem Returns String
9143>>>>>>>        Function_Return (psPrivateValue(Self))
9144>>>>>>>        //function_return (Controlvalue(self))
9144>>>>>>>    End_Function
9145>>>>>>>    
9145>>>>>>>    Procedure OnChange
9147>>>>>>>    End_Procedure
9148>>>>>>>    
9148>>>>>>>    
9148>>>>>>>    // It is expected that the sub-class will provide functionality
9148>>>>>>>    // for these messages. This gets and sets the value of the actual
9148>>>>>>>    // window control. These should only be used to synchronize the window
9148>>>>>>>    // control and the DF side. Do not use for any other purpose.
9148>>>>>>>    Procedure Set ControlValue String sVal
9150>>>>>>>    End_Procedure
9151>>>>>>>    
9151>>>>>>>    Function ControlValue Returns String
9153>>>>>>>    End_Function
9154>>>>>>>    
9154>>>>>>>    Procedure OnCreate
9156>>>>>>>        // if we are binding value to comValue, do so upon creation
9156>>>>>>>        If (pbBindValue(Self)) ;            Set ControlValue to (Value(Self))
9159>>>>>>>        Forward Send OnCreate
9161>>>>>>>    End_Procedure
9162>>>>>>>    
9162>>>>>>>    // Notification that the control's value has been changed
9162>>>>>>>    // externally by the program (via set value). Use to synchronize
9162>>>>>>>    // OCX control value.
9162>>>>>>>    Procedure OnRefreshControl String sVal
9164>>>>>>>        Boolean bOld
9164>>>>>>>        If (pbBindValue(Self) and pbPrivateControlChanging(Self)=0 and IsComObjectCreated(Self)) Begin
9166>>>>>>>            Get pbPrivateControlRefresh to bOld
9167>>>>>>>            Set pbPrivateControlRefresh to True
9168>>>>>>>            Set ControlValue to sval
9169>>>>>>>            Set pbPrivateControlRefresh to bOld
9170>>>>>>>        End
9170>>>>>>>>
9170>>>>>>>    End_Procedure
9171>>>>>>>    
9171>>>>>>>    // notification that the control has changed its value. Used to
9171>>>>>>>    // synchronize the object with the change.
9171>>>>>>>    Procedure OnControlValueChanged
9173>>>>>>>        String sVal
9173>>>>>>>        Boolean bOld
9173>>>>>>>        If (pbBindValue(Self) and pbPrivateControlRefresh(Self)=0) Begin
9175>>>>>>>            Get pbPrivateControlChanging to bOld
9176>>>>>>>            Set pbPrivateControlChanging to True
9177>>>>>>>            Get ControlValue to sVal
9178>>>>>>>            Set Value to sVal
9179>>>>>>>            Set Item_Changed_State 0 to True
9180>>>>>>>            Set pbPrivateControlChanging to bOld
9181>>>>>>>        End
9181>>>>>>>>
9181>>>>>>>    End_Procedure
9182>>>>>>>    
9182>>>>>>>    Procedure Delete_Data
9184>>>>>>>        Forward Send Delete_Data
9186>>>>>>>        Set Value to ''
9187>>>>>>>        Set Changed_state to False
9188>>>>>>>        Set Item_changed_state 0 to False
9189>>>>>>>    End_Procedure
9190>>>>>>>
9190>>>>>>>
9190>>>>>>>End_Class
9191>>>>>>>
9191>>>>>>>
9191>>>>>
9191>>>>>Define OLEEVO_TYPES for Integer
9191>>>>>    Define OLEEVO_SCALAR for 1
9191>>>>>    Define OLEEVO_STRUCT for 12
9191>>>>>    Define OLEEVO_MAP for 13
9191>>>>>    Define OLEEVO_SET for 14
9191>>>>>    Define OLEEVO_LIST for 15
9191>>>>>
9191>>>>>Define OLEEVO_VISIBILITY for Integer
9191>>>>>    Define OLEEVO_PUBLIC for 1
9191>>>>>    Define OLEEVO_PRIVATE for 2
9191>>>>>
9191>>>>>Define OLEEVO_FIELD_FLAGS for Integer
9191>>>>>    Define OLEEVO_FIELD_DEFAULT for 0
9191>>>>>    Define OLEEVO_FIELD_REQUIRED for 1
9191>>>>>
9191>>>>>Define OLEEVO_METHOD_FLAGS for Integer
9191>>>>>    Define OLEEVO_METHOD_DEFAULT for 0
9191>>>>>    Define OLEEVO_METHOD_ONEWAY for 1
9191>>>>>    Define OLEEVO_METHOD_AUTH for 2
9191>>>>>    Define OLEEVO_METHOD_UNSECURED for 4
9191>>>>>    Define OLEEVO_METHOD_LOGIN for 8
9191>>>>>
9191>>>>>Define OLEEVO_SCALARS for Integer
9191>>>>>    Define OLEEVO_BOOL for 2
9191>>>>>    Define OLEEVO_BYTE for 3
9191>>>>>    Define OLEEVO_I16 for 6
9191>>>>>    Define OLEEVO_I32 for 8
9191>>>>>    Define OLEEVO_I64 for 10
9191>>>>>    Define OLEEVO_DOUBLE for 4
9191>>>>>    Define OLEEVO_STRING for 11
9191>>>>>    Define OLEEVO_DATE for 1001
9191>>>>>    Define OLEEVO_DATETIME for 1002
9191>>>>>    Define OLEEVO_BINARY for 1003
9191>>>>>    Define OLEEVO_DECIMAL for 1004
9191>>>>>
9191>>>>>Define OLEEVO_MARSHALING_MODES for Integer
9191>>>>>    Define OLEEVO_RECORDS_AND_ARRAYS for 17
9191>>>>>    Define OLEEVO_OBJECTS_AND_COLLECTIONS for 34
9191>>>>>
9191>>>>>Define OLEEVO_TRANSPORTS for Integer
9191>>>>>    Define OLEEVO_TRANSPORT_FRAMED for 1
9191>>>>>    Define OLEEVO_TRANSPORT_HTTP for 2
9191>>>>>    Define OLEEVO_TRANSPORT_GRPC for 3
9191>>>>>
9191>>>>>Define OLEEVO_PROTOCOLS for Integer
9191>>>>>    Define OLEEVO_THRIFT_BINARY for 1
9191>>>>>    Define OLEEVO_THRIFT_COMPACT for 2
9191>>>>>    Define OLEEVO_JSON_RPC for 3
9191>>>>>    Define OLEEVO_SOAP for 4
9191>>>>>    Define OLEEVO_JSON_REST for 5
9191>>>>>    Define OLEEVO_PROTOBUF for 6
9191>>>>>
9191>>>>>Define OLEEVO_ENCODINGS for Integer
9191>>>>>    Define OLEEVO_ENCODING_UTF8 for 1
9191>>>>>    Define OLEEVO_ENCODING_ANSI for 2
9191>>>>>
9191>>>>>//Struct GUID
9191>>>>>    //UInteger Data1
9191>>>>>    //UShort Data2
9191>>>>>    //UShort Data3
9191>>>>>    // Data4  // Bad type member
9191>>>>>//End_Struct
9191>>>>>
9191>>>>>// CLSID: {DF66E45F-43E0-4EE0-B28B-C7750F3C1C10}
9191>>>>>Class cComIEvoInterface is a Mixin
9192>>>>>
9192>>>>>    Function ComNewType Returns Variant
9194>>>>>        Handle hDispatchDriver
9194>>>>>        Variant retVal
9194>>>>>        Get phDispatchDriver to hDispatchDriver
9195>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_DISPATCH to retVal
9196>>>>>        Function_Return retVal
9197>>>>>    End_Function
9198>>>>>
9198>>>>>    Function ComNewStruct Returns Variant
9200>>>>>        Handle hDispatchDriver
9200>>>>>        Variant retVal
9200>>>>>        Get phDispatchDriver to hDispatchDriver
9201>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_DISPATCH to retVal
9202>>>>>        Function_Return retVal
9203>>>>>    End_Function
9204>>>>>
9204>>>>>    Function ComNewService Returns Variant
9206>>>>>        Handle hDispatchDriver
9206>>>>>        Variant retVal
9206>>>>>        Get phDispatchDriver to hDispatchDriver
9207>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_DISPATCH to retVal
9208>>>>>        Function_Return retVal
9209>>>>>    End_Function
9210>>>>>End_Class
9211>>>>>
9211>>>>>// CoClass
9211>>>>>// CLSID: {4212868E-6850-4E20-BDCE-22EA2BAAA0E8}
9211>>>>>Class cComEvoInterface is a cComAutomationObject
9212>>>>>    Import_Class_Protocol cComIEvoInterface
9213>>>>>
9213>>>>>    Procedure Construct_Object
9215>>>>>        Forward Send Construct_Object
9217>>>>>        Set psProgID to "{4212868E-6850-4E20-BDCE-22EA2BAAA0E8}"
9218>>>>>        Set peAutoCreate to acNoAutoCreate
9219>>>>>    End_Procedure
9220>>>>>End_Class
9221>>>>>
9221>>>>>// CLSID: {A809FD17-49C0-4F9C-8007-38D17E38D19D}
9221>>>>>Class cComIEvoServiceRuntime is a Mixin
9222>>>>>
9222>>>>>    Function ComService Returns Variant
9224>>>>>        Handle hDispatchDriver
9224>>>>>        Variant retVal
9224>>>>>        Get phDispatchDriver to hDispatchDriver
9225>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_DISPATCH to retVal
9226>>>>>        Function_Return retVal
9227>>>>>    End_Function
9228>>>>>
9228>>>>>    Procedure Set ComService Variant value
9230>>>>>        Handle hDispatchDriver
9230>>>>>        Get phDispatchDriver to hDispatchDriver
9231>>>>>        Send PrepareParams to hDispatchDriver 1
9232>>>>>        Set ComProperty of hDispatchDriver 1 OLE_VT_DISPATCH to value
9233>>>>>    End_Procedure
9234>>>>>
9234>>>>>    Function ComRuntime Returns Variant
9236>>>>>        Handle hDispatchDriver
9236>>>>>        Variant retVal
9236>>>>>        Get phDispatchDriver to hDispatchDriver
9237>>>>>        Get InvokeComMethod of hDispatchDriver 5 OLE_VT_DISPATCH to retVal
9238>>>>>        Function_Return retVal
9239>>>>>    End_Function
9240>>>>>
9240>>>>>    Function ComWrap Returns Variant
9242>>>>>        Handle hDispatchDriver
9242>>>>>        Variant retVal
9242>>>>>        Get phDispatchDriver to hDispatchDriver
9243>>>>>        Get InvokeComMethod of hDispatchDriver 6 OLE_VT_DISPATCH to retVal
9244>>>>>        Function_Return retVal
9245>>>>>    End_Function
9246>>>>>End_Class
9247>>>>>
9247>>>>>// CLSID: {4C009192-DF3D-4403-BF21-C027A8FD9702}
9247>>>>>Class cCom_EvoRuntimeEvents is a Mixin
9248>>>>>
9248>>>>>    Procedure RegisterComEvents
9250>>>>>    End_Procedure
9251>>>>>End_Class
9252>>>>>
9252>>>>>// CoClass
9252>>>>>// CLSID: {24CBD848-6CEF-4E8F-B714-7A0B23976272}
9252>>>>>Class cComEvoServiceRuntime is a cComAutomationObject
9253>>>>>    Import_Class_Protocol cComIEvoServiceRuntime
9254>>>>>    Import_Class_Protocol cCom_EvoRuntimeEvents
9255>>>>>
9255>>>>>    Procedure Construct_Object
9257>>>>>        Forward Send Construct_Object
9259>>>>>        Set psProgID to "{24CBD848-6CEF-4E8F-B714-7A0B23976272}"
9260>>>>>        Set psEventId to "{4C009192-DF3D-4403-BF21-C027A8FD9702}"
9261>>>>>        Set peAutoCreate to acNoAutoCreate
9262>>>>>    End_Procedure
9263>>>>>End_Class
9264>>>>>
9264>>>>>// CLSID: {136F28D3-20DD-4771-BD36-264D75CEA2B4}
9264>>>>>Class cComIEvoSimpleServer is a Mixin
9265>>>>>
9265>>>>>    Procedure ComStart Variant llServices OLEEVO_MARSHALING_MODES llmode
9267>>>>>        Handle hDispatchDriver
9267>>>>>        Get phDispatchDriver to hDispatchDriver
9268>>>>>        Send PrepareParams to hDispatchDriver 2
9269>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llServices
9270>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llmode
9271>>>>>        Send InvokeComMethod to hDispatchDriver 1 OLE_VT_VOID
9272>>>>>    End_Procedure
9273>>>>>
9273>>>>>    Procedure ComStop
9275>>>>>        Handle hDispatchDriver
9275>>>>>        Get phDispatchDriver to hDispatchDriver
9276>>>>>        Send InvokeComMethod to hDispatchDriver 2 OLE_VT_VOID
9277>>>>>    End_Procedure
9278>>>>>
9278>>>>>    Function ComIsConnected Returns Boolean
9280>>>>>        Handle hDispatchDriver
9280>>>>>        Boolean retVal
9280>>>>>        Get phDispatchDriver to hDispatchDriver
9281>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_BOOL to retVal
9282>>>>>        Function_Return retVal
9283>>>>>    End_Function
9284>>>>>
9284>>>>>    Function ComSettings Returns Variant
9286>>>>>        Handle hDispatchDriver
9286>>>>>        Variant retVal
9286>>>>>        Get phDispatchDriver to hDispatchDriver
9287>>>>>        Get InvokeComMethod of hDispatchDriver 4 OLE_VT_DISPATCH to retVal
9288>>>>>        Function_Return retVal
9289>>>>>    End_Function
9290>>>>>End_Class
9291>>>>>
9291>>>>>// CoClass
9291>>>>>// CLSID: {D546307E-2E2A-4B98-B230-4BD658C20C90}
9291>>>>>Class cComEvoSimpleServer is a cComAutomationObject
9292>>>>>    Import_Class_Protocol cComIEvoSimpleServer
9293>>>>>
9293>>>>>    Procedure Construct_Object
9295>>>>>        Forward Send Construct_Object
9297>>>>>        Set psProgID to "{D546307E-2E2A-4B98-B230-4BD658C20C90}"
9298>>>>>        Set peAutoCreate to acNoAutoCreate
9299>>>>>    End_Procedure
9300>>>>>End_Class
9301>>>>>
9301>>>>>// CLSID: {3942D3E7-4EE5-4BAE-9FAD-02938CC05E44}
9301>>>>>Class cComIEvoConsoleConnection is a Mixin
9302>>>>>
9302>>>>>    Procedure ComConnect Variant llServices OLEEVO_MARSHALING_MODES llmode
9304>>>>>        Handle hDispatchDriver
9304>>>>>        Get phDispatchDriver to hDispatchDriver
9305>>>>>        Send PrepareParams to hDispatchDriver 2
9306>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llServices
9307>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llmode
9308>>>>>        Send InvokeComMethod to hDispatchDriver 1 OLE_VT_VOID
9309>>>>>    End_Procedure
9310>>>>>
9310>>>>>    Procedure ComDisconnect
9312>>>>>        Handle hDispatchDriver
9312>>>>>        Get phDispatchDriver to hDispatchDriver
9313>>>>>        Send InvokeComMethod to hDispatchDriver 2 OLE_VT_VOID
9314>>>>>    End_Procedure
9315>>>>>
9315>>>>>    Function ComIsConnected Returns Boolean
9317>>>>>        Handle hDispatchDriver
9317>>>>>        Boolean retVal
9317>>>>>        Get phDispatchDriver to hDispatchDriver
9318>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_BOOL to retVal
9319>>>>>        Function_Return retVal
9320>>>>>    End_Function
9321>>>>>End_Class
9322>>>>>
9322>>>>>// CoClass
9322>>>>>// CLSID: {50065F68-C59A-42A9-A1A8-6F3AAE9F3D26}
9322>>>>>Class cComEvoConsoleConnection is a cComAutomationObject
9323>>>>>    Import_Class_Protocol cComIEvoConsoleConnection
9324>>>>>
9324>>>>>    Procedure Construct_Object
9326>>>>>        Forward Send Construct_Object
9328>>>>>        Set psProgID to "{50065F68-C59A-42A9-A1A8-6F3AAE9F3D26}"
9329>>>>>        Set peAutoCreate to acNoAutoCreate
9330>>>>>    End_Procedure
9331>>>>>End_Class
9332>>>>>
9332>>>>>// CLSID: {EA0D8C17-9891-444D-B55E-BA86E7DF6E7F}
9332>>>>>Class cComIEvoDispatchConnection is a Mixin
9333>>>>>
9333>>>>>    Procedure ComConnect Variant llServices OLEEVO_MARSHALING_MODES llmode
9335>>>>>        Handle hDispatchDriver
9335>>>>>        Get phDispatchDriver to hDispatchDriver
9336>>>>>        Send PrepareParams to hDispatchDriver 2
9337>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llServices
9338>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llmode
9339>>>>>        Send InvokeComMethod to hDispatchDriver 1 OLE_VT_VOID
9340>>>>>    End_Procedure
9341>>>>>
9341>>>>>    Procedure ComDisconnect
9343>>>>>        Handle hDispatchDriver
9343>>>>>        Get phDispatchDriver to hDispatchDriver
9344>>>>>        Send InvokeComMethod to hDispatchDriver 2 OLE_VT_VOID
9345>>>>>    End_Procedure
9346>>>>>
9346>>>>>    Function ComIsConnected Returns Boolean
9348>>>>>        Handle hDispatchDriver
9348>>>>>        Boolean retVal
9348>>>>>        Get phDispatchDriver to hDispatchDriver
9349>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_BOOL to retVal
9350>>>>>        Function_Return retVal
9351>>>>>    End_Function
9352>>>>>End_Class
9353>>>>>
9353>>>>>// CoClass
9353>>>>>// CLSID: {4F31F80B-4D0A-4B3D-92BA-EAAD74D6016D}
9353>>>>>Class cComEvoDispatchConnection is a cComAutomationObject
9354>>>>>    Import_Class_Protocol cComIEvoDispatchConnection
9355>>>>>
9355>>>>>    Procedure Construct_Object
9357>>>>>        Forward Send Construct_Object
9359>>>>>        Set psProgID to "{4F31F80B-4D0A-4B3D-92BA-EAAD74D6016D}"
9360>>>>>        Set peAutoCreate to acNoAutoCreate
9361>>>>>    End_Procedure
9362>>>>>End_Class
9363>>>>>
9363>>>>>// CLSID: {271B9DDD-07BC-4F84-9EAF-B1E77C3C8E4E}
9363>>>>>Class cComIEvoField is a cComAutomationObject
9364>>>>>
9364>>>>>    Function ComId Returns Integer
9366>>>>>        Handle hDispatchDriver
9366>>>>>        Integer retVal
9366>>>>>        Get phDispatchDriver to hDispatchDriver
9367>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_I4 to retVal
9368>>>>>        Function_Return retVal
9369>>>>>    End_Function
9370>>>>>
9370>>>>>    Function ComName Returns String
9372>>>>>        Handle hDispatchDriver
9372>>>>>        String retVal
9372>>>>>        Get phDispatchDriver to hDispatchDriver
9373>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_BSTR to retVal
9374>>>>>        Function_Return retVal
9375>>>>>    End_Function
9376>>>>>
9376>>>>>    Function ComType Returns Variant
9378>>>>>        Handle hDispatchDriver
9378>>>>>        Variant retVal
9378>>>>>        Get phDispatchDriver to hDispatchDriver
9379>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_DISPATCH to retVal
9380>>>>>        Function_Return retVal
9381>>>>>    End_Function
9382>>>>>
9382>>>>>    Function ComFlags Returns Integer
9384>>>>>        Handle hDispatchDriver
9384>>>>>        Integer retVal
9384>>>>>        Get phDispatchDriver to hDispatchDriver
9385>>>>>        Get InvokeComMethod of hDispatchDriver 4 OLE_VT_I4 to retVal
9386>>>>>        Function_Return retVal
9387>>>>>    End_Function
9388>>>>>
9388>>>>>    Function ComVisibility Returns OLEEVO_VISIBILITY
9390>>>>>        Handle hDispatchDriver
9390>>>>>        OLEEVO_VISIBILITY retVal
9390>>>>>        Get phDispatchDriver to hDispatchDriver
9391>>>>>        Get InvokeComMethod of hDispatchDriver 5 OLE_VT_I4 to retVal
9392>>>>>        Function_Return retVal
9393>>>>>    End_Function
9394>>>>>
9394>>>>>    Function ComDescription Returns String
9396>>>>>        Handle hDispatchDriver
9396>>>>>        String retVal
9396>>>>>        Get phDispatchDriver to hDispatchDriver
9397>>>>>        Get InvokeComMethod of hDispatchDriver 6 OLE_VT_BSTR to retVal
9398>>>>>        Function_Return retVal
9399>>>>>    End_Function
9400>>>>>End_Class
9401>>>>>
9401>>>>>// CLSID: {17B03014-738F-468A-B9B3-E30B57C093EE}
9401>>>>>Class cComIEvoType is a cComAutomationObject
9402>>>>>
9402>>>>>    Function ComKind Returns OLEEVO_TYPES
9404>>>>>        Handle hDispatchDriver
9404>>>>>        OLEEVO_TYPES retVal
9404>>>>>        Get phDispatchDriver to hDispatchDriver
9405>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_I4 to retVal
9406>>>>>        Function_Return retVal
9407>>>>>    End_Function
9408>>>>>End_Class
9409>>>>>
9409>>>>>// CLSID: {7380FAA1-C93A-4124-9A0B-A59432F77329}
9409>>>>>Class cComIEvoPrivateField is a cComAutomationObject
9410>>>>>
9410>>>>>    Function ComId Returns Integer
9412>>>>>        Handle hDispatchDriver
9412>>>>>        Integer retVal
9412>>>>>        Get phDispatchDriver to hDispatchDriver
9413>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_I4 to retVal
9414>>>>>        Function_Return retVal
9415>>>>>    End_Function
9416>>>>>
9416>>>>>    Function ComName Returns String
9418>>>>>        Handle hDispatchDriver
9418>>>>>        String retVal
9418>>>>>        Get phDispatchDriver to hDispatchDriver
9419>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_BSTR to retVal
9420>>>>>        Function_Return retVal
9421>>>>>    End_Function
9422>>>>>
9422>>>>>    Function ComType Returns Variant
9424>>>>>        Handle hDispatchDriver
9424>>>>>        Variant retVal
9424>>>>>        Get phDispatchDriver to hDispatchDriver
9425>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_DISPATCH to retVal
9426>>>>>        Function_Return retVal
9427>>>>>    End_Function
9428>>>>>
9428>>>>>    Function ComFlags Returns Integer
9430>>>>>        Handle hDispatchDriver
9430>>>>>        Integer retVal
9430>>>>>        Get phDispatchDriver to hDispatchDriver
9431>>>>>        Get InvokeComMethod of hDispatchDriver 4 OLE_VT_I4 to retVal
9432>>>>>        Function_Return retVal
9433>>>>>    End_Function
9434>>>>>
9434>>>>>    Function ComVisibility Returns OLEEVO_VISIBILITY
9436>>>>>        Handle hDispatchDriver
9436>>>>>        OLEEVO_VISIBILITY retVal
9436>>>>>        Get phDispatchDriver to hDispatchDriver
9437>>>>>        Get InvokeComMethod of hDispatchDriver 5 OLE_VT_I4 to retVal
9438>>>>>        Function_Return retVal
9439>>>>>    End_Function
9440>>>>>
9440>>>>>    Function ComDescription Returns String
9442>>>>>        Handle hDispatchDriver
9442>>>>>        String retVal
9442>>>>>        Get phDispatchDriver to hDispatchDriver
9443>>>>>        Get InvokeComMethod of hDispatchDriver 6 OLE_VT_BSTR to retVal
9444>>>>>        Function_Return retVal
9445>>>>>    End_Function
9446>>>>>
9446>>>>>    Function ComValue Returns Variant
9448>>>>>        Handle hDispatchDriver
9448>>>>>        Variant retVal
9448>>>>>        Get phDispatchDriver to hDispatchDriver
9449>>>>>        Get InvokeComMethod of hDispatchDriver 7 OLE_VT_VARIANT to retVal
9450>>>>>        Function_Return retVal
9451>>>>>    End_Function
9452>>>>>End_Class
9453>>>>>
9453>>>>>// CLSID: {C23CD75F-B006-4443-B4C1-DBC26DB1A9AE}
9453>>>>>Class cComIEvoPrototype is a cComAutomationObject
9454>>>>>
9454>>>>>    Function ComParameters Returns Variant
9456>>>>>        Handle hDispatchDriver
9456>>>>>        Variant retVal
9456>>>>>        Get phDispatchDriver to hDispatchDriver
9457>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_DISPATCH to retVal
9458>>>>>        Function_Return retVal
9459>>>>>    End_Function
9460>>>>>End_Class
9461>>>>>
9461>>>>>// CLSID: {6CD5F06D-2869-4E19-A3AC-ECF24258DFCF}
9461>>>>>Class cComIEvoCollection is a cComAutomationObject
9462>>>>>
9462>>>>>    Function Com_NewEnum Returns Variant
9464>>>>>        Handle hDispatchDriver
9464>>>>>        Variant retVal
9464>>>>>        Get phDispatchDriver to hDispatchDriver
9465>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
9466>>>>>        Function_Return retVal
9467>>>>>    End_Function
9468>>>>>
9468>>>>>    Function ComItem Integer llIndex Returns Variant
9470>>>>>        Handle hDispatchDriver
9470>>>>>        Variant retVal
9470>>>>>        Get phDispatchDriver to hDispatchDriver
9471>>>>>        Send PrepareParams to hDispatchDriver 1
9472>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
9473>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_VARIANT to retVal
9474>>>>>        Function_Return retVal
9475>>>>>    End_Function
9476>>>>>
9476>>>>>    Function ComCount Returns Integer
9478>>>>>        Handle hDispatchDriver
9478>>>>>        Integer retVal
9478>>>>>        Get phDispatchDriver to hDispatchDriver
9479>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_I4 to retVal
9480>>>>>        Function_Return retVal
9481>>>>>    End_Function
9482>>>>>End_Class
9483>>>>>
9483>>>>>// CLSID: {9389C2C9-E2C2-4666-BA4A-262066ED3A39}
9483>>>>>Class cComIEvoMethod is a cComAutomationObject
9484>>>>>
9484>>>>>    Function ComParameters Returns Variant
9486>>>>>        Handle hDispatchDriver
9486>>>>>        Variant retVal
9486>>>>>        Get phDispatchDriver to hDispatchDriver
9487>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_DISPATCH to retVal
9488>>>>>        Function_Return retVal
9489>>>>>    End_Function
9490>>>>>
9490>>>>>    Function ComId Returns Integer
9492>>>>>        Handle hDispatchDriver
9492>>>>>        Integer retVal
9492>>>>>        Get phDispatchDriver to hDispatchDriver
9493>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_I4 to retVal
9494>>>>>        Function_Return retVal
9495>>>>>    End_Function
9496>>>>>
9496>>>>>    Function ComName Returns String
9498>>>>>        Handle hDispatchDriver
9498>>>>>        String retVal
9498>>>>>        Get phDispatchDriver to hDispatchDriver
9499>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_BSTR to retVal
9500>>>>>        Function_Return retVal
9501>>>>>    End_Function
9502>>>>>
9502>>>>>    Function ComReturns Returns Variant
9504>>>>>        Handle hDispatchDriver
9504>>>>>        Variant retVal
9504>>>>>        Get phDispatchDriver to hDispatchDriver
9505>>>>>        Get InvokeComMethod of hDispatchDriver 4 OLE_VT_DISPATCH to retVal
9506>>>>>        Function_Return retVal
9507>>>>>    End_Function
9508>>>>>
9508>>>>>    Function ComFlags Returns Integer
9510>>>>>        Handle hDispatchDriver
9510>>>>>        Integer retVal
9510>>>>>        Get phDispatchDriver to hDispatchDriver
9511>>>>>        Get InvokeComMethod of hDispatchDriver 5 OLE_VT_I4 to retVal
9512>>>>>        Function_Return retVal
9513>>>>>    End_Function
9514>>>>>
9514>>>>>    Function ComDescription Returns String
9516>>>>>        Handle hDispatchDriver
9516>>>>>        String retVal
9516>>>>>        Get phDispatchDriver to hDispatchDriver
9517>>>>>        Get InvokeComMethod of hDispatchDriver 6 OLE_VT_BSTR to retVal
9518>>>>>        Function_Return retVal
9519>>>>>    End_Function
9520>>>>>
9520>>>>>    Function ComRetvalDescription Returns String
9522>>>>>        Handle hDispatchDriver
9522>>>>>        String retVal
9522>>>>>        Get phDispatchDriver to hDispatchDriver
9523>>>>>        Get InvokeComMethod of hDispatchDriver 7 OLE_VT_BSTR to retVal
9524>>>>>        Function_Return retVal
9525>>>>>    End_Function
9526>>>>>End_Class
9527>>>>>
9527>>>>>// CLSID: {61E15563-D124-4D49-A867-00025F36D9C0}
9527>>>>>Class cComIEvoMutableCollection is a cComAutomationObject
9528>>>>>
9528>>>>>    Function Com_NewEnum Returns Variant
9530>>>>>        Handle hDispatchDriver
9530>>>>>        Variant retVal
9530>>>>>        Get phDispatchDriver to hDispatchDriver
9531>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
9532>>>>>        Function_Return retVal
9533>>>>>    End_Function
9534>>>>>
9534>>>>>    Function ComItem Integer llIndex Returns Variant
9536>>>>>        Handle hDispatchDriver
9536>>>>>        Variant retVal
9536>>>>>        Get phDispatchDriver to hDispatchDriver
9537>>>>>        Send PrepareParams to hDispatchDriver 1
9538>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
9539>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_VARIANT to retVal
9540>>>>>        Function_Return retVal
9541>>>>>    End_Function
9542>>>>>
9542>>>>>    Function ComCount Returns Integer
9544>>>>>        Handle hDispatchDriver
9544>>>>>        Integer retVal
9544>>>>>        Get phDispatchDriver to hDispatchDriver
9545>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_I4 to retVal
9546>>>>>        Function_Return retVal
9547>>>>>    End_Function
9548>>>>>
9548>>>>>    Procedure ComAdd Variant llValue
9550>>>>>        Handle hDispatchDriver
9550>>>>>        Get phDispatchDriver to hDispatchDriver
9551>>>>>        Send PrepareParams to hDispatchDriver 1
9552>>>>>        Send DefineParam to hDispatchDriver OLE_VT_VARIANT llValue
9553>>>>>        Send InvokeComMethod to hDispatchDriver 2 OLE_VT_VOID
9554>>>>>    End_Procedure
9555>>>>>
9555>>>>>    Procedure ComRemove Integer llIndex
9557>>>>>        Handle hDispatchDriver
9557>>>>>        Get phDispatchDriver to hDispatchDriver
9558>>>>>        Send PrepareParams to hDispatchDriver 1
9559>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
9560>>>>>        Send InvokeComMethod to hDispatchDriver 3 OLE_VT_VOID
9561>>>>>    End_Procedure
9562>>>>>
9562>>>>>    Procedure ComClear
9564>>>>>        Handle hDispatchDriver
9564>>>>>        Get phDispatchDriver to hDispatchDriver
9565>>>>>        Send InvokeComMethod to hDispatchDriver 4 OLE_VT_VOID
9566>>>>>    End_Procedure
9567>>>>>
9567>>>>>    Procedure ComReserve Integer llSize
9569>>>>>        Handle hDispatchDriver
9569>>>>>        Get phDispatchDriver to hDispatchDriver
9570>>>>>        Send PrepareParams to hDispatchDriver 1
9571>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llSize
9572>>>>>        Send InvokeComMethod to hDispatchDriver 5 OLE_VT_VOID
9573>>>>>    End_Procedure
9574>>>>>
9574>>>>>    Function ComAddNew Returns Variant
9576>>>>>        Handle hDispatchDriver
9576>>>>>        Variant retVal
9576>>>>>        Get phDispatchDriver to hDispatchDriver
9577>>>>>        Get InvokeComMethod of hDispatchDriver 6 OLE_VT_VARIANT to retVal
9578>>>>>        Function_Return retVal
9579>>>>>    End_Function
9580>>>>>End_Class
9581>>>>>
9581>>>>>// CLSID: {F6F51E9B-6254-47F7-9603-8287D3871691}
9581>>>>>Class cComIEvoTypeBuilder is a cComAutomationObject
9582>>>>>
9582>>>>>    Function ComCreateBool Returns Variant
9584>>>>>        Handle hDispatchDriver
9584>>>>>        Variant retVal
9584>>>>>        Get phDispatchDriver to hDispatchDriver
9585>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_DISPATCH to retVal
9586>>>>>        Function_Return retVal
9587>>>>>    End_Function
9588>>>>>
9588>>>>>    Function ComCreateByte Returns Variant
9590>>>>>        Handle hDispatchDriver
9590>>>>>        Variant retVal
9590>>>>>        Get phDispatchDriver to hDispatchDriver
9591>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_DISPATCH to retVal
9592>>>>>        Function_Return retVal
9593>>>>>    End_Function
9594>>>>>
9594>>>>>    Function ComCreateInt16 Returns Variant
9596>>>>>        Handle hDispatchDriver
9596>>>>>        Variant retVal
9596>>>>>        Get phDispatchDriver to hDispatchDriver
9597>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_DISPATCH to retVal
9598>>>>>        Function_Return retVal
9599>>>>>    End_Function
9600>>>>>
9600>>>>>    Function ComCreateInt32 Returns Variant
9602>>>>>        Handle hDispatchDriver
9602>>>>>        Variant retVal
9602>>>>>        Get phDispatchDriver to hDispatchDriver
9603>>>>>        Get InvokeComMethod of hDispatchDriver 4 OLE_VT_DISPATCH to retVal
9604>>>>>        Function_Return retVal
9605>>>>>    End_Function
9606>>>>>
9606>>>>>    Function ComCreateInt64 Returns Variant
9608>>>>>        Handle hDispatchDriver
9608>>>>>        Variant retVal
9608>>>>>        Get phDispatchDriver to hDispatchDriver
9609>>>>>        Get InvokeComMethod of hDispatchDriver 5 OLE_VT_DISPATCH to retVal
9610>>>>>        Function_Return retVal
9611>>>>>    End_Function
9612>>>>>
9612>>>>>    Function ComCreateDouble Returns Variant
9614>>>>>        Handle hDispatchDriver
9614>>>>>        Variant retVal
9614>>>>>        Get phDispatchDriver to hDispatchDriver
9615>>>>>        Get InvokeComMethod of hDispatchDriver 6 OLE_VT_DISPATCH to retVal
9616>>>>>        Function_Return retVal
9617>>>>>    End_Function
9618>>>>>
9618>>>>>    Function ComCreateString Returns Variant
9620>>>>>        Handle hDispatchDriver
9620>>>>>        Variant retVal
9620>>>>>        Get phDispatchDriver to hDispatchDriver
9621>>>>>        Get InvokeComMethod of hDispatchDriver 7 OLE_VT_DISPATCH to retVal
9622>>>>>        Function_Return retVal
9623>>>>>    End_Function
9624>>>>>
9624>>>>>    Function ComCreateMap Variant llKeyType Variant llValueType Returns Variant
9626>>>>>        Handle hDispatchDriver
9626>>>>>        Variant retVal
9626>>>>>        Get phDispatchDriver to hDispatchDriver
9627>>>>>        Send PrepareParams to hDispatchDriver 2
9628>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llKeyType
9629>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llValueType
9630>>>>>        Get InvokeComMethod of hDispatchDriver 8 OLE_VT_DISPATCH to retVal
9631>>>>>        Function_Return retVal
9632>>>>>    End_Function
9633>>>>>
9633>>>>>    Function ComCreateSet Variant llContainedType Returns Variant
9635>>>>>        Handle hDispatchDriver
9635>>>>>        Variant retVal
9635>>>>>        Get phDispatchDriver to hDispatchDriver
9636>>>>>        Send PrepareParams to hDispatchDriver 1
9637>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llContainedType
9638>>>>>        Get InvokeComMethod of hDispatchDriver 9 OLE_VT_DISPATCH to retVal
9639>>>>>        Function_Return retVal
9640>>>>>    End_Function
9641>>>>>
9641>>>>>    Function ComCreateList Variant llContainedType Returns Variant
9643>>>>>        Handle hDispatchDriver
9643>>>>>        Variant retVal
9643>>>>>        Get phDispatchDriver to hDispatchDriver
9644>>>>>        Send PrepareParams to hDispatchDriver 1
9645>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llContainedType
9646>>>>>        Get InvokeComMethod of hDispatchDriver 10 OLE_VT_DISPATCH to retVal
9647>>>>>        Function_Return retVal
9648>>>>>    End_Function
9649>>>>>
9649>>>>>    Function ComCreateDate Returns Variant
9651>>>>>        Handle hDispatchDriver
9651>>>>>        Variant retVal
9651>>>>>        Get phDispatchDriver to hDispatchDriver
9652>>>>>        Get InvokeComMethod of hDispatchDriver 11 OLE_VT_DISPATCH to retVal
9653>>>>>        Function_Return retVal
9654>>>>>    End_Function
9655>>>>>
9655>>>>>    Function ComCreateDateTime Returns Variant
9657>>>>>        Handle hDispatchDriver
9657>>>>>        Variant retVal
9657>>>>>        Get phDispatchDriver to hDispatchDriver
9658>>>>>        Get InvokeComMethod of hDispatchDriver 12 OLE_VT_DISPATCH to retVal
9659>>>>>        Function_Return retVal
9660>>>>>    End_Function
9661>>>>>
9661>>>>>    Function ComCreateBinary Returns Variant
9663>>>>>        Handle hDispatchDriver
9663>>>>>        Variant retVal
9663>>>>>        Get phDispatchDriver to hDispatchDriver
9664>>>>>        Get InvokeComMethod of hDispatchDriver 13 OLE_VT_DISPATCH to retVal
9665>>>>>        Function_Return retVal
9666>>>>>    End_Function
9667>>>>>
9667>>>>>    Function ComCreateDecimal Returns Variant
9669>>>>>        Handle hDispatchDriver
9669>>>>>        Variant retVal
9669>>>>>        Get phDispatchDriver to hDispatchDriver
9670>>>>>        Get InvokeComMethod of hDispatchDriver 14 OLE_VT_DISPATCH to retVal
9671>>>>>        Function_Return retVal
9672>>>>>    End_Function
9673>>>>>End_Class
9674>>>>>
9674>>>>>// CLSID: {7604CA2D-8AF5-4895-9AA2-5677115A75D6}
9674>>>>>Class cComIEvoScalar is a cComAutomationObject
9675>>>>>
9675>>>>>    Function ComKind Returns OLEEVO_TYPES
9677>>>>>        Handle hDispatchDriver
9677>>>>>        OLEEVO_TYPES retVal
9677>>>>>        Get phDispatchDriver to hDispatchDriver
9678>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_I4 to retVal
9679>>>>>        Function_Return retVal
9680>>>>>    End_Function
9681>>>>>
9681>>>>>    Function ComType Returns OLEEVO_SCALARS
9683>>>>>        Handle hDispatchDriver
9683>>>>>        OLEEVO_SCALARS retVal
9683>>>>>        Get phDispatchDriver to hDispatchDriver
9684>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_I4 to retVal
9685>>>>>        Function_Return retVal
9686>>>>>    End_Function
9687>>>>>End_Class
9688>>>>>
9688>>>>>// CLSID: {0225D5B3-F610-47D2-BD3E-03A4C5CBD1D8}
9688>>>>>Class cComIEvoMap is a cComAutomationObject
9689>>>>>
9689>>>>>    Function ComKind Returns OLEEVO_TYPES
9691>>>>>        Handle hDispatchDriver
9691>>>>>        OLEEVO_TYPES retVal
9691>>>>>        Get phDispatchDriver to hDispatchDriver
9692>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_I4 to retVal
9693>>>>>        Function_Return retVal
9694>>>>>    End_Function
9695>>>>>
9695>>>>>    Function ComKeyType Returns Variant
9697>>>>>        Handle hDispatchDriver
9697>>>>>        Variant retVal
9697>>>>>        Get phDispatchDriver to hDispatchDriver
9698>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_DISPATCH to retVal
9699>>>>>        Function_Return retVal
9700>>>>>    End_Function
9701>>>>>
9701>>>>>    Function ComValueType Returns Variant
9703>>>>>        Handle hDispatchDriver
9703>>>>>        Variant retVal
9703>>>>>        Get phDispatchDriver to hDispatchDriver
9704>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_DISPATCH to retVal
9705>>>>>        Function_Return retVal
9706>>>>>    End_Function
9707>>>>>End_Class
9708>>>>>
9708>>>>>// CLSID: {B090843B-D9AB-4A44-85B4-B878F0855F16}
9708>>>>>Class cComIEvoList is a cComAutomationObject
9709>>>>>
9709>>>>>    Function ComKind Returns OLEEVO_TYPES
9711>>>>>        Handle hDispatchDriver
9711>>>>>        OLEEVO_TYPES retVal
9711>>>>>        Get phDispatchDriver to hDispatchDriver
9712>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_I4 to retVal
9713>>>>>        Function_Return retVal
9714>>>>>    End_Function
9715>>>>>
9715>>>>>    Function ComContainedType Returns Variant
9717>>>>>        Handle hDispatchDriver
9717>>>>>        Variant retVal
9717>>>>>        Get phDispatchDriver to hDispatchDriver
9718>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_DISPATCH to retVal
9719>>>>>        Function_Return retVal
9720>>>>>    End_Function
9721>>>>>End_Class
9722>>>>>
9722>>>>>// CLSID: {13BD6B34-E357-47F7-AF41-58234C57242C}
9722>>>>>Class cComIEvoStructBuilder is a cComAutomationObject
9723>>>>>
9723>>>>>    Procedure ComAddField Integer llId String llName String llDescription Variant llType Integer llFlags
9725>>>>>        Handle hDispatchDriver
9725>>>>>        Get phDispatchDriver to hDispatchDriver
9726>>>>>        Send PrepareParams to hDispatchDriver 5
9727>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llId
9728>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llName
9729>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llDescription
9730>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llType
9731>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llFlags
9732>>>>>        Send InvokeComMethod to hDispatchDriver 1 OLE_VT_VOID
9733>>>>>    End_Procedure
9734>>>>>
9734>>>>>    Function ComCreateStruct String llName String llDescription Returns Variant
9736>>>>>        Handle hDispatchDriver
9736>>>>>        Variant retVal
9736>>>>>        Get phDispatchDriver to hDispatchDriver
9737>>>>>        Send PrepareParams to hDispatchDriver 2
9738>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llName
9739>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llDescription
9740>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_DISPATCH to retVal
9741>>>>>        Function_Return retVal
9742>>>>>    End_Function
9743>>>>>
9743>>>>>    Function ComCreatePrototype Returns Variant
9745>>>>>        Handle hDispatchDriver
9745>>>>>        Variant retVal
9745>>>>>        Get phDispatchDriver to hDispatchDriver
9746>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_DISPATCH to retVal
9747>>>>>        Function_Return retVal
9748>>>>>    End_Function
9749>>>>>
9749>>>>>    Procedure ComAddPrivateField Integer llId String llName String llDescription Variant llType Variant llValue
9751>>>>>        Handle hDispatchDriver
9751>>>>>        Get phDispatchDriver to hDispatchDriver
9752>>>>>        Send PrepareParams to hDispatchDriver 5
9753>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llId
9754>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llName
9755>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llDescription
9756>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llType
9757>>>>>        Send DefineParam to hDispatchDriver OLE_VT_VARIANT llValue
9758>>>>>        Send InvokeComMethod to hDispatchDriver 4 OLE_VT_VOID
9759>>>>>    End_Procedure
9760>>>>>
9760>>>>>    // (Member is disabled because of invalid return type or parameter type)
9760>>>>>    //Function ComCreateStructWithGuid String llName String llDescription  llGuid Returns Variant
9760>>>>>        //Handle hDispatchDriver
9760>>>>>        //Variant retVal
9760>>>>>        //Get phDispatchDriver to hDispatchDriver
9760>>>>>        //Send PrepareParams to hDispatchDriver 3
9760>>>>>        //Send DefineParam to hDispatchDriver OLE_VT_BSTR llName
9760>>>>>        //Send DefineParam to hDispatchDriver OLE_VT_BSTR llDescription
9760>>>>>        //Send DefineParam to hDispatchDriver OLE_VT_RECORD llGuid
9760>>>>>        //Get InvokeComMethod of hDispatchDriver 5 OLE_VT_DISPATCH to retVal
9760>>>>>        //Function_Return retVal
9760>>>>>    //End_Function
9760>>>>>End_Class
9761>>>>>
9761>>>>>// CLSID: {9A2C4B19-8EB3-47B5-B4C2-86458EFEAD1F}
9761>>>>>Class cComIEvoStruct is a cComAutomationObject
9762>>>>>
9762>>>>>    Function ComKind Returns OLEEVO_TYPES
9764>>>>>        Handle hDispatchDriver
9764>>>>>        OLEEVO_TYPES retVal
9764>>>>>        Get phDispatchDriver to hDispatchDriver
9765>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_I4 to retVal
9766>>>>>        Function_Return retVal
9767>>>>>    End_Function
9768>>>>>
9768>>>>>    Function ComName Returns String
9770>>>>>        Handle hDispatchDriver
9770>>>>>        String retVal
9770>>>>>        Get phDispatchDriver to hDispatchDriver
9771>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_BSTR to retVal
9772>>>>>        Function_Return retVal
9773>>>>>    End_Function
9774>>>>>
9774>>>>>    Function ComFields Returns Variant
9776>>>>>        Handle hDispatchDriver
9776>>>>>        Variant retVal
9776>>>>>        Get phDispatchDriver to hDispatchDriver
9777>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_DISPATCH to retVal
9778>>>>>        Function_Return retVal
9779>>>>>    End_Function
9780>>>>>
9780>>>>>    // (Member is disabled because of invalid return type or parameter type)
9780>>>>>    //{ MethodType=Property DesignTime=False }
9780>>>>>    //Function ComGuid Returns 
9780>>>>>        //Handle hDispatchDriver
9780>>>>>        // retVal
9780>>>>>        //Get phDispatchDriver to hDispatchDriver
9780>>>>>        //Get InvokeComMethod of hDispatchDriver 4 OLE_VT_RECORD to retVal
9780>>>>>        //Function_Return retVal
9780>>>>>    //End_Function
9780>>>>>
9780>>>>>    Function ComDescription Returns String
9782>>>>>        Handle hDispatchDriver
9782>>>>>        String retVal
9782>>>>>        Get phDispatchDriver to hDispatchDriver
9783>>>>>        Get InvokeComMethod of hDispatchDriver 5 OLE_VT_BSTR to retVal
9784>>>>>        Function_Return retVal
9785>>>>>    End_Function
9786>>>>>End_Class
9787>>>>>
9787>>>>>// CLSID: {5E6345DE-3620-49EA-8DB5-A42936B8E791}
9787>>>>>Class cComIEvoServiceBuilder is a cComAutomationObject
9788>>>>>
9788>>>>>    Procedure ComAddFunction Integer llId String llName String llDescription Variant llReturnType String llRetvalDescription Variant llPrototype Integer llFlags
9790>>>>>        Handle hDispatchDriver
9790>>>>>        Get phDispatchDriver to hDispatchDriver
9791>>>>>        Send PrepareParams to hDispatchDriver 7
9792>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llId
9793>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llName
9794>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llDescription
9795>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llReturnType
9796>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llRetvalDescription
9797>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llPrototype
9798>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llFlags
9799>>>>>        Send InvokeComMethod to hDispatchDriver 1 OLE_VT_VOID
9800>>>>>    End_Procedure
9801>>>>>
9801>>>>>    Procedure ComAddProcedure Integer llId String llName String llDescription Variant llPrototype Integer llFlags
9803>>>>>        Handle hDispatchDriver
9803>>>>>        Get phDispatchDriver to hDispatchDriver
9804>>>>>        Send PrepareParams to hDispatchDriver 5
9805>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llId
9806>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llName
9807>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llDescription
9808>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llPrototype
9809>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llFlags
9810>>>>>        Send InvokeComMethod to hDispatchDriver 2 OLE_VT_VOID
9811>>>>>    End_Procedure
9812>>>>>
9812>>>>>    Function ComCreateService String llName String llDescription Variant llExtends Returns Variant
9814>>>>>        Handle hDispatchDriver
9814>>>>>        Variant retVal
9814>>>>>        Get phDispatchDriver to hDispatchDriver
9815>>>>>        Send PrepareParams to hDispatchDriver 3
9816>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llName
9817>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llDescription
9818>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llExtends
9819>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_DISPATCH to retVal
9820>>>>>        Function_Return retVal
9821>>>>>    End_Function
9822>>>>>
9822>>>>>    Function ComCreateServiceWithCustomExceptionData String llName String llDescription Variant llExceptionData Returns Variant
9824>>>>>        Handle hDispatchDriver
9824>>>>>        Variant retVal
9824>>>>>        Get phDispatchDriver to hDispatchDriver
9825>>>>>        Send PrepareParams to hDispatchDriver 3
9826>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llName
9827>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llDescription
9828>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llExceptionData
9829>>>>>        Get InvokeComMethod of hDispatchDriver 4 OLE_VT_DISPATCH to retVal
9830>>>>>        Function_Return retVal
9831>>>>>    End_Function
9832>>>>>End_Class
9833>>>>>
9833>>>>>// CLSID: {28B94B6D-98C8-4F28-B2C3-39D307D5E13E}
9833>>>>>Class cComIEvoService is a cComAutomationObject
9834>>>>>
9834>>>>>    Function ComName Returns String
9836>>>>>        Handle hDispatchDriver
9836>>>>>        String retVal
9836>>>>>        Get phDispatchDriver to hDispatchDriver
9837>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_BSTR to retVal
9838>>>>>        Function_Return retVal
9839>>>>>    End_Function
9840>>>>>
9840>>>>>    Function ComExtends Returns Variant
9842>>>>>        Handle hDispatchDriver
9842>>>>>        Variant retVal
9842>>>>>        Get phDispatchDriver to hDispatchDriver
9843>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_DISPATCH to retVal
9844>>>>>        Function_Return retVal
9845>>>>>    End_Function
9846>>>>>
9846>>>>>    Function ComMethods Returns Variant
9848>>>>>        Handle hDispatchDriver
9848>>>>>        Variant retVal
9848>>>>>        Get phDispatchDriver to hDispatchDriver
9849>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_DISPATCH to retVal
9850>>>>>        Function_Return retVal
9851>>>>>    End_Function
9852>>>>>
9852>>>>>    Function ComIDL Returns String
9854>>>>>        Handle hDispatchDriver
9854>>>>>        String retVal
9854>>>>>        Get phDispatchDriver to hDispatchDriver
9855>>>>>        Get InvokeComMethod of hDispatchDriver 4 OLE_VT_BSTR to retVal
9856>>>>>        Function_Return retVal
9857>>>>>    End_Function
9858>>>>>
9858>>>>>    Function ComExceptionData Returns Variant
9860>>>>>        Handle hDispatchDriver
9860>>>>>        Variant retVal
9860>>>>>        Get phDispatchDriver to hDispatchDriver
9861>>>>>        Get InvokeComMethod of hDispatchDriver 5 OLE_VT_DISPATCH to retVal
9862>>>>>        Function_Return retVal
9863>>>>>    End_Function
9864>>>>>
9864>>>>>    Function ComWSDL Returns String
9866>>>>>        Handle hDispatchDriver
9866>>>>>        String retVal
9866>>>>>        Get phDispatchDriver to hDispatchDriver
9867>>>>>        Get InvokeComMethod of hDispatchDriver 6 OLE_VT_BSTR to retVal
9868>>>>>        Function_Return retVal
9869>>>>>    End_Function
9870>>>>>
9870>>>>>    Function ComDescription Returns String
9872>>>>>        Handle hDispatchDriver
9872>>>>>        String retVal
9872>>>>>        Get phDispatchDriver to hDispatchDriver
9873>>>>>        Get InvokeComMethod of hDispatchDriver 7 OLE_VT_BSTR to retVal
9874>>>>>        Function_Return retVal
9875>>>>>    End_Function
9876>>>>>
9876>>>>>    Function ComWADL Returns String
9878>>>>>        Handle hDispatchDriver
9878>>>>>        String retVal
9878>>>>>        Get phDispatchDriver to hDispatchDriver
9879>>>>>        Get InvokeComMethod of hDispatchDriver 8 OLE_VT_BSTR to retVal
9880>>>>>        Function_Return retVal
9881>>>>>    End_Function
9882>>>>>
9882>>>>>    Function ComProto Returns String
9884>>>>>        Handle hDispatchDriver
9884>>>>>        String retVal
9884>>>>>        Get phDispatchDriver to hDispatchDriver
9885>>>>>        Get InvokeComMethod of hDispatchDriver 9 OLE_VT_BSTR to retVal
9886>>>>>        Function_Return retVal
9887>>>>>    End_Function
9888>>>>>End_Class
9889>>>>>
9889>>>>>// CLSID: {2FCEEDA5-6697-4CB7-9B70-C9622BE7111E}
9889>>>>>Class cComIEvoRuntime is a cComAutomationObject
9890>>>>>
9890>>>>>    Procedure ComSetErrorInfo String llMessage
9892>>>>>        Handle hDispatchDriver
9892>>>>>        Get phDispatchDriver to hDispatchDriver
9893>>>>>        Send PrepareParams to hDispatchDriver 1
9894>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llMessage
9895>>>>>        Send InvokeComMethod to hDispatchDriver 1 OLE_VT_VOID
9896>>>>>    End_Procedure
9897>>>>>
9897>>>>>    Function ComCreateErrorInfoData Returns Variant
9899>>>>>        Handle hDispatchDriver
9899>>>>>        Variant retVal
9899>>>>>        Get phDispatchDriver to hDispatchDriver
9900>>>>>        Get InvokeComMethod of hDispatchDriver 2 OLE_VT_VARIANT to retVal
9901>>>>>        Function_Return retVal
9902>>>>>    End_Function
9903>>>>>
9903>>>>>    Procedure ComSetErrorInfoWithData String llMessage Variant llData
9905>>>>>        Handle hDispatchDriver
9905>>>>>        Get phDispatchDriver to hDispatchDriver
9906>>>>>        Send PrepareParams to hDispatchDriver 2
9907>>>>>        Send DefineParam to hDispatchDriver OLE_VT_BSTR llMessage
9908>>>>>        Send DefineParam to hDispatchDriver OLE_VT_VARIANT llData
9909>>>>>        Send InvokeComMethod to hDispatchDriver 3 OLE_VT_VOID
9910>>>>>    End_Procedure
9911>>>>>
9911>>>>>    Procedure ComResetErrorInfo
9913>>>>>        Handle hDispatchDriver
9913>>>>>        Get phDispatchDriver to hDispatchDriver
9914>>>>>        Send InvokeComMethod to hDispatchDriver 4 OLE_VT_VOID
9915>>>>>    End_Procedure
9916>>>>>
9916>>>>>    Function ComJWT Returns Variant
9918>>>>>        Handle hDispatchDriver
9918>>>>>        Variant retVal
9918>>>>>        String sRetVal
9918>>>>>        Move "" to sRetVal
9919>>>>>        Get phDispatchDriver to hDispatchDriver
9920>>>>>        Get InvokeComMethod of hDispatchDriver 6 OLE_VT_BSTR to sRetVal
9921>>>>>        If (sRetVal <> "") Begin
9923>>>>>            Get InvokeComMethod of hDispatchDriver 5 OLE_VT_VARIANT to retVal
9924>>>>>        End
9924>>>>>>
9924>>>>>        Function_Return retVal
9925>>>>>    End_Function
9926>>>>>
9926>>>>>    Function ComJWS Returns String
9928>>>>>        Handle hDispatchDriver
9928>>>>>        String retVal
9928>>>>>        Get phDispatchDriver to hDispatchDriver
9929>>>>>        Get InvokeComMethod of hDispatchDriver 6 OLE_VT_BSTR to retVal
9930>>>>>        Function_Return retVal
9931>>>>>    End_Function
9932>>>>>    
9932>>>>>    Procedure ComHeartbeat
9934>>>>>        Handle hDispatchDriver
9934>>>>>        Get phDispatchDriver to hDispatchDriver
9935>>>>>        Send InvokeComMethod to hDispatchDriver 7 OLE_VT_VOID
9936>>>>>    End_Procedure    
9937>>>>>End_Class
9938>>>>>
9938>>>>>// CLSID: {60BF5709-ADBD-44E0-8A5E-372096E83149}
9938>>>>>Class cComIEvoServiceRuntimeCollection is a cComAutomationObject
9939>>>>>
9939>>>>>    Function Com_NewEnum Returns Variant
9941>>>>>        Handle hDispatchDriver
9941>>>>>        Variant retVal
9941>>>>>        Get phDispatchDriver to hDispatchDriver
9942>>>>>        Get InvokeComMethod of hDispatchDriver -4 OLE_VT_UNKNOWN to retVal
9943>>>>>        Function_Return retVal
9944>>>>>    End_Function
9945>>>>>
9945>>>>>    Function ComItem Integer llIndex Returns Variant
9947>>>>>        Handle hDispatchDriver
9947>>>>>        Variant retVal
9947>>>>>        Get phDispatchDriver to hDispatchDriver
9948>>>>>        Send PrepareParams to hDispatchDriver 1
9949>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
9950>>>>>        Get InvokeComMethod of hDispatchDriver 0 OLE_VT_DISPATCH to retVal
9951>>>>>        Function_Return retVal
9952>>>>>    End_Function
9953>>>>>
9953>>>>>    Function ComCount Returns Integer
9955>>>>>        Handle hDispatchDriver
9955>>>>>        Integer retVal
9955>>>>>        Get phDispatchDriver to hDispatchDriver
9956>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_I4 to retVal
9957>>>>>        Function_Return retVal
9958>>>>>    End_Function
9959>>>>>
9959>>>>>    Procedure ComAdd Variant llServiceRuntime
9961>>>>>        Handle hDispatchDriver
9961>>>>>        Get phDispatchDriver to hDispatchDriver
9962>>>>>        Send PrepareParams to hDispatchDriver 1
9963>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llServiceRuntime
9964>>>>>        Send InvokeComMethod to hDispatchDriver 2 OLE_VT_VOID
9965>>>>>    End_Procedure
9966>>>>>
9966>>>>>    Procedure ComRemove Integer llIndex
9968>>>>>        Handle hDispatchDriver
9968>>>>>        Get phDispatchDriver to hDispatchDriver
9969>>>>>        Send PrepareParams to hDispatchDriver 1
9970>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llIndex
9971>>>>>        Send InvokeComMethod to hDispatchDriver 3 OLE_VT_VOID
9972>>>>>    End_Procedure
9973>>>>>End_Class
9974>>>>>
9974>>>>>// CLSID: {3F222A3B-68A7-4059-9A84-FBB42096401B}
9974>>>>>Class cComIEvoSimpleServerSettings is a cComAutomationObject
9975>>>>>
9975>>>>>    Function ComTcpPort Returns UShort
9977>>>>>        Handle hDispatchDriver
9977>>>>>        UShort retVal
9977>>>>>        Get phDispatchDriver to hDispatchDriver
9978>>>>>        Get InvokeComMethod of hDispatchDriver 10 OLE_VT_UI2 to retVal
9979>>>>>        Function_Return retVal
9980>>>>>    End_Function
9981>>>>>
9981>>>>>    Procedure Set ComTcpPort UShort value
9983>>>>>        Handle hDispatchDriver
9983>>>>>        Get phDispatchDriver to hDispatchDriver
9984>>>>>        Send PrepareParams to hDispatchDriver 1
9985>>>>>        Set ComProperty of hDispatchDriver 10 OLE_VT_UI2 to value
9986>>>>>    End_Procedure
9987>>>>>
9987>>>>>    Function ComServerTransport Returns OLEEVO_TRANSPORTS
9989>>>>>        Handle hDispatchDriver
9989>>>>>        OLEEVO_TRANSPORTS retVal
9989>>>>>        Get phDispatchDriver to hDispatchDriver
9990>>>>>        Get InvokeComMethod of hDispatchDriver 20 OLE_VT_I4 to retVal
9991>>>>>        Function_Return retVal
9992>>>>>    End_Function
9993>>>>>
9993>>>>>    Procedure Set ComServerTransport OLEEVO_TRANSPORTS value
9995>>>>>        Handle hDispatchDriver
9995>>>>>        Get phDispatchDriver to hDispatchDriver
9996>>>>>        Send PrepareParams to hDispatchDriver 1
9997>>>>>        Set ComProperty of hDispatchDriver 20 OLE_VT_I4 to value
9998>>>>>    End_Procedure
9999>>>>>
9999>>>>>    Function ComServerProtocol Returns OLEEVO_PROTOCOLS
10001>>>>>        Handle hDispatchDriver
10001>>>>>        OLEEVO_PROTOCOLS retVal
10001>>>>>        Get phDispatchDriver to hDispatchDriver
10002>>>>>        Get InvokeComMethod of hDispatchDriver 30 OLE_VT_I4 to retVal
10003>>>>>        Function_Return retVal
10004>>>>>    End_Function
10005>>>>>
10005>>>>>    Procedure Set ComServerProtocol OLEEVO_PROTOCOLS value
10007>>>>>        Handle hDispatchDriver
10007>>>>>        Get phDispatchDriver to hDispatchDriver
10008>>>>>        Send PrepareParams to hDispatchDriver 1
10009>>>>>        Set ComProperty of hDispatchDriver 30 OLE_VT_I4 to value
10010>>>>>    End_Procedure
10011>>>>>
10011>>>>>    Function ComLocalizeDatetime Returns Boolean
10013>>>>>        Handle hDispatchDriver
10013>>>>>        Boolean retVal
10013>>>>>        Get phDispatchDriver to hDispatchDriver
10014>>>>>        Get InvokeComMethod of hDispatchDriver 40 OLE_VT_BOOL to retVal
10015>>>>>        Function_Return retVal
10016>>>>>    End_Function
10017>>>>>
10017>>>>>    Procedure Set ComLocalizeDatetime Boolean value
10019>>>>>        Handle hDispatchDriver
10019>>>>>        Get phDispatchDriver to hDispatchDriver
10020>>>>>        Send PrepareParams to hDispatchDriver 1
10021>>>>>        Set ComProperty of hDispatchDriver 40 OLE_VT_BOOL to value
10022>>>>>    End_Procedure
10023>>>>>
10023>>>>>    Function ComStringEncoding Returns OLEEVO_ENCODINGS
10025>>>>>        Handle hDispatchDriver
10025>>>>>        OLEEVO_ENCODINGS retVal
10025>>>>>        Get phDispatchDriver to hDispatchDriver
10026>>>>>        Get InvokeComMethod of hDispatchDriver 50 OLE_VT_I4 to retVal
10027>>>>>        Function_Return retVal
10028>>>>>    End_Function
10029>>>>>
10029>>>>>    Procedure Set ComStringEncoding OLEEVO_ENCODINGS value
10031>>>>>        Handle hDispatchDriver
10031>>>>>        Get phDispatchDriver to hDispatchDriver
10032>>>>>        Send PrepareParams to hDispatchDriver 1
10033>>>>>        Set ComProperty of hDispatchDriver 50 OLE_VT_I4 to value
10034>>>>>    End_Procedure
10035>>>>>
10035>>>>>    Function ComIncomingJwtConfigurations Returns String
10037>>>>>        Handle hDispatchDriver
10037>>>>>        String retVal
10037>>>>>        Get phDispatchDriver to hDispatchDriver
10038>>>>>        Get InvokeComMethod of hDispatchDriver 60 OLE_VT_BSTR to retVal
10039>>>>>        Function_Return retVal
10040>>>>>    End_Function
10041>>>>>
10041>>>>>    Procedure Set ComIncomingJwtConfigurations String value
10043>>>>>        Handle hDispatchDriver
10043>>>>>        Get phDispatchDriver to hDispatchDriver
10044>>>>>        Send PrepareParams to hDispatchDriver 1
10045>>>>>        Set ComProperty of hDispatchDriver 60 OLE_VT_BSTR to value
10046>>>>>    End_Procedure
10047>>>>>
10047>>>>>    Function ComOutgoingJwtConfiguration Returns String
10049>>>>>        Handle hDispatchDriver
10049>>>>>        String retVal
10049>>>>>        Get phDispatchDriver to hDispatchDriver
10050>>>>>        Get InvokeComMethod of hDispatchDriver 70 OLE_VT_BSTR to retVal
10051>>>>>        Function_Return retVal
10052>>>>>    End_Function
10053>>>>>
10053>>>>>    Procedure Set ComOutgoingJwtConfiguration String value
10055>>>>>        Handle hDispatchDriver
10055>>>>>        Get phDispatchDriver to hDispatchDriver
10056>>>>>        Send PrepareParams to hDispatchDriver 1
10057>>>>>        Set ComProperty of hDispatchDriver 70 OLE_VT_BSTR to value
10058>>>>>    End_Procedure
10059>>>>>End_Class
10060>>>>>
10060>>>>>// CLSID: {91BB24E5-0D9F-4A7B-9641-77727DAC8A38}
10060>>>>>Class cComIEvoConsole is a cComAutomationObject
10061>>>>>
10061>>>>>    Function ComConnect Variant llServer Variant llServices OLEEVO_MARSHALING_MODES llmode Returns UInteger
10063>>>>>        Handle hDispatchDriver
10063>>>>>        UInteger retVal
10063>>>>>        Get phDispatchDriver to hDispatchDriver
10064>>>>>        Send PrepareParams to hDispatchDriver 3
10065>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llServer
10066>>>>>        Send DefineParam to hDispatchDriver OLE_VT_DISPATCH llServices
10067>>>>>        Send DefineParam to hDispatchDriver OLE_VT_I4 llmode
10068>>>>>        Get InvokeComMethod of hDispatchDriver 1 OLE_VT_UI4 to retVal
10069>>>>>        Function_Return retVal
10070>>>>>    End_Function
10071>>>>>
10071>>>>>    Procedure ComDisconnect UInteger llCookie
10073>>>>>        Handle hDispatchDriver
10073>>>>>        Get phDispatchDriver to hDispatchDriver
10074>>>>>        Send PrepareParams to hDispatchDriver 1
10075>>>>>        Send DefineParam to hDispatchDriver OLE_VT_UI4 llCookie
10076>>>>>        Send InvokeComMethod to hDispatchDriver 2 OLE_VT_VOID
10077>>>>>    End_Procedure
10078>>>>>
10078>>>>>    Function ComIsRunning Returns Boolean
10080>>>>>        Handle hDispatchDriver
10080>>>>>        Boolean retVal
10080>>>>>        Get phDispatchDriver to hDispatchDriver
10081>>>>>        Get InvokeComMethod of hDispatchDriver 3 OLE_VT_BOOL to retVal
10082>>>>>        Function_Return retVal
10083>>>>>    End_Function
10084>>>>>End_Class
10085>>>Use Dferror.pkg
Including file: Dferror.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\Dferror.pkg)
10085>>>>>Use LanguageText.pkg
10085>>>>>Use Windows.pkg
10085>>>>>Use msgbox.pkg
10085>>>>>Use GlobalFunctionsProcedures.pkg
10085>>>>>
10085>>>>>// Include or define all useful symbols.
10085>>>>>Use errornum.inc
10085>>>>>// these are kept for compatibility. Don't use them
10085>>>>>
10085>>>>>// used by error handler and UserError to pull a caption out of the error string
10085>>>>>Define C_ErrorCaption for "*CAPTION*="
10085>>>>>
10085>>>>>// This array stores the set of trapped errors as toggled ranges starting
10085>>>>>// with the errors that are trapped. The array should always contain 0 and
10085>>>>>// MAX_ERROR_NUMBER + 1, which are the limits. If an array contained the
10085>>>>>// following items...
10085>>>>>//
10085>>>>>// { 0, 5, 10, MAX_ERROR_NUMBER + 1 }.
10085>>>>>//
10085>>>>>// This would mean that errors 1 - 4 are trapped, 5 - 9 are ignored, and
10085>>>>>// 10 through the rest are trapped.
10085>>>>>//
10085>>>>>Class Trapped_Errors_Array is an array
10086>>>>>    
10086>>>>>    // Find largest error LE targetError. Assumes array is sorted.
10086>>>>>    Function findErrorLE Integer targetError Returns Integer
10088>>>>>        
10088>>>>>        Integer lowIndex hiIndex midIndex currError
10088>>>>>        
10088>>>>>        // If error is outside of boudary conditions, use
10088>>>>>        // value of closest valid error# instead.
10088>>>>>        If (targetError <= 0);            Move 1 to targetError
10091>>>>>        Else If (targetError >= MAX_ERROR_NUMBER) ;            Move ( MAX_ERROR_NUMBER - 1 ) to targetError
10095>>>>>        
10095>>>>>        Move 0 to lowIndex
10096>>>>>        Move ( item_count( Self ) - 1 ) to hiIndex
10097>>>>>        
10097>>>>>        // midIndex will contain the closest error LE to target upon exit.
10097>>>>>        Repeat
10097>>>>>>
10097>>>>>            
10097>>>>>            Move ( ( lowIndex + hiIndex ) / 2 ) to midIndex
10098>>>>>            Move ( integer_value( Self, midIndex ) )  to currError
10099>>>>>            
10099>>>>>            // midIndex is targetIndex if a match occurs
10099>>>>>            If (currError = targetError) ;                Function_Return midIndex
10102>>>>>            
10102>>>>>            // We are either on it or just below it.
10102>>>>>            If ( lowIndex = midIndex ) Begin
10104>>>>>                
10104>>>>>                If ( integer_value( Self, hiIndex ) le targetError ) ;                    Move hiIndex to midIndex
10107>>>>>                
10107>>>>>                Function_Return midIndex
10108>>>>>                
10108>>>>>            End
10108>>>>>>
10108>>>>>            
10108>>>>>            // No match, so move the boundaries.
10108>>>>>            If (currError > targetError) ;                Move ( midIndex - 1 ) to hiIndex
10111>>>>>            Else ;                Move midIndex to lowIndex
10113>>>>>            
10113>>>>>        Until lowIndex gt hiIndex
10115>>>>>        
10115>>>>>        Function_Return midIndex
10116>>>>>        
10116>>>>>    End_Function
10117>>>>>    
10117>>>>>    // Boundaries of the table are assumed to hold error limits.
10117>>>>>    Procedure initArray
10119>>>>>        Send delete_data
10120>>>>>        Set array_value 0 to 0
10121>>>>>        Set array_value 1 to ( MAX_ERROR_NUMBER + 1 )
10122>>>>>    End_Procedure
10123>>>>>    
10123>>>>>    // Return 1 if Error is trapped, 0 otherwise.
10123>>>>>    Function IsTrapped Integer Error# Returns Integer
10125>>>>>        Function_Return ( not ( mod( findErrorLE( Self, Error# ), 2 ) ) )
10126>>>>>    End_Function
10127>>>>>    
10127>>>>>    // Add the error as long as it doesn't violate boundary conditions.
10127>>>>>    // This routine leaves the array unsorted.
10127>>>>>    Procedure addError Integer Error#
10129>>>>>        If ( ( Error# lt MAX_ERROR_NUMBER ) and ( Error# gt 0 ) ) ;            Set array_value ( item_count( Self ) ) to ( Integer( Error# ) )
10132>>>>>    End_Procedure
10133>>>>>    
10133>>>>>    // Set error to flagged state.
10133>>>>>    Procedure handleError Integer Error# Integer trapFlag
10135>>>>>        
10135>>>>>        Integer prevErrIndex prevErrFlag prevErrValue nextErrValue
10135>>>>>        
10135>>>>>        If ( ( Error# gt MAX_ERROR_NUMBER ) or ( Error# lt 0 ) ) Begin
10137>>>>>            Error DFERR_ERROR_NUMBER_OUT_OF_RANGE
10138>>>>>>
10138>>>>>            Procedure_Return
10139>>>>>        End
10139>>>>>>
10139>>>>>        
10139>>>>>        Get findErrorLE Error# to prevErrIndex
10140>>>>>        Get isTrapped   Error# to prevErrFlag
10141>>>>>        
10141>>>>>        // if eq, Error already handled in some range.
10141>>>>>        If (prevErrFlag <> trapFlag) Begin
10143>>>>>            
10143>>>>>            // This is kind of complicated. If we are adding an error,
10143>>>>>            // we have to account for the error already being in the
10143>>>>>            // array as well as rejoining ranges that have been previously
10143>>>>>            // split and splitting ranges when adding a new flag.
10143>>>>>            
10143>>>>>            Get integer_value ( prevErrIndex + 1 ) to nextErrValue
10144>>>>>            Get integer_value prevErrIndex         to prevErrValue
10145>>>>>            
10145>>>>>            // Do this first so prevErrIndex stays valid.
10145>>>>>            If (nextErrValue = ( Error# + 1 )) ;                Send delete_item ( prevErrIndex + 1 )
10148>>>>>            Else ;                Send addError ( Error# + 1 )
10150>>>>>            
10150>>>>>            If ( prevErrValue lt Error# ) ;                Send addError Error#
10153>>>>>            Else ;                Send delete_item prevErrIndex
10155>>>>>        End
10155>>>>>>
10155>>>>>        Send sort_items UPWARD_DIRECTION
10156>>>>>        
10156>>>>>    End_Procedure
10157>>>>>    
10157>>>>>    // Flag error as trappable
10157>>>>>    Procedure Trap_Error Integer Error#
10159>>>>>        Send handleError Error# 1
10160>>>>>    End_Procedure
10161>>>>>    
10161>>>>>    // Flag error as non-trappable
10161>>>>>    Procedure Ignore_Error Integer Error#
10163>>>>>        Send handleError Error# 0
10164>>>>>    End_Procedure
10165>>>>>    
10165>>>>>    // Flag all errors as trappable
10165>>>>>    Procedure Trap_All
10167>>>>>        Send initArray
10168>>>>>    End_Procedure
10169>>>>>    
10169>>>>>    // Flag all errors as non-trappable
10169>>>>>    Procedure Ignore_All
10171>>>>>        Send delete_data
10172>>>>>        Set array_value 0 to 0
10173>>>>>        Set array_value 1 to 1
10174>>>>>        Set array_value 2 to ( MAX_ERROR_NUMBER + 1 )
10175>>>>>    End_Procedure
10176>>>>>    
10176>>>>>End_Class
10177>>>>>
10177>>>>>
10177>>>>>Class ErrorSystem is a cObject
10178>>>>>    
10178>>>>>    Procedure construct_object
10180>>>>>        Forward Send construct_object
10182>>>>>        
10182>>>>>        Set delegation_mode to no_delegate_or_error
10183>>>>>        
10183>>>>>        Property Integer Verbose_State            True
10184>>>>>        Property Integer Current_Error_Number     0
10185>>>>>        Property Integer Error_Line_Number        0
10186>>>>>        
10186>>>>>        // If set false, this makes the error handler work the old way which
10186>>>>>        // does not use the new unhandled dialog. Only exists for compatibility reasons
10186>>>>>        Property Boolean pbUnhandledErrorSupport       True
10187>>>>>        
10187>>>>>        // shows error numbers with user errors. Only set this true if your
10187>>>>>        // application has meaningful numbers that helps the end user. Note that
10187>>>>>        // unhandled errors always show numbers.
10187>>>>>        // this is ignored if pbUnhandledErrorSupport is false
10187>>>>>        Property Boolean pbShowErrorNumber        False
10188>>>>>        
10188>>>>>        
10188>>>>>        // This is the caption that appears for unhandled errors dialog box
10188>>>>>        Property String psUnhandledErrorCaption C_$UnhandledProgramError
10189>>>>>        
10189>>>>>        // This is the caption that appears for standard user errors
10189>>>>>        Property String psUserErrorCaption C_$Error
10190>>>>>        
10190>>>>>        // Flag which is sent when error is being processed. This
10190>>>>>        // stops error recursion.
10190>>>>>        Property Integer Error_Processing_State  False
10191>>>>>        
10191>>>>>        // array of errors that we consider User Errors
10191>>>>>        Property Integer[] pUserErrorsArray
10192>>>>>        
10192>>>>>        //  This allows us to skip find errors (GT & LT) and to only
10192>>>>>        //  ring a bell when these occur.
10192>>>>>        //
10192>>>>>        Property Integer Bell_on_Find_Error_State True
10193>>>>>        
10193>>>>>        Object TrappedErrors is a Trapped_Errors_Array
10195>>>>>            Send initArray
10196>>>>>        End_Object
10197>>>>>        
10197>>>>>        Send Trap_All
10198>>>>>        
10198>>>>>        // define the standard user error numbers
10198>>>>>        Send AddUserError 0
10199>>>>>        Send AddUserError DFERR_NUMBER_TOO_LARGE
10200>>>>>        Send AddUserError DFERR_WINDOW_RANGE
10201>>>>>        Send AddUserError DFERR_ENTRY_REQUIRED
10202>>>>>        Send AddUserError DFERR_ENTER_A_NUMBER
10203>>>>>        Send AddUserError DFERR_BAD_ENTRY
10204>>>>>        Send AddUserError DFERR_ENTER_VALID_DATE
10205>>>>>        Send AddUserError DFERR_NUMERIC_RANGE
10206>>>>>        Send AddUserError DFERR_DUPLICATE_REC
10207>>>>>        Send AddUserError DFERR_TEXT_FIELD_TOO_LONG
10208>>>>>        Send AddUserError DFERR_FIND_PRIOR_BEG_OF_FILE
10209>>>>>        Send AddUserError DFERR_FIND_PAST_END_OF_FILE
10210>>>>>        Send AddUserError DFERR_NO_REC_TO_DELETE
10211>>>>>        Send AddUserError DFERR_FIELD_NOT_INDEXED // can be invoked w/ find keys
10212>>>>>        Send AddUserError DFERR_REC_NUMBER_RANGE
10213>>>>>        Send AddUserError DFERR_ENTER_VALID_REC_ID
10214>>>>>        Send AddUserError DFERR_OPERATOR_ERROR
10215>>>>>        Send AddUserError DFERR_CANT_CHANGE_KEY_FIELD
10216>>>>>        Send AddUserError DFERR_NO_DELETE_RELATED_RECORDS_EXIST
10217>>>>>        Send AddUserError DFERR_OPERATION_NOT_ALLOWED
10218>>>>>        Send AddUserError DFERR_OPERATOR
10219>>>>>        Send AddUserError DFERR_XML_HTTP
10220>>>>>        Send AddUserError DFERR_CLIENT_SOAP_TRANSFER
10221>>>>>        Send AddUserError DFERR_CLIENT_SOAP_FAULT
10222>>>>>        Send AddUserError DFERR_TEXT_TOO_LARGE_FOR_FIELD
10223>>>>>        Send AddUserError DFERR_WINPRINT
10224>>>>>        Send AddUserError DFERR_CRYSTAL_REPORT
10225>>>>>        Send AddUserError DFERR_MAPI
10226>>>>>        Send AddUserError DFERR_FILE_ACCESS_VIOLATION
10227>>>>>        Send AddUserError DFERR_DATAFLEX_REPORTS
10228>>>>>        Send AddUserError DFERR_CANT_REFIND_RECORD
10229>>>>>        Send AddUserError 999 // This is defined as DD_DEFAULT_ERROR_NUMBER in DataDict.pkg and is the default Field_error
10230>>>>>        // number of DDs.
10230>>>>>        Move Self to Error_Object_Id
10231>>>>>    End_Procedure
10232>>>>>    
10232>>>>>    Function Help_Context Integer Context_Type Returns String
10234>>>>>        Function_Return (Current_Error_Number(Self))
10235>>>>>    End_Function
10236>>>>>    
10236>>>>>    // Catch and display error Error#.
10236>>>>>    Procedure Trap_Error Integer Error#
10238>>>>>        Send Trap_Error to ( trappedErrors( Self ) ) Error#
10239>>>>>    End_Procedure
10240>>>>>    
10240>>>>>    // Pass error Error# on to the regular DataFlex error handler.
10240>>>>>    Procedure Ignore_Error Integer Error#
10242>>>>>        Send Ignore_Error to ( trappedErrors( Self ) ) Error#
10243>>>>>    End_Procedure
10244>>>>>    
10244>>>>>    // Catch and display all errors.
10244>>>>>    Procedure Trap_All
10246>>>>>        Send Trap_All to ( trappedErrors( Self ) )
10247>>>>>    End_Procedure
10248>>>>>    
10248>>>>>    // Forward all error to regular DataFlex error handler.
10248>>>>>    Procedure Ignore_All
10250>>>>>        Send Ignore_All to ( trappedErrors( Self ) )
10251>>>>>    End_Procedure
10252>>>>>    
10252>>>>>    // Build complete error description from Flexerrs and user error message.
10252>>>>>    Function Error_Description Integer Error# String ErrMsg Returns String
10254>>>>>        String Full_Error_Text
10254>>>>>        
10254>>>>>        Move (Trim(ErrMsg)) to ErrMsg
10255>>>>>        Move (trim(error_text(DESKTOP,Error#))) to Full_Error_Text
10256>>>>>        
10256>>>>>        If (ErrMsg<>"") Begin
10258>>>>>            
10258>>>>>            If ( ( Full_Error_Text<>"" ) and ;                error_text_available( DESKTOP, Error# ) ) Begin
10260>>>>>                // Make sure last character of error text is a separating symbol.
10260>>>>>                // if not, add a "." So we have format of "error-text. error-detail"
10260>>>>>                If ( pos(right(Full_error_text,1),".,:;")=0 ) ;                    Move (Full_Error_Text - ".") to Full_Error_Text
10263>>>>>                Move (Full_Error_Text * ErrMsg) to Full_Error_Text
10264>>>>>            End
10264>>>>>>
10264>>>>>            Else ;                Move ErrMsg to Full_Error_Text
10266>>>>>            
10266>>>>>        End
10266>>>>>>
10266>>>>>        
10266>>>>>        Function_Return Full_Error_Text
10267>>>>>    End_Function
10268>>>>>    
10268>>>>>    // return true if an error number is critical
10268>>>>>    Function Is_Critical Integer Error# Returns Integer
10270>>>>>        Function_Return (".3.10.18.19.20.21.22.43.70.72.74.75.78.80.97.";            contains ("."+String(Error#)+"."))
10271>>>>>    End_Function
10272>>>>>    
10272>>>>>    // adds a user error to the array
10272>>>>>    Procedure AddUserError Integer iError
10274>>>>>        Integer[] UserErrors
10275>>>>>        Get pUserErrorsArray to UserErrors
10276>>>>>        // We assume that there are few enough user errors to worry about speed of finding
10276>>>>>        // the an array item. It always does a linear seach, which should be plenty fast.
10276>>>>>        If (SearchArray(iError,UserErrors)=-1) Begin
10278>>>>>            Move iError to UserErrors[SizeOfArray(UserErrors)]
10279>>>>>            Set pUserErrorsArray to UserErrors
10280>>>>>        End
10280>>>>>>
10280>>>>>    End_Procedure
10281>>>>>    
10281>>>>>    // removes an error from the user array
10281>>>>>    Procedure RemoveUserError Integer iError
10283>>>>>        Integer[] UserErrors
10284>>>>>        Integer iIndex iSize
10284>>>>>        Get pUserErrorsArray to UserErrors
10285>>>>>        Move (SearchArray(iError,UserErrors)) to iIndex
10286>>>>>        If (iIndex<>-1) Begin
10288>>>>>            // replace the removed error with the last error and resize the array
10288>>>>>            Move (SizeOfArray(UserErrors)) to iSize
10289>>>>>            Move UserErrors[iSize-1] to UserErrors[iIndex]
10290>>>>>            Set pUserErrorsArray to (ResizeArray(UserErrors,iSize-1))
10291>>>>>        End
10291>>>>>>
10291>>>>>    End_Procedure
10292>>>>>    
10292>>>>>    // removes all user errors
10292>>>>>    Procedure RemoveAllUserErrors
10294>>>>>        Integer[] UserErrors
10295>>>>>        Set pUserErrorsArray to UserErrors
10296>>>>>    End_Procedure
10297>>>>>    
10297>>>>>    // returns true if this is an unhandled error (i.e., not a user error
10297>>>>>    Function IsUnhandledError Integer iError Returns Boolean
10299>>>>>        Integer[] UserErrors
10300>>>>>        Get pUserErrorsArray to UserErrors
10301>>>>>        Function_Return (SearchArray(iError,UserErrors)=-1)
10302>>>>>    End_Function
10303>>>>>    
10303>>>>>    Procedure UnhandledErrorDisplay Integer iErrorLine String sMessage
10305>>>>>        String sCaption sCRLF
10305>>>>>        Move (Character(13)+Character(10)) to sCRLF
10306>>>>>        Get psUnhandledErrorCaption to sCaption
10307>>>>>        Move (Replaces("\n",sMessage,sCRLF)) to sMessage
10308>>>>>        Move (Replaces("\"+sCRLF, sMessage, "\n")) to sMessage
10309>>>>>        ErrorDisplay iErrorLine sMessage sCaption C_$OK C_$Copy
10310>>>>>    End_Procedure
10311>>>>>    
10311>>>>>    // Handle error event, displaying error info to user.
10311>>>>>    Procedure Error_Report Integer ErrNum Integer Err_Line String ErrMsg
10313>>>>>        Integer iReply iIcon
10313>>>>>        String  sErrorText sMess
10313>>>>>        String  sSource sCaption
10313>>>>>        Integer iSrcPos iSrc iTxtLen
10313>>>>>        Boolean bIsUnhandled bUnhandledSupport bCritical bVerbose
10313>>>>>        
10313>>>>>        If (Error_processing_State(Self)) Begin // don't allow error
10315>>>>>            Procedure_Return                     // recursion
10316>>>>>        End
10316>>>>>>
10316>>>>>        
10316>>>>>        Set Error_Processing_State to True // we are now in an error reporting state
10317>>>>>        
10317>>>>>        Set Current_Error_Number to ErrNum
10318>>>>>        Set Error_Line_Number    to Err_Line
10319>>>>>        
10319>>>>>        // if this is false, this will work old-style -- all errors go through message box
10319>>>>>        Get pbUnhandledErrorSupport to bUnhandledSupport
10320>>>>>        
10320>>>>>        Get Is_Critical errnum to bCritical
10321>>>>>        Get IsUnhandledError ErrNum to bIsUnhandled
10322>>>>>        
10322>>>>>        
10322>>>>>        //
10322>>>>>        //   Changes made so find errors don't report - just beep
10322>>>>>        //
10322>>>>>        
10322>>>>>        If ( Bell_On_find_Error_State(Self) and ;            ErrNum=DFERR_FIND_PRIOR_BEG_OF_FILE or ErrNum=DFERR_FIND_PAST_END_OF_FILE) Begin
10324>>>>>            Send Bell
10325>>>>>        End
10325>>>>>>
10325>>>>>        Else If not ( isTrapped( TrappedErrors( Self ), ErrNum ) ) Begin
10328>>>>>            // if trapped do nothing
10328>>>>>            
10328>>>>>            // We used to forward send. Since this is based on array, it does not understand this message, the forward was
10328>>>>>            // not understood. Since arrays don't delegate or error, nothing happened.
10328>>>>>            // An easier way to do nothing, is to do nothing, hence this line if removed
10328>>>>>            //forward send Error_Report ErrNum Err_Line ErrMsg
10328>>>>>        End
10328>>>>>>
10328>>>>>        Else Begin
10329>>>>>            
10329>>>>>            // See if source information is provided (Source = module.function). If so remove
10329>>>>>            // as detail. Must find last instance of this in string
10329>>>>>            Move (pos(C_ErrorContextSourceText,ErrMsg)) to iSrc
10330>>>>>            If iSrc Begin
10332>>>>>                Move (iSrc-1) to iSrcPos
10333>>>>>                Move (length(C_ErrorContextSourceText)) to  iTxtLen
10334>>>>>                Move ErrMsg to sSource
10335>>>>>                Repeat // this makes sure we find last instance of this
10335>>>>>>
10335>>>>>                    Move (remove(sSource, 1, iSrc-1 + iTxtLen )) to sSource // right part of string
10336>>>>>                    Move (pos(C_ErrorContextSourceText,sSource)) to iSrc           // see if it was the last
10337>>>>>                    If iSrc ;                                               // if not, track length                        Move (iSrcPos + iTxtLen + iSrc-1) to iSrcPos
10340>>>>>                Until (iSrc=0)
10342>>>>>                Move (trim(left(ErrMsg,iSrcPos))) to ErrMsg
10343>>>>>                If (right(ErrMsg,1)=',') ;                    Move (left(ErrMsg,length(ErrMsg)-1)) to ErrMsg
10346>>>>>            End
10346>>>>>>
10346>>>>>            
10346>>>>>            // the caption normally used for handled user errors
10346>>>>>            Get psUserErrorCaption to sCaption
10347>>>>>            // if an operator error this may be a Procedure UserError situation where the
10347>>>>>            // caption is passed in the error text. If so, get the caption
10347>>>>>            If (ErrNum=DFERR_OPERATOR) Begin
10349>>>>>                Move (pos(C_ErrorCaption,ErrMsg)) to iSrc
10350>>>>>                If iSrc Begin
10352>>>>>                    Move (length(C_ErrorCaption)) to  iTxtLen
10353>>>>>                    Move (remove(ErrMsg, 1, iSrc-1 + iTxtLen )) to sCaption
10354>>>>>                    Move (Left(ErrMsg,iSrc-1)) to ErrMsg
10355>>>>>                End
10355>>>>>>
10355>>>>>            End
10355>>>>>>
10355>>>>>            
10355>>>>>            Get Error_Description ErrNum ErrMsg to sErrorText
10356>>>>>            
10356>>>>>            // if the error source is identified we can get extended error
10356>>>>>            // text for our error message
10356>>>>>            If ghoErrorSource Begin
10358>>>>>                Get extended_error_Message of ghoErrorSource to sMess
10359>>>>>                If (sMess <> '') ;                    Move (sErrorText + "\n\n" + sMess ) to sErrorText
10362>>>>>            End
10362>>>>>>
10362>>>>>            
10362>>>>>            If (bUnhandledSupport) Begin
10364>>>>>                // as of 14.1, this is the preferred way to do errors
10364>>>>>                If ( bCritical or bIsUnhandled) Begin
10366>>>>>                    Move ( sErrorText + "\n\n" + C_$Error + ":" * String(ErrNum) ) to sErrorText
10367>>>>>                    If (sSource<>"") Begin
10369>>>>>                        Move (sErrorText + "\n" + C_$ErrorSource +" =" * sSource) to sErrorText
10370>>>>>                    End
10370>>>>>>
10370>>>>>                End
10370>>>>>>
10370>>>>>                Else If (pbShowErrorNumber(Self)) Begin
10373>>>>>                    // if a user error, we provide a way to see error numbers.
10373>>>>>                    Move ( sErrorText + "\n\n" + C_$Error + ":" * String(ErrNum) ) to sErrorText
10374>>>>>                End
10374>>>>>>
10374>>>>>            End
10374>>>>>>
10374>>>>>            Else Begin
10375>>>>>                // we get here if we want it to work the old (less good) way. This is provided
10375>>>>>                // only for backwards compatibility. All errors go through the message box
10375>>>>>                Get Verbose_State to bVerbose
10376>>>>>                If (bVerbose)  Begin
10378>>>>>                    Move ( sErrorText + "\n\n" + SFormat(C_$TechnicalDetails, ErrNum, Err_Line) ) to sErrorText
10379>>>>>                    If (sSource<>"") Begin
10381>>>>>                        Move (sErrorText + "\n" + C_$ErrorSource +" =" * sSource) to sErrorText
10382>>>>>                    End
10382>>>>>>
10382>>>>>                End
10382>>>>>>
10382>>>>>            End
10382>>>>>>
10382>>>>>            
10382>>>>>            If ( (bCritical or bIsUnhandled) and bUnhandledSupport) Begin
10384>>>>>                Send UnhandledErrorDisplay Err_Line sErrorText
10385>>>>>            End
10385>>>>>>
10385>>>>>            Else Begin
10386>>>>>                Move (If(bCritical,MB_IconHand,MB_IconExclamation)) to iIcon
10387>>>>>                Move (Message_Box(sErrorText, sCaption, MB_Ok, iIcon)) to iReply
10388>>>>>            End
10388>>>>>>
10388>>>>>            
10388>>>>>            // abort on critical errors
10388>>>>>            If bCritical ;                Abort
10391>>>>>            
10391>>>>>        End
10391>>>>>>
10391>>>>>        Move 0 to ghoErrorSource
10392>>>>>        Set Error_Processing_State to False // no longer reporting an error
10393>>>>>    End_Procedure
10394>>>>>    
10394>>>>>    
10394>>>>>    // The following functions are rarely or never used.
10394>>>>>    
10394>>>>>    // The functions below are used to construct a general help
10394>>>>>    // name for errors that are generated by the system.  If processing
10394>>>>>    // comes here, then there was no module specific help found.  These
10394>>>>>    // functions will provide a more general help name that appears in
10394>>>>>    // the form of SYSTEM..ERROR:#.  All global errors should be
10394>>>>>    // places in the help file under this application and module name.
10394>>>>>    
10394>>>>>    // Returns "ERROR:errornum" to supply error help.
10394>>>>>    Function Help_Name Returns String
10396>>>>>        Function_Return (Append("ERROR:",lastErr))
10397>>>>>    End_Function
10398>>>>>    
10398>>>>>    Function Application_Name Returns String
10400>>>>>        Function_Return 'SYSTEM'
10401>>>>>    End_Function
10402>>>>>    
10402>>>>>    Function Module_Name Returns String
10404>>>>>        Function_Return ''
10405>>>>>    End_Function
10406>>>>>End_Class
10407>>>>>
10407>>>>>Object Error_Info_Object is a ErrorSystem
10409>>>>>End_Object
10410>>>>>
10410>>>>>
10410>>>>>Procedure UserError Global String sMessage String sCaption
10412>>>>>    String sCapt
10412>>>>>    If (Error_Object_Id=0) Begin
10414>>>>>        Error DFERR_PROGRAM "No Error Handler"
10415>>>>>>
10415>>>>>        Procedure_Return
10416>>>>>    End
10416>>>>>>
10416>>>>>    
10416>>>>>    // Accept not passing a caption in which case the error handler's
10416>>>>>    // default caption. It had been the intention to require a caption ("" if none)
10416>>>>>    // but having no caption kind of worked where the caption would be "0". Since it
10416>>>>>    // kind of worked, I don't want to remove this which might generate runtime errors.
10416>>>>>    If (num_arguments>1) Begin
10418>>>>>        Move sCaption to sCapt
10419>>>>>    End
10419>>>>>>
10419>>>>>    
10419>>>>>    Error DFERR_OPERATOR (sMessage + If(sCapt<>"",C_ErrorCaption + sCapt,""))
10420>>>>>>
10420>>>>>    
10420>>>>>End_Procedure
10421>>>Use cTimer.pkg
Including file: cTimer.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cTimer.pkg)
10421>>>>>// This supercedes the DFTimer class.
10421>>>>>// It is simpler and more flexible
10421>>>>>
10421>>>>>Use Dftimer.pkg // we still use the Timer Manager classes and global objects
Including file: Dftimer.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\Dftimer.pkg)
10421>>>>>>>Use LanguageText.pkg
10421>>>>>>>Use Windows.pkg
10421>>>>>>>Use WinUser.pkg
10421>>>>>>>
10421>>>>>>>External_Function SetTimer "SetTimer" User32.DLL ;    Handle  hWnd ;    Longptr idTimer ;    Integer idTimeout ;    Pointer tmprc ;    Returns Longptr     // return type is UINT_PTR
10422>>>>>>>
10422>>>>>>>External_Function KillTimer "KillTimer" User32.DLL ;    Handle  hWnd ;    Longptr idTimer ;    Returns Integer
10423>>>>>>>
10423>>>>>>>// This global integer holds the ID of the object
10423>>>>>>>// that manages all timers.
10423>>>>>>>Integer giTimerManager
10423>>>>>>>
10423>>>>>>>// This class is used to store the object IDs
10423>>>>>>>// of the active timer objects. It augments
10423>>>>>>>// the Destroy_Object procedure to notify
10423>>>>>>>// the DFTimerManager to kill all its active
10423>>>>>>>// timers.
10423>>>>>>>// NOTE: This class looks very much like the
10423>>>>>>>// Set class. I didn't want to use Set because
10423>>>>>>>// Remove_Element shifts items which I don't
10423>>>>>>>// want to happen because item numbers are used
10423>>>>>>>// as timerIDs.
10423>>>>>>>
10423>>>>>>>Class TimersArray is an Array
10424>>>>>>>    
10424>>>>>>>    Function Find_Object Integer iObj Returns Integer
10426>>>>>>>        Integer iMax
10426>>>>>>>        Integer iItem
10426>>>>>>>        Integer iValue
10426>>>>>>>        Get Item_count to iMax
10427>>>>>>>        Decrement iMax
10428>>>>>>>        For iItem from 1 to iMax
10434>>>>>>>>
10434>>>>>>>            Get Integer_Value iItem to iValue
10435>>>>>>>            If (iValue = iObj) ;                Function_Return iItem
10438>>>>>>>        Loop
10439>>>>>>>>
10439>>>>>>>        Function_Return -1
10440>>>>>>>    End_Function
10441>>>>>>>    
10441>>>>>>>    Procedure Add_Object Integer iObj Returns Integer
10443>>>>>>>        Integer iItem
10443>>>>>>>        Get Find_Object iObj to iItem
10444>>>>>>>        If (iItem < 0) Begin
10446>>>>>>>            Get Find_Object 0 to iItem
10447>>>>>>>            If (iItem < 0) ;                Get Item_Count to iItem
10450>>>>>>>        End
10450>>>>>>>>
10450>>>>>>>        Set Array_Value iItem to iObj
10451>>>>>>>        Procedure_Return iItem
10452>>>>>>>    End_Procedure
10453>>>>>>>    
10453>>>>>>>    Procedure Remove_Object Integer iObj
10455>>>>>>>        Integer iItem
10455>>>>>>>        Get Find_Object iObj to iItem
10456>>>>>>>        If (iItem > 0) ;            Set Array_Value iItem to 0
10459>>>>>>>    End_Procedure
10460>>>>>>>    
10460>>>>>>>    Procedure Destroy_Object
10462>>>>>>>        Delegate Send Kill_All_Timers
10464>>>>>>>        Forward Send Destroy_Object
10466>>>>>>>    End_Procedure
10467>>>>>>>    
10467>>>>>>>End_Class
10468>>>>>>>
10468>>>>>>>// This class is the actual timer manager
10468>>>>>>>// A timer will be created when Message Set_Timer_Active_State
10468>>>>>>>// has been send. This message needs two arguments. The first
10468>>>>>>>// is the objectID of the object to receive the timer event,
10468>>>>>>>// and the second is state. The object which ID has been passed,
10468>>>>>>>// needs to have a Timeout property to return the timeout for the
10468>>>>>>>// timer and it also needs to handle the MSG_OnTimer whenever a
10468>>>>>>>// timer event occurs.
10468>>>>>>>// The objectID of the Object will be placed in an array which contains
10468>>>>>>>// the objectIDs of all active timers. The Windows timer ID of a timer
10468>>>>>>>// is the itemnumber of the object in the array.
10468>>>>>>>//
10468>>>>>>>Class DFTimerManager is a DfBaseControl
10469>>>>>>>    
10469>>>>>>>    Procedure Construct_Object
10471>>>>>>>        
10471>>>>>>>        Forward Send Construct_Object
10473>>>>>>>        
10473>>>>>>>        Set Visible_State to False
10474>>>>>>>        
10474>>>>>>>        Set External_Class_Name "cVdfTimer" to "static"
10475>>>>>>>        Set External_Message WM_TIMER to OnTimer
10476>>>>>>>        
10476>>>>>>>        Object TimersArray is a TimersArray
10478>>>>>>>            Set Array_Value 0 to -9999 // So we don't use item 0
10479>>>>>>>        End_Object
10480>>>>>>>        
10480>>>>>>>        Move Self to giTimerManager
10481>>>>>>>        
10481>>>>>>>    End_Procedure
10482>>>>>>>    
10482>>>>>>>    Procedure Set Timer_Active_State Integer iObj Integer iState
10484>>>>>>>        Integer iTimerID
10484>>>>>>>        Integer iTimeout
10484>>>>>>>        Integer iResult
10484>>>>>>>        Integer iSet
10484>>>>>>>        DWord   nResult
10484>>>>>>>        Handle  hWnd
10484>>>>>>>        
10484>>>>>>>        // Get the handle of this object
10484>>>>>>>        Get Window_Handle to hWnd
10485>>>>>>>        If (not(hWnd)) Begin
10487>>>>>>>            Error DFERR_DFTIMER C_$TimerNoHandle
10488>>>>>>>>
10488>>>>>>>            Procedure_Return
10489>>>>>>>        End
10489>>>>>>>>
10489>>>>>>>        
10489>>>>>>>        // Test if handle is valid. If not, we leave.
10489>>>>>>>        If (not(IsWindow(hWnd))) ;            Procedure_Return
10492>>>>>>>        
10492>>>>>>>        Move (TimersArray(Self)) to iSet
10493>>>>>>>        
10493>>>>>>>        If (iSet) Begin
10495>>>>>>>            
10495>>>>>>>            // Let's create or modify a timer
10495>>>>>>>            If iState Begin
10497>>>>>>>                
10497>>>>>>>                // Get the exising to new TimerID
10497>>>>>>>                Get MSG_Add_Object of iSet iObj to iTimerID
10498>>>>>>>                
10498>>>>>>>                // Set/Modify the timer
10498>>>>>>>                Get Timeout of iObj to iTimeout
10499>>>>>>>                Move (SetTimer(hWnd, iTimerID, iTimeout, 0)) to iResult
10500>>>>>>>                If not iResult Begin
10502>>>>>>>                    Error DFERR_DFTIMER C_$TooManyTimers
10503>>>>>>>>
10503>>>>>>>                    Procedure_Return
10504>>>>>>>                End
10504>>>>>>>>
10504>>>>>>>                
10504>>>>>>>            End
10504>>>>>>>>
10504>>>>>>>            
10504>>>>>>>            // Let's kill an existing timer
10504>>>>>>>            Else Begin
10505>>>>>>>                
10505>>>>>>>                // Look up the object in the set
10505>>>>>>>                Get Find_Object of iSet iObj to iTimerID
10506>>>>>>>                
10506>>>>>>>                If (iTimerID = -1) ;                    Procedure_Return
10509>>>>>>>                
10509>>>>>>>                // Kill the timer
10509>>>>>>>                Move (KillTimer(hWnd, iTimerID)) to iResult
10510>>>>>>>                If not iResult Begin
10512>>>>>>>                    Move (GetLastError()) to nResult
10513>>>>>>>                    Error DFERR_DFTIMER (C_$CantKillTimer * String(nResult) - "!")
10514>>>>>>>>
10514>>>>>>>                    Procedure_Return
10515>>>>>>>                End
10515>>>>>>>>
10515>>>>>>>                
10515>>>>>>>                // Remove the objectID
10515>>>>>>>                Send Remove_Object to iSet iObj
10516>>>>>>>            End
10516>>>>>>>>
10516>>>>>>>        End
10516>>>>>>>>
10516>>>>>>>    End_Procedure
10517>>>>>>>    
10517>>>>>>>    Function Timer_Active_State Integer iObj Returns Integer
10519>>>>>>>        Integer iResult
10519>>>>>>>        Get Find_Object of (TimersArray(Self)) iObj to iResult
10520>>>>>>>        Function_Return (iResult<>-1) // note: -1= not found
10521>>>>>>>    End_Function
10522>>>>>>>    
10522>>>>>>>    // Will be called by the Set when it is being destroyed.
10522>>>>>>>    Procedure Kill_All_Timers
10524>>>>>>>        Integer iMax
10524>>>>>>>        Integer iSet
10524>>>>>>>        Integer iItem
10524>>>>>>>        Integer iObj
10524>>>>>>>        Integer iResult
10524>>>>>>>        Handle  hWnd
10524>>>>>>>        
10524>>>>>>>        // Get the handle of this object
10524>>>>>>>        Get Window_Handle to hWnd
10525>>>>>>>        If (not(hWnd)) Begin
10527>>>>>>>            Error DFERR_DFTIMER C_$TimerNoHandle
10528>>>>>>>>
10528>>>>>>>            Procedure_Return
10529>>>>>>>        End
10529>>>>>>>>
10529>>>>>>>        
10529>>>>>>>        // If the window handle is no longer valid, we
10529>>>>>>>        // leave this procedure. This can happen when the
10529>>>>>>>        // program is begin aborted using Exit_Application
10529>>>>>>>        If (not(IsWindow(hWnd))) ;            Procedure_Return
10532>>>>>>>        
10532>>>>>>>        // Scan the set and kill all known timers
10532>>>>>>>        Move (TimersArray(Self)) to iSet
10533>>>>>>>        If (iSet) Begin
10535>>>>>>>            Get Item_Count of iSet to iMax
10536>>>>>>>            Decrement iMax
10537>>>>>>>            For iItem from 1 to iMax
10543>>>>>>>>
10543>>>>>>>                Get Integer_Value of iSet iItem to iObj
10544>>>>>>>                If iObj Begin
10546>>>>>>>                    Move (KillTimer(hWnd, iItem)) to iResult
10547>>>>>>>                    Set Array_Value of iSet iItem to 0
10548>>>>>>>                End
10548>>>>>>>>
10548>>>>>>>            Loop
10549>>>>>>>>
10549>>>>>>>        End
10549>>>>>>>>
10549>>>>>>>        
10549>>>>>>>    End_Procedure
10550>>>>>>>    
10550>>>>>>>    Procedure OnTimer Integer wParam Integer lParam
10552>>>>>>>        Integer iObj
10552>>>>>>>        Get Integer_Value of (TimersArray(Self)) wParam to iObj
10553>>>>>>>        If not iObj Begin
10555>>>>>>>            Error DFERR_DFTIMER C_$TimerWithoutObject
10556>>>>>>>>
10556>>>>>>>            Procedure_Return
10557>>>>>>>        End
10557>>>>>>>>
10557>>>>>>>        Send OnTimer to iObj wParam lParam
10558>>>>>>>    End_Procedure
10559>>>>>>>    
10559>>>>>>>    Procedure Destroy_Object
10561>>>>>>>        Send Kill_All_Timers
10562>>>>>>>        Forward Send Destroy_Object
10564>>>>>>>        Move 0 to giTimerManager
10565>>>>>>>    End_Procedure
10566>>>>>>>    
10566>>>>>>>End_Class
10567>>>>>>>
10567>>>>>>>
10567>>>>>>>
10567>>>>>>>
10567>>>>>>>// This class acts as a container for the
10567>>>>>>>// timer manager object. This is needed because
10567>>>>>>>// A DFTimerManager object created directly at the
10567>>>>>>>// desktop doesn't have a Window_Handle which we
10567>>>>>>>// need to create a Windoows timer. By placing
10567>>>>>>>// this non-visual container around the timer
10567>>>>>>>// manager, it does get a Window_Handle.
10567>>>>>>>// The procedure End_Construct_Object has been
10567>>>>>>>// augmented to create a window and also
10567>>>>>>>// automatically page all children, which will
10567>>>>>>>// be the timer manager.
10567>>>>>>>//
10567>>>>>>>Class DFTimerManagerPanel is a dfBasePanel
10568>>>>>>>    
10568>>>>>>>    Procedure Construct_Object
10570>>>>>>>        Forward Send Construct_Object
10572>>>>>>>        Set Visible_State to False
10573>>>>>>>        Object DFTimerManager is a DFTimerManager
10575>>>>>>>        End_Object
10576>>>>>>>    End_Procedure
10577>>>>>>>    
10577>>>>>>>    Procedure End_Construct_Object
10579>>>>>>>        Forward Send End_Construct_Object
10581>>>>>>>        Send Page_Object True
10582>>>>>>>        Broadcast Send Page_Object True
10584>>>>>>>    End_Procedure
10585>>>>>>>    
10585>>>>>>>End_Class
10586>>>>>>>
10586>>>>>>>// This is the class the user uses to create DFTimer objects
10586>>>>>>>
10586>>>>>>>
10586>>>>>>>//{ OverrideProperty=Skip_State DesignTime=False }
10586>>>>>>>//{ OverrideProperty=TypeFace DesignTime=False }
10586>>>>>>>Class DFTimer is a Textbox
10587>>>>>>>    
10587>>>>>>>    Procedure Construct_Object
10589>>>>>>>        Forward Send Construct_Object
10591>>>>>>>        
10591>>>>>>>        // Make sure this object never appears
10591>>>>>>>        Set Visible_State to False
10592>>>>>>>        
10592>>>>>>>        Property Integer Private.Timeout    1000
10593>>>>>>>        
10593>>>>>>>        Property Integer Timer_Message      0
10594>>>>>>>        Property Integer Timer_Object       0
10595>>>>>>>        Property Integer Auto_Start_State   True
10596>>>>>>>        Property Integer Auto_Stop_State    True
10597>>>>>>>    End_Procedure
10598>>>>>>>    
10598>>>>>>>    Procedure Set Timer_Active_State Integer iState
10600>>>>>>>        Integer iObj
10600>>>>>>>        Move Self to iObj
10601>>>>>>>        If giTimerManager ;            Set Timer_Active_State of giTimerManager iObj to iState
10604>>>>>>>    End_Procedure
10605>>>>>>>    
10605>>>>>>>    Function Timer_Active_State Returns Integer
10607>>>>>>>        Integer iState
10607>>>>>>>        Integer iObj
10607>>>>>>>        Move Self to iObj
10608>>>>>>>        If giTimerManager ;            Get Timer_Active_State of giTimerManager iObj to iState
10611>>>>>>>        Function_Return iState
10612>>>>>>>    End_Function
10613>>>>>>>    
10613>>>>>>>    Procedure Set Timeout Integer iTimeout
10615>>>>>>>        Integer iActive
10615>>>>>>>        Set Private.Timeout to iTimeout
10616>>>>>>>        Get Timer_Active_State to iActive
10617>>>>>>>        If iActive ;            Set Timer_Active_State to True
10620>>>>>>>    End_Procedure
10621>>>>>>>    
10621>>>>>>>    Function Timeout Returns Integer
10623>>>>>>>        Integer iTimeout
10623>>>>>>>        Get Private.Timeout to iTimeout
10624>>>>>>>        Function_Return iTimeout
10625>>>>>>>    End_Function
10626>>>>>>>    
10626>>>>>>>    Procedure OnTimer Integer iwParam Integer ilParam
10628>>>>>>>        Integer iMsg
10628>>>>>>>        Integer iObj
10628>>>>>>>        Get Timer_Message to iMsg
10629>>>>>>>        If (iMsg) Begin
10631>>>>>>>            Get Timer_Object  to iObj
10632>>>>>>>            If iObj ;                Send iMsg to iObj iwParam ilParam
10635>>>>>>>            Else ;                Send iMsg iwParam ilParam
10637>>>>>>>        End
10637>>>>>>>>
10637>>>>>>>    End_Procedure
10638>>>>>>>    
10638>>>>>>>    // Augmented to Auto_Start a timer
10638>>>>>>>    //
10638>>>>>>>    Procedure Page_Object Integer iState
10640>>>>>>>        Forward Send Page_Object iState
10642>>>>>>>        If (iState and Auto_Start_State(Self)) ;            Set Timer_Active_State to True
10645>>>>>>>    End_Procedure
10646>>>>>>>    
10646>>>>>>>    // Augmented to Auto_Stop a timer
10646>>>>>>>    //
10646>>>>>>>    Procedure Page_Delete
10648>>>>>>>        If (Auto_Stop_State(Self)) ;            Set Timer_Active_State to False
10651>>>>>>>        Forward Send Page_Delete
10653>>>>>>>    End_Procedure
10654>>>>>>>    
10654>>>>>>>    // Augmented to stop the timer
10654>>>>>>>    //
10654>>>>>>>    Procedure Destroy_Object
10656>>>>>>>        Set Timer_Active_State to False
10657>>>>>>>        Forward Send Destroy_Object
10659>>>>>>>    End_Procedure
10660>>>>>>>    
10660>>>>>>>End_Class
10661>>>>>>>
10661>>>>>>>//
10661>>>>>>>// This was moved into a method so it can be reliable created
10661>>>>>>>// at the desktop. Note that cDesktop adds method to cDesktop class (class of desktop)
10661>>>>>>>//
10661>>>>>>>Procedure CreateDfTimerManagerPanel for cDesktop
10663>>>>>>>    // Create the Desktop Timer Manager Object.
10663>>>>>>>    Object DFTimerManagerPanel is a DFTimerManagerPanel
10665>>>>>>>    End_Object
10666>>>>>>>End_Procedure
10667>>>>>>>
10667>>>>>>>Send CreateDfTimerManagerPanel of DESKTOP
10668>>>>>
10668>>>>>Class cTimer is a cObject
10669>>>>>    
10669>>>>>    Procedure Construct_Object
10671>>>>>        Forward Send Construct_Object
10673>>>>>        Property Integer piPrivate_Timeout 1000
10674>>>>>    End_Procedure
10675>>>>>    
10675>>>>>    Procedure Set pbEnabled Boolean bEnabled
10677>>>>>        If giTimerManager Begin
10679>>>>>            Set Timer_Active_State of giTimerManager Self to bEnabled
10680>>>>>        End
10680>>>>>>
10680>>>>>    End_Procedure
10681>>>>>    
10681>>>>>    Function pbEnabled Returns Boolean
10683>>>>>        Boolean bEnabled
10683>>>>>        If giTimerManager Begin
10685>>>>>            Get Timer_Active_State of giTimerManager Self to bEnabled
10686>>>>>        End
10686>>>>>>
10686>>>>>        Function_Return bEnabled
10687>>>>>    End_Function
10688>>>>>    
10688>>>>>    Procedure Set piTimeout Integer iTimeout
10690>>>>>        Boolean bEnabled
10690>>>>>        Set piPrivate_Timeout to iTimeout
10691>>>>>        Get pbEnabled to bEnabled
10692>>>>>        If bEnabled Begin
10694>>>>>            Set pbEnabled to True
10695>>>>>        End
10695>>>>>>
10695>>>>>    End_Procedure
10696>>>>>    
10696>>>>>    Function piTimeout Returns Integer
10698>>>>>        Integer iTimeout
10698>>>>>        Get piPrivate_Timeout to iTimeout
10699>>>>>        Function_Return iTimeout
10700>>>>>    End_Function
10701>>>>>    
10701>>>>>    Procedure OnTimer
10703>>>>>    End_Procedure
10704>>>>>    
10704>>>>>    // this is needed by the timer manager
10704>>>>>    Function Timeout Returns Integer
10706>>>>>        Integer iTimeout
10706>>>>>        Get piPrivate_Timeout to iTimeout
10707>>>>>        Function_Return iTimeout
10708>>>>>    End_Function
10709>>>>>    
10709>>>>>    Procedure Destroy_Object
10711>>>>>        Set pbEnabled to False
10712>>>>>        Forward Send Destroy_Object
10714>>>>>    End_Procedure
10715>>>>>    
10715>>>>>End_Class
10716>>>Use Winkern.pkg
10716>>>
10716>>>Use ThriftlyCommands.pkg
Including file: ThriftlyCommands.pkg    (C:\Users\marce\OneDrive\Documentos\Thriftly Developer\Dataflex\Library_x64\AppSrc\ThriftlyCommands.pkg)
10716>>>>>
10716>>>>>//=========================================================================================================================================================================================================
10716>>>>>//*********************************************************************************************************************************************************************************************************
10716>>>>>// This is the custom Object command for VDF 17.1 and greater
10716>>>>>//*********************************************************************************************************************************************************************************************************
10716>>>>>//=========================================================================================================================================================================================================
10716>>>>>
10716>>>>>
10716>>>>>
10716>>>>>
10716>>>>>//=========================================================================================================================================================================================================
10716>>>>>//*********************************************************************************************************************************************************************************************************
10716>>>>>// This is the custom message command for VDF 15-19
10716>>>>>//*********************************************************************************************************************************************************************************************************
10716>>>>>//=========================================================================================================================================================================================================
10716>>>>>
10716>>>>>
10716>>>Use cThriftlyDoc.pkg
Including file: cThriftlyDoc.pkg    (C:\Users\marce\OneDrive\Documentos\Thriftly Developer\Dataflex\Library_x64\AppSrc\cThriftlyDoc.pkg)
10716>>>>>//Thriftly documentation. 
10716>>>>>
10716>>>>>Struct tDocumentCommand
10716>>>>>    String sType 
10716>>>>>    String sDesc
10716>>>>>    String sElementName
10716>>>>>End_Struct
10716>>>>>
10716>>>>>Object oThriftlyDocumentation is a cObject
10718>>>>>    Property Boolean pisError
10720>>>>>    
10720>>>>>    Procedure Error_Report Integer iErrNum Integer iErrLine String sErrText
10723>>>>>        Set pisError to (True) 
10724>>>>>    End_Procedure
10725>>>>>    
10725>>>>>    Function ImageNumber String sImage Returns Integer 
10728>>>>>        Integer hErrObj
10728>>>>>        Integer iReturn 
10728>>>>>
10728>>>>>        Move Error_Object_Id to  hErrObj
10729>>>>>        Move (Self) to Error_Object_Id 
10730>>>>>        Set pisError to False 
10731>>>>>        Move (Eval(sImage+".N")) to iReturn 
10732>>>>>        If (pisError(Self)) Move -1 to iReturn 
10735>>>>>        Move hErrObj to Error_Object_Id 
10736>>>>>        
10736>>>>>        Function_Return iReturn 
10737>>>>>    End_Function
10738>>>>>
10738>>>>>    Function ImageDataAsArray Integer iImageNo Returns String[]
10741>>>>>        String[] aLines 
10742>>>>>        String sReturn 
10742>>>>>        Integer iCh 
10742>>>>>        String sLine 
10742>>>>>        
10742>>>>>        Move (Seq_New_Channel()) to iCh 
10743>>>>>        Direct_Input channel iCh ("image:"+String(iImageNo))
10745>>>>>        While (not(SeqEof))   
10749>>>>>            Readln sLine 
10750>>>>>            If (not(SeqEof)) Move sLine to aLines[SizeOfArray(aLines)]
10753>>>>>        Loop 
10754>>>>>>
10754>>>>>        Close_Input iCh 
10755>>>>>        Send Seq_Release_Channel iCh 
10756>>>>>        
10756>>>>>        Function_Return aLines  
10757>>>>>    End_Function
10758>>>>>    
10758>>>>>    Function ImageToLines String sImageName Returns String[]
10761>>>>>        String[] aLines 
10762>>>>>        Integer iImage 
10762>>>>>        Get ImageNumber sImageName to iImage
10763>>>>>        If (iImage>0) Get ImageDataAsArray iImage to aLines
10766>>>>>        
10766>>>>>        Function_Return aLines 
10767>>>>>    End_Function
10768>>>>>
10768>>>>>    Function ImageText String sObject String sMethod Returns String[]
10771>>>>>        String[] aLines 
10772>>>>>        String sImageName
10772>>>>>        Integer iImage
10772>>>>>        
10772>>>>>        Move (lowercase(sMethod)) to sMethod 
10773>>>>>        If ((Pos("get_",sMethod))=1) Move (Mid(sMethod,(Length(sMethod)),5)) to sMethod 
10776>>>>>        If ((Pos("msg_",sMethod))=1) Move (Mid(sMethod,(Length(sMethod)),5)) to sMethod 
10779>>>>>        
10779>>>>>        Move (sObject+"."+sMethod) to sImageName 
10780>>>>>        Move (ImageToLines(Self,sImageName)) to aLines 
10781>>>>>
10781>>>>>        Function_Return aLines 
10782>>>>>    End_Function
10783>>>>>    
10783>>>>>    Function RemoveInitialChars String sInp Integer iIndent Returns String 
10786>>>>>        Integer iStartPos 
10786>>>>>        Function_Return (Mid(sInp,(Length(sInp)),iIndent))
10787>>>>>        //Function_Return sInp 
10787>>>>>    End_Function
10788>>>>>    
10788>>>>>    Function hasNameParameter String sName Returns Boolean 
10791>>>>>        Move (Lowercase(sName)) to sName 
10792>>>>>        If (sName="param") Function_Return True 
10795>>>>>        Else Function_Return False 
10797>>>>>    End_Function
10798>>>>>    
10798>>>>>    Function LineStartPos String sInp Returns Integer 
10801>>>>>        Char[] myCharArray
10802>>>>>        Address pStr
10802>>>>>        Integer iMax
10802>>>>>        Integer iPos 
10802>>>>>        String sSkipNext
10802>>>>>        
10802>>>>>        If ((Pos("//",sInp))=0) Function_Return 0 
10805>>>>>        
10805>>>>>        Move (Replace("//",sInp,"  ")) to sInp 
10806>>>>>        Move (Length(sInp)) to iMax
10807>>>>>        Move (ResizeArray(myCharArray,iMax+1)) to myCharArray
10808>>>>>        Move (AddressOf(myCharArray)) to pStr
10809>>>>>        Move (AddressOf(sInp)) to pStr        
10810>>>>>        
10810>>>>>        For iPos from 0 to (iMax-1) 
10816>>>>>>
10816>>>>>            If (myCharArray[iPos]<>32) Function_Return (iPos+1)
10819>>>>>        Loop
10820>>>>>>
10820>>>>>        
10820>>>>>        Function_Return 0 
10821>>>>>    End_Function
10822>>>>>    
10822>>>>>    Function StripIndentPoint String[] aLines Returns Integer 
10825>>>>>        Integer iPos 
10825>>>>>        Integer iMax 
10825>>>>>        Integer iStartPos
10825>>>>>        Integer iTest 
10825>>>>>        
10825>>>>>        Move 0 to iStartPos 
10826>>>>>        Move (SizeOfArray(aLines)) to iMax
10827>>>>>        For iPos from 0 to (iMax-1)
10833>>>>>>
10833>>>>>            Move (LineStartPos(Self,aLines[iPos])) to iTest
10834>>>>>            If (iTest<>0) Begin
10836>>>>>                If ((iTest<iStartPos) or (iStartPos=0)) Move iTest to iStartPos
10839>>>>>            End 
10839>>>>>>
10839>>>>>        Loop
10840>>>>>>
10840>>>>>        
10840>>>>>        Function_Return iStartPos 
10841>>>>>    End_Function
10842>>>>>    
10842>>>>>    Function isNewCommand String sTest Returns Boolean 
10845>>>>>        Move (Trim(sTest)) to sTest 
10846>>>>>        Function_Return ((pos("@",sTest))<>0)
10847>>>>>    End_Function
10848>>>>>    
10848>>>>>    Enum_List 
10848>>>>>        Define C_Starting
10848>>>>>        Define C_command
10848>>>>>        Define C_Before_Param
10848>>>>>        Define C_Param
10848>>>>>        Define C_before_detail
10848>>>>>        Define C_detail  
10848>>>>>    End_Enum_List
10848>>>>>    
10848>>>>>    Function HasTitle String sType Returns Boolean 
10851>>>>>             If (sType="param")   Function_Return True 
10854>>>>>        Else If (sType="element") Function_Return True 
10858>>>>>        Else If (sType="error")   Function_Return True 
10862>>>>>        Else                      Function_Return False 
10864>>>>>    End_Function
10865>>>>>    
10865>>>>>    Function CreateCommand String sLine tDocumentCommand TempCommand Returns tDocumentCommand
10868>>>>>        Char[] myCharArray
10869>>>>>        Address pStr
10869>>>>>        Integer iMax 
10869>>>>>        Integer iPos 
10869>>>>>        String sChar 
10869>>>>>        Integer iParsing 
10869>>>>>        
10869>>>>>        If (not(isNewCommand(Self,sLine))) Begin 
10871>>>>>            Move sLine to TempCommand.sDesc
10872>>>>>            If (TempCommand.sType="") Move "detail" to TempCommand.sType
10875>>>>>            Function_Return TempCommand
10876>>>>>        End
10876>>>>>>
10876>>>>>        
10876>>>>>        Move C_Starting to iParsing 
10877>>>>>        Move (Length(sLine)) to iMax
10878>>>>>        Move (ResizeArray(myCharArray,iMax+1)) to myCharArray
10879>>>>>        Move (AddressOf(myCharArray)) to pStr
10880>>>>>        Move (AddressOf(sLine)) to pStr        
10881>>>>>        
10881>>>>>        For iPos from 0 to (iMax-1) 
10887>>>>>>
10887>>>>>            Move (Character(myCharArray[iPos])) to sChar
10888>>>>>            If (iParsing=C_Starting) Begin
10890>>>>>                Move "" to TempCommand.sElementName 
10891>>>>>                If (sChar="@") Begin 
10893>>>>>                    Move "" to TempCommand.sType
10894>>>>>                    Move C_command to iParsing 
10895>>>>>                End
10895>>>>>>
10895>>>>>                Else If (sChar<>" ") Begin 
10898>>>>>                    Move sChar to TempCommand.sType 
10899>>>>>                    Move C_command to iParsing 
10900>>>>>                End
10900>>>>>>
10900>>>>>            End
10900>>>>>>
10900>>>>>            Else If (iParsing=C_Command) Begin 
10903>>>>>                If (sChar<>" ") Append TempCommand.sType sChar 
10906>>>>>                Else Begin 
10907>>>>>                    Move (Lowercase(TempCommand.sType)) to TempCommand.sType
10908>>>>>                    Move "" to TempCommand.sElementName
10909>>>>>                    If (HasTitle(Self,TempCommand.sType)) Move C_Before_Param to iParsing 
10912>>>>>                    Else Move C_before_detail to iParsing 
10914>>>>>                End
10914>>>>>>
10914>>>>>            End
10914>>>>>>
10914>>>>>            Else If (iParsing=C_Before_Param) Begin 
10917>>>>>                If ((pos(sChar," -.:=")) = 0) Begin 
10919>>>>>                    Move C_Param to iParsing 
10920>>>>>                    Move sChar to TempCommand.sElementName
10921>>>>>                End
10921>>>>>>
10921>>>>>            End
10921>>>>>>
10921>>>>>            Else If (iParsing=C_Param) Begin 
10924>>>>>                If ((pos(sChar," -.:=")) <> 0) Begin 
10926>>>>>                    Move C_Before_Detail to iParsing
10927>>>>>                End
10927>>>>>>
10927>>>>>                Else Begin 
10928>>>>>                    Append TempCommand.sElementName sChar 
10929>>>>>                End
10929>>>>>>
10929>>>>>            End
10929>>>>>>
10929>>>>>            Else If (iParsing=C_Before_Detail) Begin 
10932>>>>>                If ((pos(sChar," -.:=")) = 0) Begin 
10934>>>>>                    Move C_Detail to iParsing 
10935>>>>>                    Move sChar to TempCommand.sDesc
10936>>>>>                End
10936>>>>>>
10936>>>>>            End
10936>>>>>>
10936>>>>>            Else If (iParsing=C_Detail) Begin 
10939>>>>>                Move (TempCommand.sDesc+sChar) to TempCommand.sDesc
10940>>>>>            End
10940>>>>>>
10940>>>>>        Loop
10941>>>>>>
10941>>>>>        
10941>>>>>        Function_Return TempCommand
10942>>>>>    End_Function
10943>>>>>    
10943>>>>>    Function FindDocumentCommand tDocumentCommand cmd1 tDocumentCommand cmd2 Returns Integer 
10946>>>>>        If (cmd1.sType > cmd2.sType) Function_Return (GT)
10949>>>>>        If (cmd1.sType < cmd2.sType) Function_Return (LT)
10952>>>>>
10952>>>>>        If (cmd1.sElementName > cmd2.sElementName) Function_Return (GT)
10955>>>>>        If (cmd1.sElementName < cmd2.sElementName) Function_Return (LT)
10958>>>>>        
10958>>>>>        Function_Return (EQ) 
10959>>>>>    End_Function
10960>>>>>    
10960>>>>>    //todo - this function could do with being a bit easier to read.
10960>>>>>    Function ParseImage String[] aLines Returns tDocumentCommand[]
10963>>>>>        Integer iCharStartPos
10963>>>>>        Integer iMax 
10963>>>>>        Integer iPos 
10963>>>>>        Integer iCommand 
10963>>>>>        tDocumentCommand[] aCommands
10963>>>>>        tDocumentCommand[] aCommands
10964>>>>>        tDocumentCommand tmpCommand 
10964>>>>>        tDocumentCommand tmpCommand 
10964>>>>>        String sLine 
10964>>>>>        String sCRLF 
10964>>>>>        String sTmp
10964>>>>>                
10964>>>>>        Move ((Character(13))+(character(10))) to sCRLF
10965>>>>>        Move (StripIndentPoint(Self,aLines)) to iCharStartPos 
10966>>>>>
10966>>>>>        Move "detail" to tmpCommand.sType
10967>>>>>
10967>>>>>        Move (SizeOfArray(aLines)) to iMax
10968>>>>>        For iPos from 0 to (iMax-1)
10974>>>>>>
10974>>>>>            Move aLines[iPos] to sLine 
10975>>>>>            If ((Trim(sLine))="") Move "" to sLine 
10978>>>>>            If ((Pos("//",sLine))<>0) Move (Mid(sLine,(length(sLine)),iCharStartPos)) to sLine
10981>>>>>            
10981>>>>>            Move (CreateCommand(Self,sLine,tmpCommand)) to tmpCommand 
10982>>>>>            Move (SearchArray(tmpCommand,aCommands,Self,get_FindDocumentCommand)) to iCommand 
10983>>>>>            
10983>>>>>            If (iCommand=-1) Move tmpCommand to aCommands[SizeOfArray(aCommands)]
10986>>>>>            Else Begin 
10987>>>>>                //Command line without description does not add blank line to text block 
10987>>>>>                If ((sLine="") or (tmpCommand.sDesc<>"")) Begin 
10989>>>>>                    Move aCommands[iCommand].sDesc to sTmp 
10990>>>>>                    If (sTmp<>"") Append sTmp sCRLF 
10993>>>>>                    Append sTmp tmpCommand.sDesc
10994>>>>>                    Move sTmp to aCommands[iCommand].sDesc
10995>>>>>                End
10995>>>>>>
10995>>>>>            End
10995>>>>>>
10995>>>>>        Loop
10996>>>>>>
10996>>>>>        
10996>>>>>        Function_Return aCommands
10997>>>>>    End_Function
10998>>>>>    
10998>>>>>    Function isSearchOK String sTest String sInp Returns Boolean 
11001>>>>>        If (sTest="") Function_Return (True)
11004>>>>>        
11004>>>>>        Move (Lowercase(sInp)) to sInp 
11005>>>>>        Move (Lowercase(sTest)) to sTest
11006>>>>>        If (Pos(sInp,sTest)) Function_Return (True)  
11009>>>>>        
11009>>>>>        Function_Return (False) 
11010>>>>>    End_Function
11011>>>>>    
11011>>>>>    Function stripCodes tDocumentCommand[] aCommands String sType String sElement Returns tDocumentCommand[] 
11014>>>>>        tDocumentCommand[] aReturn 
11014>>>>>        tDocumentCommand[] aReturn 
11015>>>>>        Integer iMax
11015>>>>>        Integer iPos 
11015>>>>>        Boolean isLineOK 
11015>>>>>        
11015>>>>>        Move (SizeOfArray(aCommands)) to iMax 
11016>>>>>        For iPos from 0 to (iMax-1)
11022>>>>>>
11022>>>>>            Move (True) to isLineOK 
11023>>>>>            If (not(isSearchOK(Self,sType,aCommands[iPos].sType))) Move (False) to isLineOK
11026>>>>>            If (not(isSearchOK(Self,sElement,aCommands[iPos].sElementName))) Move (False) to isLineOK
11029>>>>>            If (isLineOK) Move aCommands[iPos] to aReturn[SizeOfArray(aReturn)]
11032>>>>>        Loop
11033>>>>>>
11033>>>>>        
11033>>>>>        Function_Return aReturn 
11034>>>>>    End_Function
11035>>>>>    
11035>>>>>    Function GenericDetail String sObject String sMethod String sType String sElement Returns String 
11038>>>>>        String[] aLines 
11039>>>>>        tDocumentCommand[] aCommands 
11039>>>>>        tDocumentCommand[] aCommands 
11040>>>>>        Integer iPos 
11040>>>>>        Integer iMax 
11040>>>>>        String sReturn 
11040>>>>>        String sCRLF 
11040>>>>>        
11040>>>>>        Move ((Character(10))+(Character(13))) to sCRLF 
11041>>>>>        
11041>>>>>        Get ImageText sObject sMethod to aLines 
11042>>>>>        Move (ParseImage(Self,aLines)) to aCommands 
11043>>>>>        Move (stripCodes(Self,aCommands,sType,sElement)) to aCommands
11044>>>>>        
11044>>>>>        Move (SizeOfArray(aCommands)) to iMax 
11045>>>>>        For iPos from 0 to (iMax-1) 
11051>>>>>>
11051>>>>>            If (sReturn<>"") Append sReturn sCRLF
11054>>>>>            Append sReturn aCommands[iPos].sDesc
11055>>>>>        Loop
11056>>>>>>
11056>>>>>        
11056>>>>>        Function_Return sReturn 
11057>>>>>    End_Function
11058>>>>>
11058>>>>>    Function MethodDescription String sObject String sMethod Returns String 
11061>>>>>        String sReturn 
11061>>>>>        Get GenericDetail sObject sMethod "detail" "" to sReturn 
11062>>>>>        Function_Return sReturn 
11063>>>>>    End_Function
11064>>>>>
11064>>>>>    Function ParameterDescription String sObject String sMethod String sParameter Returns String
11067>>>>>        String sReturn 
11067>>>>>        Get GenericDetail sObject sMethod "param" sParameter to sReturn
11068>>>>>        
11068>>>>>        Function_Return sReturn 
11069>>>>>    End_Function  
11070>>>>>    
11070>>>>>    Function ReturnDescription String sObject String sMethod Returns String
11073>>>>>        String sReturn 
11073>>>>>        Get GenericDetail sObject sMethod "returns" "" to sReturn
11074>>>>>        
11074>>>>>        Function_Return sReturn 
11075>>>>>    End_Function  
11076>>>>>    
11076>>>>>    Function ErrorDescription String sObject String sMethod String sError Returns String
11079>>>>>        String sReturn 
11079>>>>>        Get GenericDetail sObject sMethod "errors" sError to sReturn
11080>>>>>        
11080>>>>>        Function_Return sReturn 
11081>>>>>    End_Function  
11082>>>>>    
11082>>>>>    Function StructDescription String sStruct Returns String
11085>>>>>        String sReturn 
11085>>>>>        Get GenericDetail "struct" sStruct "" "" to sReturn
11086>>>>>        
11086>>>>>        Function_Return sReturn 
11087>>>>>    End_Function  
11088>>>>>    
11088>>>>>    Function StructElementDescription String sStruct String sElement Returns String
11091>>>>>        String sReturn 
11091>>>>>        Get GenericDetail "struct" sStruct "element" sElement to sReturn
11092>>>>>        
11092>>>>>        Function_Return sReturn 
11093>>>>>    End_Function 
11094>>>>>End_Object
11095>>>
11095>>>// So Dataflex has this long standing "feature" where strings in a table are
11095>>>// always padded to the length of the field. This is a pain when developing
11095>>>// APIs because using the file buffer is a bit easier to code than using the
11095>>>// DD buffer. So we provide a custom version of the move command that right 
11095>>>// trim's the first parameter if it's a string.
11095>>>
11095>>>Struct ServiceErrorType
11095>>>    String serviceName
11095>>>    String customErrorStructName
11095>>>    Variant errorStruct
11095>>>End_Struct
11095>>>
11095>>>// This global is unfortunate but needed so that when errors are generated
11095>>>// we know which Evolution runtime to send details to.
11095>>>Global_Variable Integer EVO_CURRENT_SERVICE
11095>>>
11095>>>Use cThriftlyErrorSystem.pkg
Including file: cThriftlyErrorSystem.pkg    (C:\Users\marce\OneDrive\Documentos\Thriftly Developer\Dataflex\Library_x64\AppSrc\cThriftlyErrorSystem.pkg)
11095>>>>>Use UI
11095>>>>>Use Dferror.pkg
11095>>>>>
11095>>>>>Struct ErrorData
11095>>>>>    Boolean  Unhandled
11095>>>>>    Integer  ErrorNumber
11095>>>>>    Integer  LineNumber
11095>>>>>    Boolean  IsCritical
11095>>>>>    String   Value
11095>>>>>    String   Description
11095>>>>>    String   Caption
11095>>>>>    String[] CallStack
11095>>>>>End_Struct
11095>>>>>
11095>>>>>Define C_CRLF for (Character(13)+Character(10))
11095>>>>>
11095>>>>>Class cThriftlyErrorSystem is an ErrorSystem    
11096>>>>>    Procedure Construct_Object
11098>>>>>        Property Handle phoEvoRuntime
11099>>>>>        Property Boolean pbErrorsIncludeStackTrace True
11100>>>>>        Property Integer Error_Processing_State False
11101>>>>>        Forward Send Construct_Object
11103>>>>>    End_Procedure
11104>>>>>
11104>>>>>    Procedure End_Construct_Object
11106>>>>>        Forward Send End_Construct_Object
11108>>>>>        
11108>>>>>        Send RemoveAllUserErrors // we want everything to run through our handlers
11109>>>>>    End_Procedure
11110>>>>>
11110>>>>>    Function StringToArray String sSrc String sDelim Returns String[]
11112>>>>>        Integer iPos iCtr
11112>>>>>        String[] sData
11113>>>>>        Repeat
11113>>>>>>
11113>>>>>            Move (Pos(sDelim,sSrc)) to iPos
11114>>>>>            If (iPos > 0) Begin
11116>>>>>                Move (Left(sSrc,(iPos-1))) to sData[iCtr]
11117>>>>>                Move (Replace(sData[iCtr],sSrc,'')) to sSrc
11118>>>>>                Move (Replace(sDelim,sSrc,'')) to sSrc
11119>>>>>                Increment iCtr
11120>>>>>            End
11120>>>>>>
11120>>>>>            Else Break
11122>>>>>        Loop
11123>>>>>>
11123>>>>>        If (Length(sSrc) > 0) Begin
11125>>>>>          Move sSrc to sData[iCtr]
11126>>>>>        End
11126>>>>>>
11126>>>>>        Function_Return sData
11127>>>>>    End_Function
11128>>>>>  
11128>>>>>    Procedure Error_Report Integer ErrNum Integer Err_Line String ErrMsg
11130>>>>>        Integer iReply iIcon
11130>>>>>        String  sErrorText sMess sCallStack
11130>>>>>        String[] callstack
11131>>>>>        String  sSource sCaption
11131>>>>>        Integer iSrcPos iSrc iTxtLen
11131>>>>>        Handle hoRuntime
11131>>>>>        Variant vRuntime
11131>>>>>        Variant vErrInfo
11131>>>>>        Boolean bIsUnhandled bUnhandledSupport bCritical bVerbose
11131>>>>>        ErrorData errinfo
11131>>>>>        ErrorData errinfo
11131>>>>>        
11131>>>>>        If (Error_processing_State(Self)) Begin // don't allow error
11133>>>>>            Procedure_Return                     // recursion
11134>>>>>        End
11134>>>>>>
11134>>>>>        
11134>>>>>        Set Error_Processing_State to True // we are now in an error reporting state
11135>>>>>        Get Is_Critical errnum to bCritical
11136>>>>>
11136>>>>>        Get ComRuntime of EVO_CURRENT_SERVICE to vRuntime
11137>>>>>        Get Create U_cComIEvoRuntime to hoRuntime
11138>>>>>        Set pvComObject of hoRuntime to vRuntime
11139>>>>>
11139>>>>>        Move True to errinfo.Unhandled
11140>>>>>        Move ErrNum to errinfo.ErrorNumber
11141>>>>>        Move Err_Line to errinfo.LineNumber
11142>>>>>        Move bCritical to errinfo.IsCritical
11143>>>>>
11143>>>>>        If (pbErrorsIncludeStackTrace(Self)) Begin
11145>>>>>            CallStackDump sCallStack
11146>>>>>            
11146>>>>>            Get StringToArray sCallStack C_CRLF to callstack
11147>>>>>            // This function ends up in the call stack, which is stupid and deceptive, so remove it if it's present.
11147>>>>>            // Unfortunately it's not ALWAYS present, so you can't just always remove the first time.
11147>>>>>            If (Left(callstack[0], 16) = "MSG_ERROR_REPORT") ;                Move (RemoveFromArray(callstack, 0)) to callstack
11150>>>>>            
11150>>>>>            Move callstack to errinfo.CallStack
11151>>>>>        End
11151>>>>>>
11151>>>>>            
11151>>>>>        If not ( isTrapped( TrappedErrors( Self ), ErrNum ) ) Begin
11153>>>>>            // if trapped do nothing
11153>>>>>            
11153>>>>>            // We used to forward send. Since this is based on array, it does not understand this message, the forward was
11153>>>>>            // not understood. Since arrays don't delegate or error, nothing happened.
11153>>>>>            // An easier way to do nothing, is to do nothing, hence this line is removed
11153>>>>>            //forward send Error_Report ErrNum Err_Line ErrMsg
11153>>>>>            
11153>>>>>            Set pvComObject of hoRuntime to (NullComObject())
11154>>>>>            Send Destroy_Object of hoRuntime
11155>>>>>        End
11155>>>>>>
11155>>>>>        Else Begin
11156>>>>>            // See if source information is provided (Source = module.function). If so remove
11156>>>>>            // as detail. Must find last instance of this in string
11156>>>>>            Move (pos(C_ErrorContextSourceText,ErrMsg)) to iSrc
11157>>>>>            If iSrc Begin
11159>>>>>                Move (iSrc-1) to iSrcPos
11160>>>>>                Move (length(C_ErrorContextSourceText)) to  iTxtLen
11161>>>>>                Move ErrMsg to sSource
11162>>>>>                Repeat // this makes sure we find last instance of this
11162>>>>>>
11162>>>>>                    Move (remove(sSource, 1, iSrc-1 + iTxtLen )) to sSource // right part of string
11163>>>>>                    Move (pos(C_ErrorContextSourceText,sSource)) to iSrc           // see if it was the last
11164>>>>>                    If iSrc ;                                               // if not, track length                       Move (iSrcPos + iTxtLen + iSrc-1) to iSrcPos
11167>>>>>                Until (iSrc=0)
11169>>>>>                Move (trim(left(ErrMsg,iSrcPos))) to ErrMsg
11170>>>>>                If (right(ErrMsg,1)=',') ;                   Move (left(ErrMsg,length(ErrMsg)-1)) to ErrMsg
11173>>>>>            End
11173>>>>>>
11173>>>>>            
11173>>>>>            // the caption normally used for handled user errors
11173>>>>>            Move "" to sCaption
11174>>>>>            // if an operator error this may be a Procedure UserError situation where the
11174>>>>>            // caption is passed in the error text. If so, get the caption
11174>>>>>            If (ErrNum=DFERR_OPERATOR) Begin
11176>>>>>             Move (pos(C_ErrorCaption,ErrMsg)) to iSrc
11177>>>>>             If iSrc Begin
11179>>>>>                Move (length(C_ErrorCaption)) to  iTxtLen
11180>>>>>                Move (remove(ErrMsg, 1, iSrc-1 + iTxtLen )) to sCaption
11181>>>>>                Move (Left(ErrMsg,iSrc-1)) to ErrMsg
11182>>>>>             End
11182>>>>>>
11182>>>>>            End
11182>>>>>>
11182>>>>>
11182>>>>>            Move ErrMsg to errinfo.Value
11183>>>>>            Move sCaption to errinfo.Caption
11184>>>>>            
11184>>>>>            Get Error_Description ErrNum ErrMsg to sErrorText
11185>>>>>            
11185>>>>>            // if the error source is identified we can get extended error
11185>>>>>            // text for our error message
11185>>>>>            If ghoErrorSource Begin
11187>>>>>                Get extended_error_Message of ghoErrorSource to sMess
11188>>>>>                If sMess ne '' ;                   Move (sErrorText + "\n\n" + sMess ) to sErrorText
11191>>>>>            End
11191>>>>>>
11191>>>>>
11191>>>>>            Move sErrorText to errinfo.Description
11192>>>>>            Send Custom_Error_Report of EVO_CURRENT_SERVICE hoRuntime errinfo
11193>>>>>
11193>>>>>            Set pvComObject of hoRuntime to (NullComObject())
11194>>>>>            Send Destroy_Object of hoRuntime
11195>>>>>            
11195>>>>>            // abort on critical errors
11195>>>>>            If bCritical Abort
11198>>>>>       End
11198>>>>>>
11198>>>>>
11198>>>>>       Move 0 to ghoErrorSource
11199>>>>>       Set Error_Processing_State to False // no longer reporting an error
11200>>>>>    End_Procedure
11201>>>>>
11201>>>>>End_Class
11202>>>
11202>>>
11202>>>
11202>>>
11202>>>Use SoapConstants.pkg
Including file: SoapConstants.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\SoapConstants.pkg)
11202>>>>>// SoapConstants.pkg
11202>>>>>// constants used by soap
11202>>>>>
11202>>>>>// DataFlex datatypes that we support in soap.
11202>>>>>// These MUST match the dataflex definitions as provided in fmac
11202>>>>>Enum_List
11202>>>>>    Define xsString    for 0
11202>>>>>    Define xsNumber    for 1
11202>>>>>    Define xsDate      for 2
11202>>>>>    Define xsInteger   for 3
11202>>>>>    Define xsBigint    for 4
11202>>>>>    Define xsReal      for 5
11202>>>>>    Define xsBoolean   for 6
11202>>>>>    Define xsTime      for 8
11202>>>>>    Define xsDatetime  for 9
11202>>>>>    Define xsFloat     for 10
11202>>>>>    Define xsChar      for 11
11202>>>>>    Define xsUchar     for 12
11202>>>>>    Define xsShort     for 13
11202>>>>>    Define xsUShort    for 14
11202>>>>>    Define xsUinteger  for 15
11202>>>>>    Define xsUbigint   for 17
11202>>>>>    Define xsCurrency  for 18
11202>>>>>    Define xsStruct    for 19
11202>>>>>    Define xsDecimal   for 22
11202>>>>>
11202>>>>>    Define xsEmpty     for  -1  // not a real datatype. Used with return types when nothing is returned. We must use -1 (the runtime message InterfaceMessageParamType returns this)
11202>>>>>    Define xsAnyType    for 127  // not a real type (represent as XML within a wrapper document)
11202>>>>>    Define xsXmlElement for 128  // not a real type (represent as an xml document. <any /> type in schema)
11202>>>>>    Define xsAnyTypeStr    for 129  // not a real type (represent as XML serialized stringwithin a wrapper document). Can be used in struct/array definitions.
11202>>>>>    Define xsXmlElementStr for 130  // not a real type (represent as an xml serialized stringdocument. <any /> type in schema). Can be used in struct/array definitions.
11202>>>>>    Define xsBase64Binary for 131 //  not a real type (represent as a base64binary serialized stringdocument. Can be used in struct/array definitions.
11202>>>>>
11202>>>>>End_Enum_List
11202>>>>>
11202>>>>>// soap style
11202>>>>>Enum_List
11202>>>>>   Define ssDocument
11202>>>>>   Define ssRPC
11202>>>>>End_Enum_List
11202>>>>>
11202>>>>>// soap encoding
11202>>>>>Enum_List
11202>>>>>   Define seLiteral
11202>>>>>   Define seEncoded
11202>>>>>End_Enum_List
11202>>>>>
11202>>>>>// service/port-types. Currently we only support soap
11202>>>>>Enum_List
11202>>>>>   Define ptUnKnown
11202>>>>>   Define ptSOAP
11202>>>>>   Define ptHttp
11202>>>>>End_Enum_List
11202>>>>>
11202>>>>>Define C_UnBounded            for -1 // used when maxOccurs=Unbounded
11202>>>>>
11202>>>>>Define svSOAP11 for 1
11202>>>>>Define svSOAP12 for 2
11202>>>>>
11202>>>>>// SOAP URI constants (SOAP1.1)
11202>>>>>Define C_WSDLURI              for "http://schemas.xmlsoap.org/wsdl/"
11202>>>>>Define C_SOAPURI              for "http://schemas.xmlsoap.org/wsdl/soap/"
11202>>>>>Define C_XMLSCHEMAURI         for "http://www.w3.org/2001/XMLSchema"
11202>>>>>Define C_XMLSCHEMAXSIURI      for "http://www.w3.org/2001/XMLSchema-instance"
11202>>>>>Define C_SOAPENVELOPEURI      for "http://schemas.xmlsoap.org/soap/envelope/"
11202>>>>>Define C_SOAPENCODINGURI      for "http://schemas.xmlsoap.org/soap/encoding/"
11202>>>>>Define C_ContentTypeSOAP      for "text/xml"
11202>>>>>Define C_SOAPHREF             for "href" // 1.1 uses href while 1.2 uses ref
11202>>>>>
11202>>>>>// SOAP1.2 constants
11202>>>>>Define C_SOAPURI12            for "http://schemas.xmlsoap.org/wsdl/soap12/"
11202>>>>>Define C_SOAPENVELOPEURI12    for "http://www.w3.org/2003/05/soap-envelope"
11202>>>>>Define C_SOAPENCODINGURI12    for "http://www.w3.org/2003/05/soap-encoding"
11202>>>>>Define C_SOAPRPC12            for "http://www.w3.org/2003/05/soap-rpc"
11202>>>>>Define C_ContentTypeSOAP12    for "application/soap+xml"
11202>>>>>Define C_SOAPHREF12 for "ref"
11202>>>>>
11202>>>>>Define C_MTOMMimeMarker for "dfMimeContent"
11202>>>>>
11202>>>
11202>>>// The SOAP Constants are missing Boolean (Bit type, not logical type)
11202>>>// So we define it ourselves (FMAC defines it "ARGBIT = 16")
11202>>>Define xsBit for 16
11202>>>
11202>>>Use Variant.pkg
11202>>>Use Flexml.pkg
Including file: Flexml.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\Flexml.pkg)
11202>>>>>Use VdfBase.pkg
11202>>>>>Use LanguageText.pkg
11202>>>>>Use GlobalFunctionsProcedures.pkg
11202>>>>>
11202>>>>>
11202>>>>>// Used to designate that a handle is a handle to an Xml Dom object. This
11202>>>>>// is used/required by server web-services but could be used elsewhere .
11202>>>>>
11202>>>>>
11202>>>>>// Types of Nodes
11202>>>>>
11202>>>>>
11202>>>>>// classes and methods defined in fmac
11202>>>>>
11202>>>>>
11202>>>>>Register_Function transformNode Handle infcXSLNode Returns String
11202>>>>>
11202>>>>>
11202>>>>>
11202>>>>>
11202>>>>>
11202>>>>>
11202>>>>>
11202>>>>>
11202>>>>>
11202>>>>>// XML function & procedure registration
11202>>>>>
11202>>>>>Register_Procedure Set XmlInterface Handle iHandle
11202>>>>>Register_Function XmlInterface Returns Handle
11202>>>>>
11202>>>>>// NODE Properties
11202>>>>>Register_Function phAttributes Returns Handle
11202>>>>>Register_Function psBaseName Returns String
11202>>>>>Register_Function phChildNodes Returns Handle
11202>>>>>Register_Function phDefinition Returns Handle
11202>>>>>Register_Function phFirstChild Returns Handle
11202>>>>>Register_Function phLastChild Returns Handle
11202>>>>>Register_Function phNextSibling Returns Handle
11202>>>>>Register_Function psNameSpaceURI Returns String
11202>>>>>Register_Function psNodeName Returns String
11202>>>>>Register_Function piNodeType Returns Integer
11202>>>>>Register_Function psNodeTypeString Returns String
11202>>>>>Register_Function phOwnerDocument Returns Handle
11202>>>>>Register_Function phParentNode Returns Handle
11202>>>>>Register_Function pbParsed Returns Integer
11202>>>>>Register_Function psPrefix Returns String
11202>>>>>Register_Function phPreviousSibling Returns Handle
11202>>>>>Register_Function pbSpecified Returns Integer
11202>>>>>Register_Function psText Returns String
11202>>>>>Register_Procedure Set psText String sText
11202>>>>>Register_Function psXML Returns String
11202>>>>>
11202>>>>>// Node Read write properties
11202>>>>>
11202>>>>>Register_Procedure Set psDataType String sTypeName
11202>>>>>Register_Function psDataType Returns String
11202>>>>>Register_Procedure Set pvNodeTypedValue Integer iType Integer iAddress
11202>>>>>Register_Function pvNodeTypedValue Integer iType Returns Integer  // address of data
11202>>>>>Register_Procedure Set psNodeValue String sValue
11202>>>>>Register_Function psNodeValue Returns String
11202>>>>>
11202>>>>>// Node Methods
11202>>>>>
11202>>>>>Register_Function AppendChild Handle iChildInfc Returns Handle
11202>>>>>Register_Function CloneInfcNode Handle bRecurse Returns Handle
11202>>>>>Register_Function HasChildNodes Returns Integer
11202>>>>>Register_Function InsertBefore Handle infcNodeToInsert Handle iWhere Returns Handle
11202>>>>>Register_Function RemoveChild Handle iChildToRemove Returns Handle
11202>>>>>Register_Function ReplaceChild Handle iNewChild Handle iChildToReplace Returns Handle
11202>>>>>Register_Function SelectNodes String selectstring Returns Handle
11202>>>>>Register_Function SelectSingleNode String selectstring Returns Handle
11202>>>>>
11202>>>>>// Node Collections
11202>>>>>// READONLY PROPERTIES
11202>>>>>
11202>>>>>Register_Function phItem Integer iItem Returns Handle
11202>>>>>Register_Function phElementItem Integer iItem Returns Handle
11202>>>>>
11202>>>>>Register_Function piLength Returns Integer
11202>>>>>
11202>>>>>Register_Function NamedItem String sName Returns Handle
11202>>>>>Register_Function QualifiedItem String sBaseName String sNameSpace Returns Handle
11202>>>>>Register_Function RemoveNamedItem String sName Returns Handle
11202>>>>>Register_Function RemoveQualifiedItem String sBaseName String sNameSpace Returns Handle
11202>>>>>Register_Function SetNamedItem Handle iInterface Returns Handle
11202>>>>>
11202>>>>>// XML DOM Document
11202>>>>>// Read only properties
11202>>>>>
11202>>>>>Register_Function phDocType Returns Handle
11202>>>>>Register_Function phImplementation Returns Handle
11202>>>>>Register_Function phParseError Returns Handle
11202>>>>>Register_Function piReadyState Returns Integer
11202>>>>>Register_Function psURL Returns String
11202>>>>>
11202>>>>>// Read Write Properties
11202>>>>>
11202>>>>>Register_Procedure Set pbAsync Integer bValue
11202>>>>>Register_Function pbAsync Returns Integer
11202>>>>>Register_Procedure Set phDocumentElement Handle iElement
11202>>>>>Register_Function phDocumentElement Returns Handle
11202>>>>>Register_Procedure Set pbPreserveWhiteSpace Integer bValue
11202>>>>>Register_Function pbPreserveWhiteSpace Returns Integer
11202>>>>>Register_Procedure Set pbResolveExternals Integer bValue
11202>>>>>Register_Function pbResolveExternals Returns Integer
11202>>>>>Register_Procedure Set pbValidateOnParse Integer bValue
11202>>>>>Register_Function pbValidateOnParse Returns Integer
11202>>>>>
11202>>>>>// Events
11202>>>>>
11202>>>>>// Methods
11202>>>>>
11202>>>>>Register_Function Abort Returns Integer
11202>>>>>Register_Function ElementsByTagName String sTagName Returns Handle
11202>>>>>Register_Function LoadDocument String sURLName Returns Integer
11202>>>>>Register_Function LoadXML String sXMLText Returns Integer
11202>>>>>Register_Function NodeFromID String sNodeName Returns Handle
11202>>>>>Register_Function SaveDocument String sURLName Returns Integer
11202>>>>>
11202>>>>>// Parse Error
11202>>>>>// Read Only Properties
11202>>>>>
11202>>>>>Register_Function piErrorCode Returns Integer
11202>>>>>Register_Function piFilePos Returns Integer
11202>>>>>Register_Function piLine Returns Integer
11202>>>>>Register_Function piLinePos Returns Integer
11202>>>>>Register_Function psReason Returns String
11202>>>>>Register_Function psSrcText Returns String
11202>>>>>Register_Function psURL Returns String
11202>>>>>
11202>>>>>// DOM Implementation
11202>>>>>// Method
11202>>>>>
11202>>>>>Register_Function HasFeature String sSystem String sFeature Returns Integer
11202>>>>>
11202>>>>>// Methods
11202>>>>>
11202>>>>>Register_Function substringData Integer iOffset Integer iCount Returns String
11202>>>>>Register_Function appendData String sData Returns Handle
11202>>>>>Register_Function insertData Integer iOffset String sData Returns Handle
11202>>>>>Register_Function deleteData Integer iOffset Integer iCount Returns Handle
11202>>>>>Register_Function replaceData Integer iOffset Integer iCount String sData Returns Handle
11202>>>>>
11202>>>>>// Attributes
11202>>>>>
11202>>>>>Register_Function psName Returns String
11202>>>>>
11202>>>>>// Elements
11202>>>>>// Read Only properties
11202>>>>>
11202>>>>>Register_Function psTagName Returns String
11202>>>>>
11202>>>>>// Methods
11202>>>>>
11202>>>>>Register_Procedure Set attributeValue String sName String sValue
11202>>>>>Register_Function attributeValue String sName Returns String
11202>>>>>Register_Function removeAttribute String sName Returns Handle
11202>>>>>Register_Function attributeNode String sName Returns Handle
11202>>>>>Register_Procedure Set attributeNode Handle iNode Returns Handle
11202>>>>>Register_Function removeAttributeNode Handle iNode Returns Handle
11202>>>>>
11202>>>>>// DOM Text
11202>>>>>// Methods
11202>>>>>
11202>>>>>Register_Function splitText Integer iOffset Returns Integer
11202>>>>>
11202>>>>>// DOM Processing Instruction
11202>>>>>// Read Only Properties
11202>>>>>Register_Function psTarget Returns String
11202>>>>>
11202>>>>>// DOM Document Type
11202>>>>>
11202>>>>>Register_Function phEntities Returns Handle
11202>>>>>Register_Function phNotations Returns Handle
11202>>>>>
11202>>>>>// DOM Notations
11202>>>>>
11202>>>>>Register_Function psPublicID Returns String
11202>>>>>Register_Function psSystemID Returns String
11202>>>>>Register_Function psNotationName Returns String
11202>>>>>
11202>>>>>// create nodes
11202>>>>>
11202>>>>>Register_Function createAttribute String sName Returns Handle
11202>>>>>Register_Function createCDataSection String sValue Returns Handle
11202>>>>>Register_Function createComment String sValue Returns Handle
11202>>>>>Register_Function createDocumentFragment Returns Handle
11202>>>>>Register_Function createElement String sTagName Returns Handle
11202>>>>>Register_Function createEntityReference String sEntityName Returns Handle
11202>>>>>Register_Function createNode Integer iNodeType String sName String sNameSpace Returns Handle
11202>>>>>Register_Function createProcessingInstruction String sTarget String sData Returns Handle
11202>>>>>Register_Function createTextNode String sData Returns Handle
11202>>>>>
11202>>>>>Register_Function ChangeNodeType Integer iTypeOfNode Integer bSetInterface Returns Handle
11202>>>>>
11202>>>>>
11202>>>>>//          Part 1:  Base Document Logic Specialized For Templates
11202>>>>>
11202>>>>>//
11202>>>>>//  XML Collections
11202>>>>>//
11202>>>>>//  Collection mixin has common functions to both node lists and named node maps
11202>>>>>//
11202>>>>>
11202>>>>>// This provides functions required of all XMLDOM objects.
11202>>>>>//
11202>>>>>Class cXMLDOMMixin is a Mixin
11203>>>>>    
11203>>>>>    // Create an XML object of passed class Id and bind passed interface. returns
11203>>>>>    // the object handle. All dynamic XML object can be created using this syntax
11203>>>>>    
11203>>>>>    Function CreateXMLObject Integer iClassId Handle hinfXMLInterface Returns Handle
11205>>>>>        Handle hoId hoDocument
11205>>>>>        // We will always create objects at the DOMDocument level.
11205>>>>>        Get DocumentObject to hoDocument
11206>>>>>        If (hoDocument=0) Begin  // this should never happen.
11208>>>>>            Error DFERR_XML_INTERNAL_ERROR C_$XmlFailedNoDocObject
11209>>>>>>
11209>>>>>            Function_Return 0
11210>>>>>        End
11210>>>>>>
11210>>>>>        If hinfXMLInterface Begin
11212>>>>>            Get Create of hoDocument iClassId to hoID
11213>>>>>            Set XMLInterface of hoID to hinfXMLInterface
11214>>>>>        End
11214>>>>>>
11214>>>>>        Function_Return hoID
11215>>>>>    End_Function
11216>>>>>    
11216>>>>>    // create an XML Node object based on the interface type.
11216>>>>>    // this will convert the interface to the proper type and will create
11216>>>>>    // an appropriate DF object.
11216>>>>>    // This requires that a DocumentObject exists
11216>>>>>    
11216>>>>>    Function CreateXMLNode Handle hinfc Returns Handle
11218>>>>>        Integer iType iClassId
11218>>>>>        Handle  hoDocument hoNode
11218>>>>>        // Get the node type of the infc handle w/o creating a DF object
11218>>>>>        Move (invokexml(DF_IXMLDOMNODE, GET_piNodeType, hinfc, 0, 0, 0, 0)) to iType
11219>>>>>        Move (invokexml(DF_IXMLDOMNODE, GET_ChangeNodeType, hinfc, iType, 1, 0, 0)) to hInfc
11220>>>>>        If (hinfc=0) Begin
11222>>>>>            // this should not happen and we would need to know about this.
11222>>>>>            Error DFERR_XML_INTERNAL_ERROR (C_$XmlFailedNoDocObject + String(iType))
11223>>>>>>
11223>>>>>            Function_Return 0
11224>>>>>        End
11224>>>>>>
11224>>>>>        Get DocumentObject to hoDocument
11225>>>>>        // you can augment your class IDs in a single place.
11225>>>>>        Get NodeClassId of hoDocument iType to iClassId
11226>>>>>        Get CreateXMLObject of hoDocument iClassId hinfc to hoNode
11227>>>>>        
11227>>>>>        Function_Return hoNode
11228>>>>>    End_Function
11229>>>>>    
11229>>>>>    
11229>>>>>    // Change object's class. This let's you change the class id of an object
11229>>>>>    // on an object by object basis. This would let you create nodes (e.g. elements)
11229>>>>>    // that have a custom interface for each node type. Normally, this would be sent
11229>>>>>    // after a node has been created using one of the default classes
11229>>>>>    Function ChangeNodeClass Handle hoNode Integer iClassID Returns Handle
11231>>>>>        Integer iType
11231>>>>>        Handle  hinfcNew
11231>>>>>        Get piNodeType of hoNode to iType
11232>>>>>        Get ChangeNodeType of hoNode iType False to hInfcNew
11233>>>>>        Send Destroy to hoNode // destroy object and old infc handle.
11234>>>>>        Get CreateXMLObject iClassId hinfcNew to hoNode
11235>>>>>        Function_Return hoNode
11236>>>>>    End_Function
11237>>>>>    
11237>>>>>End_Class
11238>>>>>
11238>>>>>
11238>>>>>Class cXMLDOMCollectionMixin is a Mixin
11239>>>>>    
11239>>>>>    Import_Class_Protocol cXMLDOMMixin
11240>>>>>    
11240>>>>>    //  Returns number of items in the collection
11240>>>>>    //
11240>>>>>    Function NodeListLength Returns Integer
11242>>>>>        Integer iLength
11242>>>>>        Get piLength to iLength
11243>>>>>        Function_Return iLength
11244>>>>>    End_Function
11245>>>>>    
11245>>>>>    // Returns an XML node object for pass item
11245>>>>>    //
11245>>>>>    Function CollectionNode Integer I Returns Handle
11247>>>>>        Handle hoNewNode
11247>>>>>        Handle infcItem
11247>>>>>        Get phItem i to infcItem
11248>>>>>        If (infcItem) ;            Get CreateXMLNode infcItem to hoNewNode
11251>>>>>        Function_Return hoNewNode
11252>>>>>    End_Function
11253>>>>>    
11253>>>>>    
11253>>>>>End_Class
11254>>>>>
11254>>>>>// Simple declarations of collections.
11254>>>>>
11254>>>>>Class cXMLDOMNodeList is a BaseXmlDomNodeList
11255>>>>>    Import_Class_Protocol cXMLDOMCollectionMixin
11256>>>>>End_Class
11257>>>>>
11257>>>>>Class cXMLDOMNamedNodeMap is a BaseXmlDomNamedNodeMap
11258>>>>>    
11258>>>>>    Import_Class_Protocol cXMLDOMCollectionMixin
11259>>>>>    
11259>>>>>    // returns a node attribute that matches passed name, zero if none
11259>>>>>    Function NamedNode String sName Returns Handle
11261>>>>>        Handle hoNewNode
11261>>>>>        Handle infcItem
11261>>>>>        Get NamedItem sName to infcItem
11262>>>>>        If infcItem ;            Get CreateXMLNode infcItem to hoNewNode
11265>>>>>        Function_Return hoNewNode
11266>>>>>    End_Function
11267>>>>>    
11267>>>>>    // Adds or changes a node attribute
11267>>>>>    // This should return the passed object Id which is now bound to the attribute. If an error, returns 0
11267>>>>>    Function SetNamedNode Handle hoNode Returns Handle
11269>>>>>        Handle hinfcNode hinfcItem
11269>>>>>        Get XMLInterface of hoNode to hinfcNode // node of passed attribute
11270>>>>>        Get SetNamedItem hinfcNode to hinfcItem
11271>>>>>        If hinfcItem ;            Set XMLInterface of hoNode to hinfcItem
11274>>>>>        Else ;            Move 0 to hoNode // zero indicates error
11276>>>>>        Function_Return hoNode
11277>>>>>    End_Function
11278>>>>>    
11278>>>>>    // removes named attribute, Returns handle of removed node or zero if not found.
11278>>>>>    // Note that returned object must be disposed of or moved somewhere else.
11278>>>>>    Function RemoveNamedNode String sName Returns Handle
11280>>>>>        Handle hoNewNode
11280>>>>>        Handle infcItem
11280>>>>>        Get RemoveNamedItem sName to infcItem
11281>>>>>        If infcItem ;            Get CreateXMLNode infcItem to hoNewNode
11284>>>>>        Function_Return hoNewNode
11285>>>>>    End_Function
11286>>>>>    
11286>>>>>    Function QualifiedNode String sNameSpace String sBaseName Returns Handle
11288>>>>>        Handle hoNewNode
11288>>>>>        Handle infcItem
11288>>>>>        Get QualifiedItem  sBaseName sNameSpace  to infcItem
11289>>>>>        If infcItem ;            Get CreateXMLNode infcItem to hoNewNode
11292>>>>>        Function_Return hoNewNode
11293>>>>>    End_Function
11294>>>>>    
11294>>>>>    Function RemoveQualifiedNode String sNameSpace String sBaseName Returns Handle
11296>>>>>        Handle hoNewNode
11296>>>>>        Handle infcItem
11296>>>>>        Get RemoveQualifiedItem sBaseName sNameSpace to infcItem
11297>>>>>        If infcItem ;            Get CreateXMLNode infcItem to hoNewNode
11300>>>>>        Function_Return hoNewNode
11301>>>>>    End_Function
11302>>>>>    
11302>>>>>End_Class
11303>>>>>
11303>>>>>
11303>>>>>
11303>>>>>// Mixin for nodes.
11303>>>>>//
11303>>>>>//  First the declaration of functions that have no object references.
11303>>>>>//
11303>>>>>
11303>>>>>
11303>>>>>Class cXMLDOMNodeMixin is a Mixin
11304>>>>>    
11304>>>>>    Import_Class_Protocol cXMLDOMMixin
11305>>>>>    
11305>>>>>    //  Append Node to the end of list. Returns passed Object handle if Ok, 0 if error
11305>>>>>    
11305>>>>>    Function AppendNode Handle hoNode Returns Handle
11307>>>>>        Handle hinfcNode
11307>>>>>        Handle infcReturned
11307>>>>>        // Get COM Interface to call Append child.
11307>>>>>        Get XMLInterface of hoNode to hinfcNode
11308>>>>>        If (hinfcNode=0) ;            Function_Return 0
11311>>>>>        Get AppendChild hinfcNode to infcReturned
11312>>>>>        // Interface returned is stored in DataFlex object.
11312>>>>>        If (infcReturned=0) ;            Function_Return 0
11315>>>>>        Set XMLInterface of hoNode to infcReturned
11316>>>>>        Function_Return hoNode
11317>>>>>    End_Function
11318>>>>>    
11318>>>>>    //  Insert NewNode before Node. Returns passed newnode Object handle if Ok, 0 if error
11318>>>>>    
11318>>>>>    Function InsertBeforeNode Handle hoNewNode Handle hoNode Returns Handle
11320>>>>>        Handle hinfcNewNode hinfcNode hoRefNode infcReturned
11320>>>>>        Integer iType
11320>>>>>        // DOM says if no refnode argument passed or it is 0, append to end
11320>>>>>        If (Num_Arguments=1) ;            Move 0 to hoRefNode
11323>>>>>        Else ;            Move hoNode to hoRefNode
11325>>>>>        Get XMLInterface of hoNewNode to hinfcNewNode
11326>>>>>        If (hinfcNewNode=0) ;            Function_Return 0
11329>>>>>        If hoRefNode Begin
11331>>>>>            Get XMLInterface of hoRefNode to hinfcNode
11332>>>>>            If (hinfcNode=0) ;                Function_Return 0
11335>>>>>        End
11335>>>>>>
11335>>>>>        Get InsertBefore hinfcNewNode hinfcNode to infcReturned
11336>>>>>        If (infcReturned=0) ;            Function_Return 0
11339>>>>>        // Interface returned is stored in DataFlex object.
11339>>>>>        Set XMLInterface of hoNewNode to infcReturned
11340>>>>>        Function_Return hoNewNode
11341>>>>>    End_Function
11342>>>>>    
11342>>>>>    //  Remove Node. Returns object Id of removed node, zero if error
11342>>>>>    //  Important: The node is not destroyed! This lets you move it elsewhere if you want
11342>>>>>    
11342>>>>>    Function RemoveNode Handle hoNode Returns Handle
11344>>>>>        Handle hInfcNode
11344>>>>>        Get XMLInterface of hoNode to hInfcNode
11345>>>>>        If (hinfcNode=0) ;            Function_Return 0
11348>>>>>        Get RemoveChild hInfcNode to hinfcNode
11349>>>>>        If (hinfcNode=0) ;            Function_Return 0
11352>>>>>        Set XMLInterface of hoNode to hinfcNode
11353>>>>>        Function_Return hoNode
11354>>>>>    End_Function
11355>>>>>    
11355>>>>>    //  Replace Node. Returns object Id of replaced node, zero if error
11355>>>>>    //  Important: The replaced node is not destroyed! This lets you move it elsewhere if you want
11355>>>>>    
11355>>>>>    Function ReplaceNode Handle hoNewNode Handle hoNodeToReplace Returns Handle
11357>>>>>        Handle hInfcNewNode hinfcNodetoReplace hinfcNode
11357>>>>>        Get XMLInterface of hoNewNode       to hInfcNewNode
11358>>>>>        Get XMLInterface of hoNodetoReplace to hInfcNodetoreplace
11359>>>>>        If (hinfcNewNode=0 or hInfcNodeToReplace=0) ;            Function_Return 0
11362>>>>>        Get ReplaceChild hInfcNewNode hinfcNodeToReplace to hinfcNode
11363>>>>>        If (hinfcNode=0) ;            Function_Return 0
11366>>>>>        Set XMLInterface of hoNodetoReplace to hinfcNode
11367>>>>>        Function_Return hoNodetoReplace
11368>>>>>    End_Function
11369>>>>>    
11369>>>>>    // Remove the named node. Returns handle to removed node. You must destroy
11369>>>>>    // or move this removed object as needed
11369>>>>>    
11369>>>>>    Function RemoveNamedNode String sQueryString Returns Handle
11371>>>>>        Handle hoNode
11371>>>>>        Handle hInfcTemplate hinfcNode
11371>>>>>        Integer iRet
11371>>>>>        Get SelectSingleNode sQueryString to hinfcTemplate
11372>>>>>        If (hinfcTemplate) Begin
11374>>>>>            // Remove child returns an interface to the disassociated node.
11374>>>>>            // It should be disposed by setting it to an object and then calling destroy
11374>>>>>            Get RemoveChild hInfcTemplate to hInfcNode
11375>>>>>            // Even if hInfcTemplate and hInfcNode are the same their reference count will be incremented.
11375>>>>>            // Therefore we must destroy one the interfaces which will decrement the reference count thus
11375>>>>>            // avoding a memory leak
11375>>>>>            Move (invokexml(DF_IXMLDOMNODE, DESTROY_XML_INTERFACE, hInfcTemplate, 0, 0, 0, 0)) to iRet
11376>>>>>            If hInfcNode ;                Get CreateXMLNode hinfcNode to hoNode
11379>>>>>        End
11379>>>>>>
11379>>>>>        Function_Return hoNode
11380>>>>>    End_Function
11381>>>>>    
11381>>>>>    // This function creates a clone of the passed Node. if bRecurse all child nodes are also
11381>>>>>    // cloned. The object Id of the new clone object is returned.
11381>>>>>    // The interface of the object returned can be used in AppendChild to add
11381>>>>>    // the node to the XML Document.
11381>>>>>    
11381>>>>>    Function CloneNode Integer bRecurse Returns Handle
11383>>>>>        Handle hoNewNode
11383>>>>>        Handle hinfcNewNode
11383>>>>>        Get CloneInfcNode (If(bRecurse,-1,0)) to hinfcNewNode
11384>>>>>        If hinfcNewNode ;            Get CreateXMLNode hinfcNewNode to hoNewNode
11387>>>>>        Function_Return hoNewNode
11388>>>>>    End_Function
11389>>>>>    
11389>>>>>    //  Create a collection of all nodes. returns handle of a cXMLDomNodeList
11389>>>>>    
11389>>>>>    Function ChildNodes Returns Handle
11391>>>>>        Handle infcNodeList
11391>>>>>        Handle hoNodeList
11391>>>>>        Get phChildNodes to infcNodeList
11392>>>>>        If (infcNodeList) ;            Get CreateXMLObject U_cXMLDOMNodeList infcNodeList to hoNodeList
11395>>>>>        Function_Return hoNodeList
11396>>>>>    End_Function
11397>>>>>    
11397>>>>>    //  Create a collection of all attributes. returns handle of a cXMLDomNodeMapList
11397>>>>>    
11397>>>>>    Function AttributeNodes Returns Handle
11399>>>>>        Handle hoCollectionId   // Object to hold collection
11399>>>>>        Handle hinfcAttributes  // XML Interface for collection
11399>>>>>        Get phAttributes to hinfcAttributes
11400>>>>>        If (hinfcAttributes) ;            Get CreateXMLObject U_cXMLDOMNamedNodeMap hinfcAttributes to hoCollectionId
11403>>>>>        Function_Return hoCollectionId
11404>>>>>    End_Function
11405>>>>>    
11405>>>>>    //  Create a collection of all attributes for the temporary attribute node object.
11405>>>>>    //  Using this saves a small amount of time creating and destroying this object but
11405>>>>>    //  it must be used with care. This binding is temporary!
11405>>>>>    Function TempAttributeNodes Returns Handle
11407>>>>>        Handle hoCollectionId hoDocument
11407>>>>>        Handle hinfcAttributes  // XML Interface for collection
11407>>>>>        Get phAttributes to hinfcAttributes
11408>>>>>        If (hinfcAttributes) Begin
11410>>>>>            Get DocumentObject to hoDocument
11411>>>>>            Get phoTempDomNodeMap of hoDocument to hoCollectionId
11412>>>>>            Set XMLInterface of hoCollectionId to hinfcAttributes
11413>>>>>        End
11413>>>>>>
11413>>>>>        Function_Return hoCollectionId
11414>>>>>    End_Function
11415>>>>>    
11415>>>>>    
11415>>>>>    // Returns a collection of just elements
11415>>>>>    
11415>>>>>    Function ElementNodes String sQueryString Returns Handle
11417>>>>>        Handle hoNodeList
11417>>>>>        Handle hinfcNodeList
11417>>>>>        Get ElementsByTagName sQueryString to hinfcNodeList
11418>>>>>        If (hinfcNodeList <> 0) ;            Get CreateXMLObject U_cXMLDOMNodeList hinfcNodeList to hoNodeList
11421>>>>>        Function_Return hoNodeList
11422>>>>>    End_Function
11423>>>>>    
11423>>>>>    
11423>>>>>    
11423>>>>>    // Return object handle for query.
11423>>>>>    
11423>>>>>    Function FindNode String sQueryString Returns Handle
11425>>>>>        Handle hoNode
11425>>>>>        Handle hinfcNode
11425>>>>>        Get SelectSingleNode sQueryString to hinfcNode
11426>>>>>        If (hinfcNode <> 0) ;            Get CreateXMLNode hInfcNode to hoNode
11429>>>>>        Function_Return hoNode
11430>>>>>    End_Function
11431>>>>>    
11431>>>>>    // Return object handle for a collection node.
11431>>>>>    
11431>>>>>    
11431>>>>>    Function FindNodeList String sQueryString Returns Handle
11433>>>>>        Handle hoNodeList
11433>>>>>        Handle hinfcNodeList
11433>>>>>        Get SelectNodes sQueryString to hinfcNodeList
11434>>>>>        If (hinfcNodeList <> 0) ;            Get CreateXMLObject U_cXMLDOMNodeList hinfcNodeList to hoNodeList
11437>>>>>        Function_Return hoNodeList
11438>>>>>    End_Function
11439>>>>>    
11439>>>>>    // The CreatexxxxxNode messages creates an node object for the type specified. Both
11439>>>>>    // the interface and the object or of the correct type (i.e. element, comment)
11439>>>>>    // These all return an object handle which can be used to place the object via
11439>>>>>    // appendNode or InsertBeforeNode
11439>>>>>    
11439>>>>>    // This function creates a child element, returning a dataflex object.
11439>>>>>    // The interface of the object returned can be used in AppendChild to add
11439>>>>>    // the element to the XML Document.
11439>>>>>    
11439>>>>>    Function CreateElementNode String sTagName String sValue Returns Handle
11441>>>>>        Handle hoNewElement
11441>>>>>        Handle hoDocumentObject
11441>>>>>        Handle infcNewElement
11441>>>>>        Integer iClassId
11441>>>>>        // The DataFlex objects are created inside the nodes (elements).
11441>>>>>        // Create an element in the document and assign its interface to the new DF object.
11441>>>>>        Get DocumentObject to hoDocumentObject
11442>>>>>        Get createElement of hoDocumentObject sTagName to infcNewElement
11443>>>>>        If infcNewElement Begin // if there was an error, no infc handle would be returned
11445>>>>>            Get NodeClassId of hoDocumentObject NODE_ELEMENT to iClassId
11446>>>>>            Get CreateXMLObject iClassId infcNewElement to hoNewElement
11447>>>>>            If hoNewElement ; // very unlikely this will be zero                Set psText of hoNewElement to sValue
11450>>>>>        End
11450>>>>>>
11450>>>>>        Function_Return hoNewElement
11451>>>>>    End_Function
11452>>>>>    
11452>>>>>    // This function creates an attribute in a document. Attributes are _NOT_ children of an element.
11452>>>>>    // A DataFlex object is returned. An attribute can be added to an xml document using
11452>>>>>    // get AddAttributeNode.
11452>>>>>    
11452>>>>>    Function CreateAttributeNode String sName String sValue Returns Handle
11454>>>>>        Handle hoNewAttribute
11454>>>>>        Handle hoDocumentObject
11454>>>>>        Handle infcNewAttribute
11454>>>>>        Integer iClassId
11454>>>>>        Get DocumentObject to hoDocumentObject
11455>>>>>        // Create an Attribute in the document and assign its interface to the new DF object.
11455>>>>>        Get createAttribute of hoDocumentObject sName to infcNewAttribute
11456>>>>>        If infcNewAttribute Begin // if there was an error, no infc handle would be returned
11458>>>>>            Get NodeClassId of hoDocumentObject NODE_ATTRIBUTE to iClassId
11459>>>>>            Get CreateXMLObject iClassId infcNewAttribute to hoNewAttribute
11460>>>>>            // Set the value of the attribute.
11460>>>>>            If hoNewAttribute ; // very unlikely this will be 0                Set psText of hoNewAttribute to sValue
11463>>>>>        End
11463>>>>>>
11463>>>>>        Function_Return hoNewAttribute
11464>>>>>    End_Function
11465>>>>>    
11465>>>>>    // This function creates a child comment, returning a dataflex object.
11465>>>>>    // The interface of the object returned can be used in AppendChild to add
11465>>>>>    // the comment to the XML Document.
11465>>>>>    
11465>>>>>    Function CreateChildComment String sValue Returns Handle
11467>>>>>        Handle hoNewComment
11467>>>>>        Handle hoDocumentObject
11467>>>>>        Handle infcNewComment
11467>>>>>        Integer iClassID
11467>>>>>        Get DocumentObject to hoDocumentObject
11468>>>>>        // Create an Comment in the document and assign its interface to the new DF object.
11468>>>>>        Get createComment of hoDocumentObject sValue to infcNewComment
11469>>>>>        If infcNewComment Begin // if there was an error, no infc handle would be returned
11471>>>>>            Get NodeClassId of hoDocumentObject NODE_COMMENT to iClassId
11472>>>>>            Get CreateXMLObject iClassId infcNewComment to hoNewComment
11473>>>>>            If hoNewComment ; // very unlikely this will be 0                Set psText of hoNewComment to sValue
11476>>>>>        End
11476>>>>>>
11476>>>>>        Function_Return hoNewComment
11477>>>>>    End_Function
11478>>>>>    
11478>>>>>    // This function creates a child processing instruction, returning a dataflex object.
11478>>>>>    // The interface of the object returned can be used in AppendChild to add
11478>>>>>    // the processing instruction to the XML Document.
11478>>>>>    
11478>>>>>    Function CreateChildProcessingInstruction String sTarget String sValue Returns Handle
11480>>>>>        Handle hoNewProcessingInstruction
11480>>>>>        Handle hoDocumentObject
11480>>>>>        Handle infcNewProcessingInstruction
11480>>>>>        Integer iClassID
11480>>>>>        Get DocumentObject to hoDocumentObject
11481>>>>>        // Create an ProcessingInstruction in the document and assign its interface to the new DF object.
11481>>>>>        Get createProcessingInstruction of hoDocumentObject sTarget sValue to infcNewProcessingInstruction
11482>>>>>        If infcNewProcessingInstruction  Begin // if there was an error, no infc handle would be returned
11484>>>>>            Get NodeClassId of hoDocumentObject NODE_PROCESSING_INSTRUCTION to iClassId
11485>>>>>            Get CreateXMLObject iClassID infcNewProcessingInstruction to hoNewProcessingInstruction
11486>>>>>        End
11486>>>>>>
11486>>>>>        Function_Return hoNewProcessingInstruction
11487>>>>>    End_Function
11488>>>>>    
11488>>>>>    // This function creates a child text node, returning a dataflex object.
11488>>>>>    // The interface of the object returned can be used in AppendChild to add
11488>>>>>    // the text node to the XML Document.
11488>>>>>    
11488>>>>>    Function CreateChildTextNode String sValue Returns Handle
11490>>>>>        Handle hoNewTextNode
11490>>>>>        Handle hoDocumentObject
11490>>>>>        Handle infcNewTextNode
11490>>>>>        Integer iClassID
11490>>>>>        Get DocumentObject to hoDocumentObject
11491>>>>>        // Create an TextNode in the document and assign its interface to the new DF object.
11491>>>>>        Get createTextNode of hoDocumentObject sValue to infcNewTextNode
11492>>>>>        If infcNewTextNode Begin // if there was an error, no infc handle would be returned
11494>>>>>            Get NodeClassId of hoDocumentObject NODE_TEXT to iClassId
11495>>>>>            Get CreateXMLObject iClassId infcNewTextNode to hoNewTextNode
11496>>>>>        End
11496>>>>>>
11496>>>>>        Function_Return hoNewTextNode
11497>>>>>    End_Function
11498>>>>>    
11498>>>>>    // This function creates a cdata text node, returning a dataflex object.
11498>>>>>    // The interface of the object returned can be used in AppendChild to add
11498>>>>>    // the cdata node to the XML Document.
11498>>>>>    
11498>>>>>    Function CreateCDATASectionNode String sValue Returns Handle
11500>>>>>        Handle hoNewNode
11500>>>>>        Handle hoDocumentObject
11500>>>>>        Handle infcNewNode
11500>>>>>        Integer iClassId
11500>>>>>        // The DataFlex objects are created inside the nodes (elements).
11500>>>>>        // Create an element in the document and assign its interface to the new DF object.
11500>>>>>        Get DocumentObject to hoDocumentObject
11501>>>>>        Get createCDATASection of hoDocumentObject sValue to infcNewNode
11502>>>>>        If infcNewNode Begin
11504>>>>>            Get NodeClassId of hoDocumentObject NODE_CDATA_SECTION to iClassId
11505>>>>>            Get CreateXMLObject iClassId infcNewNode to hoNewNode
11506>>>>>        End
11506>>>>>>
11506>>>>>        Function_Return hoNewNode
11507>>>>>    End_Function
11508>>>>>    
11508>>>>>    // Create a document fragment.  Document fragments can be used to house nodes temporarily. When
11508>>>>>    // You append or insert a document fragment (appendNode InsertBeforeNode) child nodes are appended
11508>>>>>    // to the destination object and not the fragment node itself. This is useful!
11508>>>>>    
11508>>>>>    Function CreateDocumentFragmentNode Returns Handle
11510>>>>>        Handle hoNew
11510>>>>>        Handle hoDocumentObject
11510>>>>>        Handle infcNew
11510>>>>>        Integer iClassID
11510>>>>>        Get DocumentObject to hoDocumentObject
11511>>>>>        // Create an Comment in the document and assign its interface to the new DF object.
11511>>>>>        Get createDocumentFragment of hoDocumentObject to infcNew
11512>>>>>        If infcNew Begin // if there was an error, no infc handle would be returned
11514>>>>>            Get NodeClassId of hoDocumentObject NODE_DOCUMENT_FRAGMENT to iClassId
11515>>>>>            Get CreateXMLObject iClassId infcNew to hoNew
11516>>>>>        End
11516>>>>>>
11516>>>>>        Function_Return hoNew
11517>>>>>    End_Function
11518>>>>>    
11518>>>>>    //  Create a Node of any passed Type (e.g. Node_element). Normally you don't need this as there are
11518>>>>>    //  specific messages to do this for each node type. Node that this lets you pass namespaces as a separate
11518>>>>>    //  parameter. With all of the other messages (e.g. createElementNode) you pass namespaces as prefixed to
11518>>>>>    // the tagname (e.g. Get CreateElementNode "MyNameSpace:MyTag" "MyValue" to hoEle)
11518>>>>>    
11518>>>>>    Function CreateChildNode Integer iNodeType String sTagName String sNameSpace Returns Handle
11520>>>>>        Handle hoNewNode hoDocumentObject
11520>>>>>        Handle infcNewNode
11520>>>>>        Integer iClassid iType
11520>>>>>        Get DocumentObject to hoDocumentObject
11521>>>>>        Get NodeClassId iNodeType to iClassId
11522>>>>>        If (iClassId<>0) Begin
11524>>>>>            // Create a node in the document and assign its interface to the new DF object.
11524>>>>>            Get createNode of hoDocumentObject iNodeType sTagName sNameSpace to infcNewNode
11525>>>>>            // this is required to force the interface type to be correct.
11525>>>>>            Move (invokexml(DF_IXMLDOMNODE, GET_piNodeType, infcNewNode, 0, 0, 0, 0)) to iType
11526>>>>>            Move (invokexml(DF_IXMLDOMNODE, GET_ChangeNodeType, infcNewNode, iType, 1, 0, 0)) to infcNewNode
11527>>>>>            
11527>>>>>            If infcNewNode ;                Get CreateXMLObject iClassId infcNewNode to hoNewNode
11530>>>>>        End
11530>>>>>>
11530>>>>>        Function_Return hoNewNode
11531>>>>>    End_Function
11532>>>>>    
11532>>>>>    
11532>>>>>    
11532>>>>>    // The Addxxxxx messages create a new node and appends it to the list. When used as a function,
11532>>>>>    // the object handle is returned and must be disposed of later by the programmer.
11532>>>>>    // When used as a procedure, the object is destroyed--it just does it and is done.
11532>>>>>    
11532>>>>>    Function AddElement String sTagName String sValue Returns Handle
11534>>>>>        Handle hoNewElement
11534>>>>>        Get CreateElementNode sTagName sValue to hoNewElement
11535>>>>>        If hoNewElement ;            Get AppendNode hoNewElement to hoNewElement
11538>>>>>        Function_Return hoNewElement
11539>>>>>    End_Function
11540>>>>>    
11540>>>>>    Procedure AddElement String sTagName String sValue
11542>>>>>        Handle hoNewElement
11542>>>>>        Get AddElement sTagName sValue to hoNewElement
11543>>>>>        If hoNewElement ;            Send Destroy to hoNewElement
11546>>>>>        Else ;            Error DFERR_XML_INTERNAL_ERROR (SFormat(C_$XmlMethodFailure, "msg_AddElement"))
11548>>>>>    End_Procedure
11549>>>>>    
11549>>>>>    // this returns the object, This is often needed
11549>>>>>    Function CreateElementNodeNS String sNameSpace String sTagName String sValue Returns Handle
11551>>>>>        Handle hoNewElement
11551>>>>>        Get CreateChildNode NODE_ELEMENT sTagName sNameSpace to hoNewElement
11552>>>>>        If (hoNewElement and sValue<>"") ;            Set psText of hoNewElement to sValue
11555>>>>>        Function_Return hoNewElement
11556>>>>>    End_Function
11557>>>>>    
11557>>>>>    
11557>>>>>    // this returns the object, This is often needed
11557>>>>>    Function AddElementNS String sNameSpace String sTagName String sValue Returns Handle
11559>>>>>        Handle hoNewElement
11559>>>>>        Get CreateElementNodeNS sNameSpace sTagName sValue to hoNewElement
11560>>>>>        If hoNewElement Begin
11562>>>>>            Get AppendNode hoNewElement to hoNewElement
11563>>>>>        End
11563>>>>>>
11563>>>>>        Function_Return hoNewElement
11564>>>>>    End_Function
11565>>>>>    
11565>>>>>    Procedure AddElementNS String sNameSpace String sTagName String sValue
11567>>>>>        Handle hoNewElement
11567>>>>>        Get AddElementNS sNameSpace sTagName sValue to hoNewElement
11568>>>>>        If hoNewElement ;            Send Destroy to hoNewElement
11571>>>>>        Else ;            Error DFERR_XML_INTERNAL_ERROR (SFormat(C_$XmlMethodFailure, "msg_AddElementNS"))
11573>>>>>    End_Procedure
11574>>>>>    
11574>>>>>    Function AddAttributeNode Handle hoNode Returns Handle
11576>>>>>        Handle hInfc
11576>>>>>        Get Set_AttributeNode (XmlInterface(hoNode)) to hInfc
11577>>>>>        If hInfc ; // if ret value we have a replacement            Set XmlInterface of hoNode to hInfc
11580>>>>>        Function_Return hoNode
11581>>>>>    End_Function
11582>>>>>    
11582>>>>>    Function AttributeValueNode String sName Returns Handle
11584>>>>>        Handle hInfc
11584>>>>>        Handle hoNode
11584>>>>>        Get AttributeNode sName to hInfc
11585>>>>>        If hInfc ; // if ret value we have a replacement            Get CreateXMLNode hInfc to hoNode
11588>>>>>        Function_Return hoNode
11589>>>>>    End_Function
11590>>>>>    
11590>>>>>    Function AttributeValueNodeNS String sNameSpace String sBaseName Returns Handle
11592>>>>>        Handle hoAttrs hoAttr
11592>>>>>        String sValue
11592>>>>>        Get TempAttributeNodes to hoAttrs
11593>>>>>        If hoAttrs Begin
11595>>>>>            Get QualifiedNode of hoAttrs sNamespace sBaseName to hoAttr
11596>>>>>            Set XMLInterface of hoAttrs to 0
11597>>>>>        End
11597>>>>>>
11597>>>>>        Function_Return hoAttr
11598>>>>>    End_Function
11599>>>>>    
11599>>>>>    
11599>>>>>    Function CreateAttributeNodeNS String sNameSpace String sName String sValue Returns Handle
11601>>>>>        Handle hoNewAttribute
11601>>>>>        Get CreateChildNode NODE_ATTRIBUTE sName sNameSpace to hoNewAttribute
11602>>>>>        If hoNewAttribute ;            Set psText of hoNewAttribute to sValue
11605>>>>>        Function_Return hoNewAttribute
11606>>>>>    End_Function
11607>>>>>    
11607>>>>>    Procedure AddAttributeNS String sNameSpace String sName String sValue
11609>>>>>        Handle hoNode
11609>>>>>        Get CreateAttributeNodeNS sNameSpace sName sValue to hoNode
11610>>>>>        If hoNode Begin
11612>>>>>            Get AddAttributeNode hoNode to hoNode
11613>>>>>            If hoNode ;                Send Destroy of hoNode
11616>>>>>        End
11616>>>>>>
11616>>>>>        Else ;            Error DFERR_XML_INTERNAL_ERROR (SFormat(C_$XmlMethodFailure, "msg_AddAttributeNS"))
11618>>>>>    End_Procedure
11619>>>>>    
11619>>>>>    
11619>>>>>    // This function encapsulates creation and addition of attributes to a node.
11619>>>>>    // should only work with element class
11619>>>>>    Procedure AddAttribute String sName String sValue
11621>>>>>        Set AttributeValue sName to sValue
11622>>>>>    End_Procedure
11623>>>>>    
11623>>>>>    // This function encapsulates creation and addition of comments to a node.
11623>>>>>    // The return value is a Boolean that is currently unused.
11623>>>>>    
11623>>>>>    Procedure AddChildComment String sValue
11625>>>>>        Handle hoNewNode
11625>>>>>        Get createChildComment sValue to hoNewNode
11626>>>>>        If not hoNewNode ;            Error DFERR_XML_INTERNAL_ERROR (SFormat(C_$XmlMethodFailure, "msg_AddChildComment"))
11629>>>>>        Else Begin
11630>>>>>            Get AppendNode hoNewNode to hoNewNode
11631>>>>>            Send Destroy to hoNewNode
11632>>>>>        End
11632>>>>>>
11632>>>>>    End_Procedure
11633>>>>>    
11633>>>>>    // This function encapsulates creation and addition of processing instructions to a node.
11633>>>>>    // The return value is a Boolean that is currently unused.
11633>>>>>    
11633>>>>>    Procedure AddChildProcessingInstruction String sTarget String sValue
11635>>>>>        Handle hoNewNode
11635>>>>>        Get createChildProcessingInstruction sTarget sValue to hoNewNode
11636>>>>>        If not hoNewNode ;            Error DFERR_XML_INTERNAL_ERROR (SFormat(C_$XmlMethodFailure, "msg_AddChildProcessingInstruction"))
11639>>>>>        Else Begin
11640>>>>>            Get AppendNode hoNewNode to hoNewNode
11641>>>>>            Send Destroy to hoNewNode
11642>>>>>        End
11642>>>>>>
11642>>>>>    End_Procedure
11643>>>>>    
11643>>>>>    
11643>>>>>    // This function encapsulates creation and addition of text nodes to a node.
11643>>>>>    // The return value is a Boolean that is currently unused.
11643>>>>>    
11643>>>>>    Procedure AddChildTextNode String sValue
11645>>>>>        Handle hoNewNode
11645>>>>>        Get createChildTextNode sValue to hoNewNode
11646>>>>>        If not hoNewNode ;            Error DFERR_XML_INTERNAL_ERROR (SFormat(C_$XmlMethodFailure, "msg_AddChildTextNode"))
11649>>>>>        Else Begin
11650>>>>>            Get AppendNode hoNewNode to hoNewNode
11651>>>>>            Send Destroy to hoNewNode
11652>>>>>        End
11652>>>>>>
11652>>>>>    End_Procedure
11653>>>>>    
11653>>>>>    // This procedure encapsulates creation and addition of cdata text nodes to a node.
11653>>>>>    Procedure AddCDataSection String sValue
11655>>>>>        Handle hoNewNode
11655>>>>>        Get CreateCDATASectionNode sValue to hoNewNode
11656>>>>>        If not hoNewNode ;            Error DFERR_XML_INTERNAL_ERROR (SFormat(C_$XmlMethodFailure, "msg_AddCDataSection"))
11659>>>>>        Else Begin
11660>>>>>            Get AppendNode hoNewNode to hoNewNode
11661>>>>>            Send Destroy to hoNewNode
11662>>>>>        End
11662>>>>>>
11662>>>>>    End_Procedure
11663>>>>>    
11663>>>>>    
11663>>>>>    Function AddChildNode Integer iNodeType String sTagName String sNameSpace Returns Handle
11665>>>>>        Handle hoNewNode
11665>>>>>        Handle hoDocumentObject
11665>>>>>        Get DocumentObject to hoDocumentObject
11666>>>>>        Get createChildNode of hoDocumentObject iNodeType sTagName sNamespace to hoNewNode
11667>>>>>        If hoNewNode ;            Get AppendNode hoNewNode to hoNewNode
11670>>>>>        Function_Return hoNewNode
11671>>>>>    End_Function
11672>>>>>    
11672>>>>>    // don't use the runtime/msxml version of this. Instead just return the
11672>>>>>    // first text from the first child node. This is much faster
11672>>>>>    Function psText Returns String
11674>>>>>        Handle hText
11674>>>>>        String sValue
11674>>>>>        Get phFirstChild to hText
11675>>>>>        Get InfcNodeValue hText to sValue
11676>>>>>        Function_Return sValue
11677>>>>>    End_Function
11678>>>>>    
11678>>>>>    // Use this to call the internal Text property. This returns all text for all child
11678>>>>>    // node. You rarely would want to do this. The is uses the msxml psText which can
11678>>>>>    // get slow with very large files. If for some reason you need all of the child node's
11678>>>>>    // text and the file is large, you might want to consider doing this process manually.
11678>>>>>    Function AllChildNodesText Returns String
11680>>>>>        String sValue
11680>>>>>        Forward Get psText to sValue
11682>>>>>        Function_Return sValue
11683>>>>>    End_Function
11684>>>>>    
11684>>>>>    // return the interface NodeValue without having to create a
11684>>>>>    // new object. This also disposes the hInfc interface
11684>>>>>    Function InfcNodeValue Handle hInfc Returns String
11686>>>>>        Handle hoDocument hoTempNode
11686>>>>>        String sValue
11686>>>>>        If (hinfc) Begin
11688>>>>>            Get DocumentObject to hoDocument
11689>>>>>            Get phoTempDomNode of hoDocument to hoTempNode
11690>>>>>            Set XMLInterface of hoTempNode to hInfc
11691>>>>>            Get psNodeValue of hoTempNode to sValue
11692>>>>>            // This disposes of hInfc which was passed in. After
11692>>>>>            // calling this you can no longer use it (which is good).
11692>>>>>            Set XMLInterface of hoTempNode to 0
11693>>>>>        End
11693>>>>>>
11693>>>>>        Function_Return sValue
11694>>>>>    End_Function
11695>>>>>    
11695>>>>>    // ChildNodeValue is used to get the "value" of an element. This is useful when the element
11695>>>>>    // only has a single value (similar to an attribute).
11695>>>>>    
11695>>>>>    Function ChildNodeValue String sTagName Returns String
11697>>>>>        Handle hoTempNode hoDocument
11697>>>>>        Handle hinfcTempNode
11697>>>>>        String sRetVal
11697>>>>>        Get SelectSingleNode sTagName to hinfcTempNode
11698>>>>>        If (hinfcTempNode <> 0) Begin
11700>>>>>            Get DocumentObject to hoDocument
11701>>>>>            Get phoTempDomNode of hoDocument to hoTempNode
11702>>>>>            Set XMLInterface of hoTempNode to hinfcTempNode
11703>>>>>            Get phFirstChild of hoTempNode to hinfcTempNode
11704>>>>>            Set XMLInterface of hoTempNode to 0
11705>>>>>            If hinfcTempNode Begin
11707>>>>>                Get InfcNodeValue hinfcTempNode to sRetVal
11708>>>>>            End
11708>>>>>>
11708>>>>>        End
11708>>>>>>
11708>>>>>        Function_Return sRetVal
11709>>>>>    End_Function
11710>>>>>    
11710>>>>>    // This simple function allows a parent to change the text of one of its elements.
11710>>>>>    // This actually occurs quite a bit, because (as stated above) lowest level
11710>>>>>    // elements are frequently used as properties.
11710>>>>>    //
11710>>>>>    Procedure SetChildNodeValue String sTagName String sValue
11712>>>>>        Handle hoTempNode
11712>>>>>        Handle hinfcTempNode
11712>>>>>        // Search for the node that matches.
11712>>>>>        Get SelectSingleNode sTagName to hinfcTempNode
11713>>>>>        // If no match is found, add a new element with the tag.
11713>>>>>        If (hinfcTempNode = 0) ;            Send AddElement sTagName sValue
11716>>>>>        Else Begin
11717>>>>>            Get CreateXMLObject U_BaseXMLDOMNode hinfcTempNode to hoTempNode
11718>>>>>            If hoTempNode Begin
11720>>>>>                // Set the text of the element.
11720>>>>>                Set psText of hoTempNode to sValue
11721>>>>>                Send Destroy to hoTempNode
11722>>>>>            End
11722>>>>>>
11722>>>>>            Else ;                Error DFERR_XML_INTERNAL_ERROR (SFormat(C_$XmlMethodFailure, "msg_SetChildNodeValue"))
11724>>>>>        End
11724>>>>>>
11724>>>>>    End_Procedure
11725>>>>>    
11725>>>>>    // These messages are used to allow you to travese through a nodes.
11725>>>>>    
11725>>>>>    Function FirstChild Returns Handle
11727>>>>>        Handle hoChild
11727>>>>>        Handle hinfcChild
11727>>>>>        Get phFirstChild  to hinfcChild
11728>>>>>        If (hinfcChild) ;            Get CreateXMLNode hinfcChild to hoChild
11731>>>>>        Function_Return hoChild
11732>>>>>    End_Function
11733>>>>>    
11733>>>>>    Function NextSibling Returns Handle
11735>>>>>        Handle hoChild
11735>>>>>        Handle hinfcChild
11735>>>>>        Get phNextSibling  to hinfcChild
11736>>>>>        If (hinfcChild) ;            Get CreateXMLNode hinfcChild to hoChild
11739>>>>>        Function_Return hoChild
11740>>>>>    End_Function
11741>>>>>    
11741>>>>>    Function PreviousSibling Returns Handle
11743>>>>>        Handle hoChild
11743>>>>>        Handle hinfcChild
11743>>>>>        Get phPreviousSibling  to hinfcChild
11744>>>>>        If (hinfcChild) ;            Get CreateXMLNode hinfcChild to hoChild
11747>>>>>        Function_Return hoChild
11748>>>>>    End_Function
11749>>>>>    
11749>>>>>    Function LastChild Returns Handle
11751>>>>>        Handle hoChild
11751>>>>>        Handle hinfcChild
11751>>>>>        Get phLastChild  to hinfcChild
11752>>>>>        If (hinfcChild) ;            Get CreateXMLNode hinfcChild to hoChild
11755>>>>>        Function_Return hoChild
11756>>>>>    End_Function
11757>>>>>    
11757>>>>>    // return an object that is the parent of the current node
11757>>>>>    Function ParentNode Returns Handle
11759>>>>>        Handle hoId
11759>>>>>        Handle hinfcXMLInterface
11759>>>>>        Get phParentNode to hinfcXMLInterface
11760>>>>>        If (hinfcXMLInterface) ;            Get CreateXmlNode hinfcXMLInterface to hoID
11763>>>>>        Function_Return hoID
11764>>>>>    End_Function
11765>>>>>    
11765>>>>>    // Same as NextSibling except it uses or destroys the current node
11765>>>>>    //
11765>>>>>    // optimized version does not destroy/create object unless it needs to.
11765>>>>>    // if the next node is the same node type we will resuse this object
11765>>>>>    // else this object is destroyed
11765>>>>>    Function NextNode Returns Handle
11767>>>>>        Handle hoNode hoDocument
11767>>>>>        Handle hInfc
11767>>>>>        Get phNextSibling to hInfc
11768>>>>>        If hInfc Begin
11770>>>>>            Get DocumentObject to hoDocument
11771>>>>>            Move Self to hoNode
11772>>>>>            Send BindXMLInfc of hoDocument hInfc (&hoNode)
11773>>>>>        End
11773>>>>>>
11773>>>>>        Else Begin
11774>>>>>            Send Destroy
11775>>>>>            Move 0 to hoNode
11776>>>>>        End
11776>>>>>>
11776>>>>>        Function_Return hoNode
11777>>>>>    End_Function
11778>>>>>    
11778>>>>>    
11778>>>>>    // Enumerate through all nodes.
11778>>>>>    
11778>>>>>    Procedure EnumerateNodes Integer iMsg Handle hoReceiver String sVal1 String sVal2
11780>>>>>        Integer i iLen
11780>>>>>        Handle hoNode
11780>>>>>        Handle hoNodeCollection
11780>>>>>        Get ChildNodes to hoNodeCollection
11781>>>>>        If (hoNodeCollection <> 0) Begin
11783>>>>>            Get NodeListLength of hoNodeCollection to iLen
11784>>>>>            Decrement iLen
11785>>>>>            For i from 0 to iLen
11791>>>>>>
11791>>>>>                // For each record, process its fields.
11791>>>>>                Get CollectionNode of hoNodeCollection i to hoNode
11792>>>>>                Send iMsg of hoReceiver hoNode sVal1 sVal2
11793>>>>>                Send Destroy of hoNode
11794>>>>>            Loop
11795>>>>>>
11795>>>>>            Send Destroy of hoNodeCollection
11796>>>>>        End
11796>>>>>>
11796>>>>>    End_Procedure
11797>>>>>    
11797>>>>>    // Enumerate through all elements.
11797>>>>>    
11797>>>>>    Procedure EnumerateElements Integer iMsg Handle hoReceiver String sVal1 String sVal2
11799>>>>>        Integer i iLen
11799>>>>>        Handle hoNode
11799>>>>>        Handle hoNodeCollection
11799>>>>>        Get ChildNodes to hoNodeCollection
11800>>>>>        If (hoNodeCollection <> 0) Begin
11802>>>>>            Get NodeListLength of hoNodeCollection to iLen
11803>>>>>            Decrement iLen
11804>>>>>            For i from 0 to iLen
11810>>>>>>
11810>>>>>                // For each record, process its fields.
11810>>>>>                Get CollectionNode of hoNodeCollection i to hoNode
11811>>>>>                If (piNodeType(hoNode)=NODE_ELEMENT) ;                    Send iMsg of hoReceiver hoNode sVal1 sVal2
11814>>>>>                Send Destroy of hoNode
11815>>>>>            Loop
11816>>>>>>
11816>>>>>            Send Destroy of hoNodeCollection
11817>>>>>        End
11817>>>>>>
11817>>>>>    End_Procedure
11818>>>>>    
11818>>>>>    
11818>>>>>    // enumerate through all attributes. There is no recurse here because attributes will not
11818>>>>>    // contain attributes.
11818>>>>>    
11818>>>>>    Procedure EnumerateAttributes Integer iMsg Handle hoReceiver String sSomeValue
11820>>>>>        Integer i iLen
11820>>>>>        Handle hoNode
11820>>>>>        Handle hoNodeMapCollection
11820>>>>>        // we don't use tempattributenodes because we don't know what the enum message will do.
11820>>>>>        Get AttributeNodes to hoNodeMapCollection
11821>>>>>        If (hoNodeMapCollection <> 0) Begin
11823>>>>>            Get NodeListLength of hoNodeMapCollection to iLen
11824>>>>>            Decrement iLen
11825>>>>>            For i from 0 to iLen
11831>>>>>>
11831>>>>>                // For each record, process its fields.
11831>>>>>                Get CollectionNode of hoNodeMapCollection i to hoNode
11832>>>>>                Send iMsg of hoReceiver hoNode sSomeValue
11833>>>>>                Send Destroy of hoNode
11834>>>>>            Loop
11835>>>>>>
11835>>>>>            Send Destroy of hoNodeMapCollection
11836>>>>>        End
11836>>>>>>
11836>>>>>    End_Procedure
11837>>>>>    
11837>>>>>    
11837>>>>>    Function XSLTransformation Handle hoXSLDocument Returns String
11839>>>>>        Handle infcXSLStartAt
11839>>>>>        String sBuffer
11839>>>>>        // Transformation is of current object using passed XSLDocument.
11839>>>>>        Get XMLInterface of hoXSLDocument to infcXSLStartAt
11840>>>>>        Get TransformNode infcXSLStartAt to sBuffer
11841>>>>>        Function_Return sBuffer
11842>>>>>    End_Function
11843>>>>>    
11843>>>>>    // This allows for transformations not limited to the size of the string buffer
11843>>>>>    //
11843>>>>>    // Note that it is up to the programmer to dispose of the memory allocated at pBuffer
11843>>>>>    // by using the free(pBuffer) function
11843>>>>>    //
11843>>>>>    Function XSLTransformationToAddress Handle hoXSLDocument Returns Address
11845>>>>>        Handle infcXSLStartAt
11845>>>>>        Address pBuffer
11845>>>>>        // Transformation is of current object using passed XSLDocument.
11845>>>>>        Get XMLInterface of hoXSLDocument to infcXSLStartAt
11846>>>>>        Get TransformNodeToAddress infcXSLStartAt to pBuffer
11847>>>>>        Function_Return pBuffer
11848>>>>>    End_Function
11849>>>>>    
11849>>>>>    
11849>>>>>    // extract base name from string. e.g.: ns:name --> name
11849>>>>>    //
11849>>>>>    Function BaseNameFromQName String sName Returns String
11851>>>>>        Integer iPos
11851>>>>>        Move (Pos(":",sName)) to iPos
11852>>>>>        If iPos Begin
11854>>>>>            Move (remove(sName,1,iPos)) to sName
11855>>>>>        End
11855>>>>>>
11855>>>>>        Function_Return sName
11856>>>>>    End_Function
11857>>>>>    
11857>>>>>    // extract prefix name from string. e.g.: ns:name --> ns
11857>>>>>    //
11857>>>>>    Function PrefixNameFromQName String sName Returns String
11859>>>>>        String sPreFix
11859>>>>>        Integer iPos
11859>>>>>        Move (Pos(":",sName)) to iPos
11860>>>>>        If iPos Begin
11862>>>>>            Move (Left(sName,iPos-1)) to sPreFix
11863>>>>>        End
11863>>>>>>
11863>>>>>        Function_Return sPreFix
11864>>>>>    End_Function
11865>>>>>    
11865>>>>>    
11865>>>>>    // Returns true if node is element and namespace and base name match
11865>>>>>    //
11865>>>>>    Function IsElementNS String sNamespaceURI String sBaseName Returns Boolean
11867>>>>>        Function_Return (piNodeType(Self)=NODE_ELEMENT and ;            psNameSpaceURI(Self)=sNamespaceURI and ;            psBaseName(Self)=sBaseName )
11868>>>>>    End_Function
11869>>>>>    
11869>>>>>    // Returns node of first occurence of child node matching namespace and base name
11869>>>>>    //
11869>>>>>    Function ChildElementNS String sNameSpaceURI String sBaseName Returns Handle
11871>>>>>        Handle hoNode
11871>>>>>        Get FirstChild to hoNode
11872>>>>>        While (hoNode and not(IsElementNS(hoNode, sNameSpaceURI, sBaseName)))
11876>>>>>            Get NextNode of hoNode to hoNode
11877>>>>>        Loop
11878>>>>>>
11878>>>>>        Function_Return hoNode
11879>>>>>    End_Function
11880>>>>>    
11880>>>>>    Function NextElementNS String sNameSpaceURI String sBaseName Returns Handle
11882>>>>>        Handle hoNode
11882>>>>>        // NextNode may return the same object or it may destroy the object and
11882>>>>>        // return nothing or a different object
11882>>>>>        Get NextNode to hoNode
11883>>>>>        While (hoNode and not(IsElementNS(hoNode, sNameSpaceURI, sBaseName)))
11887>>>>>            // use of hoNode is required. This can be different than self
11887>>>>>            Get NextNode of hoNode to hoNode
11888>>>>>        Loop
11889>>>>>>
11889>>>>>        
11889>>>>>        Function_Return hoNode
11890>>>>>    End_Function
11891>>>>>    
11891>>>>>    
11891>>>>>    // Returns value (string) first occurence of child node matching namespace and base name
11891>>>>>    //
11891>>>>>    Function ChildElementValueNS String sNameSpaceURI String sBaseName Returns String
11893>>>>>        Handle hoNext
11893>>>>>        String sText
11893>>>>>        Get ChildElementNS sNameSpaceURI sBaseName to hoNext
11894>>>>>        If hoNext Begin
11896>>>>>            Get psText of hoNext to sText
11897>>>>>            Send destroy of hoNext
11898>>>>>        End
11898>>>>>>
11898>>>>>        Function_Return sText
11899>>>>>    End_Function
11900>>>>>    
11900>>>>>    Procedure SetChildElementValueNS String sNameSpaceURI String sBaseName String sValue
11902>>>>>        Handle hoNode
11902>>>>>        Handle hinfcTempNode
11902>>>>>        Get ChildElementNS sNameSpaceURI sBaseName to hoNode
11903>>>>>        If (hoNode=0) Begin
11905>>>>>            Send AddElementNS sNameSpaceURI sBaseName sValue
11906>>>>>        End
11906>>>>>>
11906>>>>>        Else Begin
11907>>>>>            Set psText of hoNode to sValue
11908>>>>>            Send destroy of hoNode
11909>>>>>        End
11909>>>>>>
11909>>>>>    End_Procedure
11910>>>>>    
11910>>>>>    // pass a prefix and try to finds its NameSpaceURI. Start at current node and work up to parent.
11910>>>>>    // This can be useful when a qualified name is found in an attribute value
11910>>>>>    //
11910>>>>>    Function PrefixToNamespaceURI String sPrefix Returns String
11912>>>>>        Handle hoNode
11912>>>>>        Integer i iNodes
11912>>>>>        Handle hoNodes hoParentNode hoAttNode
11912>>>>>        Boolean bDone bParent
11912>>>>>        String sAttPrefix sName sNameSpace
11912>>>>>        
11912>>>>>        Move Self to hoNode
11913>>>>>        While not bDone
11917>>>>>            Get TempAttributeNodes of hoNode to hoNodes
11918>>>>>            If (hoNodes <> 0) Begin
11920>>>>>                Get NodeListLength of hoNodes to iNodes
11921>>>>>                For i from 0 to (iNodes-1)
11927>>>>>>
11927>>>>>                    // For each record, process its fields.
11927>>>>>                    Get CollectionNode of hoNodes i to hoAttNode
11928>>>>>                    Get psPrefix of hoAttNode to sAttPrefix
11929>>>>>                    Get psBaseName of hoAttNode to sName
11930>>>>>                    // with legacy msxml, xmlns="foo" returns psPrefix="xmlns" and pbBaseName=""
11930>>>>>                    // with newer msxml, xmlns="foo" returns psPrefix="" and pbBaseName="xmlns"
11930>>>>>                    // We handle both cases here.
11930>>>>>                    
11930>>>>>                    If ( (sAttPrefix="xmlns" and sName=sPrefix) or ; // if a normal xmlns:xx="foo" match (sPrefix="xx") or a legacy xmlns="foo" match (sPrefix="")                        (sPrefix="" and sAttPrefix="" and sName="xmlns") ) Begin // special test for newer msxml xmlns="foo" match (sPrefix="")
11932>>>>>                        
11932>>>>>                        Get Value of hoAttNode to sNameSpace
11933>>>>>                        Move True to bDone
11934>>>>>                        Move (iNodes-1) to i
11935>>>>>                        
11935>>>>>                    End
11935>>>>>>
11935>>>>>                    
11935>>>>>                    Send Destroy of hoAttNode
11936>>>>>                Loop
11937>>>>>>
11937>>>>>                Set XMLInterface of hoNodes to 0
11938>>>>>            End
11938>>>>>>
11938>>>>>            
11938>>>>>            Get ParentNode of hoNode to hoParentNode
11939>>>>>            If bParent ;                Send destroy of hoNode
11942>>>>>            If not bDone Begin
11944>>>>>                If not hoParentNode ;                    Move True to bDone
11947>>>>>                Else Begin
11948>>>>>                    Move True to bParent
11949>>>>>                    Move hoParentNode to hoNode
11950>>>>>                End
11950>>>>>>
11950>>>>>            End
11950>>>>>>
11950>>>>>        Loop
11951>>>>>>
11951>>>>>        Function_Return sNameSpace
11952>>>>>    End_Function
11953>>>>>    
11953>>>>>    
11953>>>>>    
11953>>>>>End_Class
11954>>>>>
11954>>>>>// Set up basic inheritance for specialized forms of XML classes.
11954>>>>>// This needs to be done so we can make objects of these types.
11954>>>>>
11954>>>>>Class cXMLDOMElement is a BaseXmlDomElement
11955>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
11956>>>>>    
11956>>>>>    // Should use AddAttributeValue...does same thing
11956>>>>>    Procedure SetAttributeValue String sName String sValue
11958>>>>>        Send AddAttribute sName sValue
11959>>>>>    End_Procedure
11960>>>>>    
11960>>>>>    // Note: Get_AttributeValue already there
11960>>>>>    
11960>>>>>    Procedure RemoveAttribute String sName
11962>>>>>        Integer iVal
11962>>>>>        Get RemoveAttribute sName to iVal
11963>>>>>    End_Procedure
11964>>>>>    
11964>>>>>    Function AttributeValueNS String sNameSpace String sBaseName Returns String
11966>>>>>        String sValue
11966>>>>>        Handle hinfcItem
11966>>>>>        Handle hoDoc hoTempAttributeNodes hoNode
11966>>>>>        Integer hinfcAttributes
11966>>>>>        
11966>>>>>        Get TempAttributeNodes to hoTempAttributeNodes
11967>>>>>        Get QualifiedItem of hoTempAttributeNodes sBaseName sNameSpace  to hinfcItem
11968>>>>>        Set XMLInterface of hoTempAttributeNodes to 0
11969>>>>>        If hinfcItem Begin
11971>>>>>            Get DocumentObject to hoDoc
11972>>>>>            Get phoTempDomNode of hoDoc to hoNode
11973>>>>>            Set XMLInterface of hoNode to hinfcItem
11974>>>>>            Get psNodeValue of hoNode to sValue
11975>>>>>            Set XMLInterface of hoNode to 0
11976>>>>>        End
11976>>>>>>
11976>>>>>        Function_Return sValue
11977>>>>>    End_Function
11978>>>>>    
11978>>>>>    Procedure RemoveAttributeNS String sNameSpace String sBaseName
11980>>>>>        Handle hoAttrs hoAttr
11980>>>>>        String sValue
11980>>>>>        Get TempAttributeNodes to hoAttrs
11981>>>>>        If hoAttrs Begin
11983>>>>>            Get RemoveQualifiedNode of hoAttrs sNamespace sBaseName to hoAttr
11984>>>>>            Set XMLInterface of hoAttrs to 0
11985>>>>>            If hoAttr ;                Send destroy of hoAttr
11988>>>>>        End
11988>>>>>>
11988>>>>>    End_Procedure
11989>>>>>    
11989>>>>>End_Class
11990>>>>>
11990>>>>>Class cXMLDOMNode is a BaseXmlDomNode
11991>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
11992>>>>>End_Class
11993>>>>>
11993>>>>>Class cXMLDOMAttribute is a BaseXmlDomAttribute
11994>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
11995>>>>>End_Class
11996>>>>>
11996>>>>>Class cXMLDOMComment is a BaseXmlDomComment
11997>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
11998>>>>>End_Class
11999>>>>>
11999>>>>>Class cXMLDOMProcessingInstruction is a BaseXmlDomProcessingInstruction
12000>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
12001>>>>>End_Class
12002>>>>>
12002>>>>>Class cXMLDOMTextNode is a BaseXmlDomTextNode
12003>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
12004>>>>>End_Class
12005>>>>>
12005>>>>>Class cXMLDOMCDATASection is a BaseXmlDomCDATASection
12006>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
12007>>>>>End_Class
12008>>>>>
12008>>>>>Class cXMLDOMDocumentType is a BaseXmlDomDocumentType
12009>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
12010>>>>>    
12010>>>>>End_Class
12011>>>>>
12011>>>>>Class cXMLDOMNotation is a BaseXmlDomNotation
12012>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
12013>>>>>End_Class
12014>>>>>
12014>>>>>Class cXMLDOMEntity is a BaseXmlDomEntity
12015>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
12016>>>>>End_Class
12017>>>>>
12017>>>>>Class cXMLDOMEntityReference is a BaseXmlDomEntityReference
12018>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
12019>>>>>End_Class
12020>>>>>
12020>>>>>Class cXMLDOMDocumentFragment is a BaseXmlDomDocumentFragment
12021>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
12022>>>>>End_Class
12023>>>>>
12023>>>>>
12023>>>>>Class cXMLDOMParseError is a BaseXMLDomParseError
12024>>>>>    // returns an error sub-object as a sibling of this error object
12024>>>>>    Function ErrorItemNode Integer iItem Returns Handle
12026>>>>>        Handle hoParseErrorNode hoParent
12026>>>>>        Handle hParseErrorIntf
12026>>>>>        Get ErrorItem iItem to hParseErrorIntf
12027>>>>>        If (hParseErrorIntf) Begin
12029>>>>>            // add to parent in case developer destroys the current object
12029>>>>>            Get Parent to hoParent
12030>>>>>            Get Create of hoParent U_cXMLDOMParseError to hoParseErrorNode
12031>>>>>            Set XmlInterface of hoParseErrorNode to hParseErrorIntf
12032>>>>>        End
12032>>>>>>
12032>>>>>        Function_Return hoParseErrorNode
12033>>>>>    End_Function
12034>>>>>End_Class
12035>>>>>
12035>>>>>// Base document class with Base functions.
12035>>>>>
12035>>>>>Class cXMLDOMDocument is an BaseXmlDomDocument
12036>>>>>    
12036>>>>>    Import_Class_Protocol cXMLDOMNodeMixin
12037>>>>>    
12037>>>>>    Procedure Construct_Object
12039>>>>>        Handle hInfc
12039>>>>>        Forward Send Construct_Object
12041>>>>>        Property String psDocumentName ""
12042>>>>>        Property Integer phPrivateDocumentElement 0
12043>>>>>        Property Handle phoTempDomNode (Create(Self,U_cXMLDomNode))
12044>>>>>        Property Handle phoTempDomNodeMap (Create(Self,U_cXMLDOMNamedNodeMap))
12045>>>>>        
12045>>>>>        // added in 15.1. If no COM pointer, msxml6 is most likely not installed. This will
12045>>>>>        // raise an unhandled error, which could be augmented to do something else.
12045>>>>>        Get XmlInterface to hInfc
12046>>>>>        If (hInfc=0) Begin
12048>>>>>            Send ErrorCreatingXMLObject
12049>>>>>        End
12049>>>>>>
12049>>>>>        
12049>>>>>        // as of 18.0 pbAsync now defaults to False. In most cases, this is what you want
12049>>>>>        Set pbAsync to False
12050>>>>>    End_Procedure
12051>>>>>    
12051>>>>>    // returns the classId for the passed NodeType. This is a good augmentation point. All nodes
12051>>>>>    // within an xml document come here to get a class. So, if you want to augment and return a
12051>>>>>    // different class, just check the node type and return whatever -- else forward
12051>>>>>    
12051>>>>>    Function NodeClassId Integer iType Returns Integer
12053>>>>>        Integer iClassId
12053>>>>>        Case Begin
12053>>>>>            Case (iType=NODE_ELEMENT) ;                Move U_cXMLDOMElement      to iClassId
12056>>>>>            Case (iType=NODE_ATTRIBUTE) ;                Move U_cXMLDOMAttribute    to iClassId
12060>>>>>            Case (iType=NODE_TEXT) ;                Move U_cXMLDOMTextNode     to iClassId
12064>>>>>            Case (iType=NODE_CDATA_SECTION) ;                Move U_cXMLDOMCDATASection to iClassId
12068>>>>>            Case (iType=NODE_ENTITY_REFERENCE) ;                Move U_cXMLDOMEntityReference to iClassId
12072>>>>>            Case (iType=NODE_ENTITY) ;                Move U_cXMLDOMEntity       to iClassId
12076>>>>>            Case (iType=NODE_PROCESSING_INSTRUCTION) ;                Move U_cXMLDOMProcessingInstruction to iClassId
12080>>>>>            Case (iType=NODE_COMMENT) ;                Move U_cXMLDOMComment      to iClassId
12084>>>>>            Case (iType=NODE_DOCUMENT) ;                Move U_cXMLDOMDocument     to iClassId
12088>>>>>            Case (iType=NODE_DOCUMENT_TYPE) ;                Move U_cXMLDOMDocumentType to iClassId
12092>>>>>            Case (iType=NODE_DOCUMENT_FRAGMENT) ;                Move U_cXMLDOMDocumentFragment to iClassId
12096>>>>>            Case (iType=NODE_NOTATION) ;                Move U_cXMLDOMNotation     to iClassId
12100>>>>>            Case (iType=0) ;                Move 0                     to iClassId // this is an error!!
12104>>>>>            Case Else ;                Move U_cXMLDOMNode         to iClassId
12106>>>>>        Case End
12106>>>>>        Function_Return iClassId
12107>>>>>    End_Function
12108>>>>>    
12108>>>>>    // Load an XML Document. The name of the document is stored in a property
12108>>>>>    // that must be set for this function to work correctly.
12108>>>>>    
12108>>>>>    Function LoadXMLDocument Returns Integer
12110>>>>>        String sDocumentName
12110>>>>>        Integer bRetVal
12110>>>>>        Get psDocumentName to sDocumentName
12111>>>>>        Get LoadDocument sDocumentName to bRetVal
12112>>>>>        If (bRetVal = 0);            Function_Return True
12115>>>>>        Else;            Function_Return False
12117>>>>>    End_Function
12118>>>>>    
12118>>>>>    Function SaveXMLDocument Returns Integer
12120>>>>>        String sDocumentName
12120>>>>>        Integer bRetVal
12120>>>>>        Get psDocumentName to sDocumentName
12121>>>>>        Get SaveDocument sDocumentName to bRetVal
12122>>>>>        Function_Return bRetVal
12123>>>>>    End_Function
12124>>>>>    
12124>>>>>    // Load an XML from a string. This aguments the C message to ret 1 if Ok and 0 if error.
12124>>>>>    //
12124>>>>>    Function LoadXML String sXML Returns Integer
12126>>>>>        Integer bRetVal
12126>>>>>        // for some reason the parser will not work properly with embedded double quotes.
12126>>>>>        // Change all " to ' in document.
12126>>>>>        //Move (replaces('"',sXML,"'")) to sXML  // removed this. Bad Idea.
12126>>>>>        Forward Get LoadXml sXML to bRetVal
12128>>>>>        If (bRetVal = 0) ;            Function_Return True
12131>>>>>        Else;            Function_Return False
12133>>>>>    End_Function
12134>>>>>    
12134>>>>>    // Load an XML string from an address. This aguments the C message to ret 1 if Ok and 0 if error.
12134>>>>>    //
12134>>>>>    Function LoadXMLFromAddress Address pXML Returns Integer
12136>>>>>        Integer bRetVal
12136>>>>>        Forward Get LoadXmlFromAddress pXML to bRetVal
12138>>>>>        If (bRetVal = 0) ;            Function_Return True
12141>>>>>        Else;            Function_Return False
12143>>>>>    End_Function
12144>>>>>    
12144>>>>>    
12144>>>>>    // Allow Nodes and Node node lists to get the parent document.
12144>>>>>    
12144>>>>>    Function DocumentObject Returns Handle
12146>>>>>        Function_Return Self
12147>>>>>    End_Function
12148>>>>>    
12148>>>>>    // Access to the root node allows for searches and iterations.
12148>>>>>    // The root node is a cNode.
12148>>>>>    
12148>>>>>    Function DocumentElement Returns Handle
12150>>>>>        Handle hNewNode       // Object ID of Root Node
12150>>>>>        Handle infcNode   // XML Element Interface
12150>>>>>        Get phDocumentElement to infcNode
12151>>>>>        If infcNode Begin
12153>>>>>            Get CreateXMLObject U_cXMLDOMElement infcNode to hNewNode
12154>>>>>            Set phPrivateDocumentElement to hNewNode // we no longer use this at all
12155>>>>>        End
12155>>>>>>
12155>>>>>        Function_Return hNewNode
12156>>>>>    End_Function
12157>>>>>    
12157>>>>>    //  CreateRootNode is used to set up the first element in a document.
12157>>>>>    //  It should only be used when creating new files.
12157>>>>>    
12157>>>>>    Function CreateDocumentElement String sTagName Returns Handle
12159>>>>>        Handle hNewNode       // Object ID of Root Node
12159>>>>>        Handle infcNode   // XML Element Interface
12159>>>>>        // Call XML to create an element in the document.
12159>>>>>        Get CreateElement sTagName to infcNode
12160>>>>>        // Tie the element interface to the DataFlex object.
12160>>>>>        If infcNode ;            Get CreateXMLObject U_cXMLDOMElement infcNode to hNewNode
12163>>>>>        // Call XML to set the root element of the document.
12163>>>>>        Set phDocumentElement to infcNode
12164>>>>>        Set phPrivateDocumentElement to hNewNode
12165>>>>>        Function_Return hNewNode
12166>>>>>    End_Function
12167>>>>>    
12167>>>>>    Function CreateDocumentElementNS String sNamespace String sTagName Returns Handle
12169>>>>>        Handle hNewNode       // Object ID of Root Node
12169>>>>>        Handle infcNode iType  // XML Element Interface
12169>>>>>        Get CreateElementNodeNS sNameSpace sTagName "" to hNewNode
12170>>>>>        Get XmlInterface of hNewNode to infcNode
12171>>>>>        Set phDocumentElement to infcNode
12172>>>>>        Set phPrivateDocumentElement to hNewNode
12173>>>>>        Function_Return hNewNode
12174>>>>>    End_Function
12175>>>>>    
12175>>>>>    
12175>>>>>    
12175>>>>>    // return the DocType as a document-type object. Returns 0 if no dtd
12175>>>>>    // Access to information from the doc type object is limited. Use get psXML
12175>>>>>    Function DocTypeNode Returns Handle
12177>>>>>        Handle hinfcDocType hoDocType
12177>>>>>        Get phDocType to hinfcDocType
12178>>>>>        If hinfcDocType ;            Get CreateXMLObject U_cXMLDOMDocumentType hinfcDocType to hoDocType
12181>>>>>        Function_Return hoDocType
12182>>>>>    End_Function
12183>>>>>    
12183>>>>>    Function phXMLErrorObject Returns Handle
12185>>>>>        Handle hoParseErrorObject
12185>>>>>        Handle hInfcParseError
12185>>>>>        Get phParseError to hInfcParseError
12186>>>>>        If hInfcParseError ;            Get CreateXMLObject U_cXMLDOMParseError hinfcParseError to hoParseErrorObject
12189>>>>>        Function_Return hoParseErrorObject
12190>>>>>    End_Function
12191>>>>>    
12191>>>>>    //  The following procedure is meant to be overridden by one provided by the developer.
12191>>>>>    
12191>>>>>    Procedure BasicParseErrorReport
12193>>>>>        String sProblem
12193>>>>>        String sLinePosition
12193>>>>>        String sDescr
12193>>>>>        String sReason
12193>>>>>        String sSource
12193>>>>>        Handle hoParseErrorObject
12193>>>>>        Get phXMLErrorObject to hoParseErrorObject
12194>>>>>        If hoParseErrorObject Begin
12196>>>>>            Move (SFormat(C_$CannotLoad, psDocumentName(Self)) + "."+character(13)+character(10)) to sProblem
12197>>>>>            Move (SFormat(C_$ParsingError, piLine(hoParseErrorObject), piLinePos(hoParseErrorObject))) to sLinePosition
12198>>>>>            Move (sLinePosition +character(13)+character(10)) to sLinePosition
12199>>>>>            
12199>>>>>            Move (C_$Reason + ":" * (psReason(hoParseErrorObject))  +character(13)+character(10)) to sReason
12200>>>>>            Move (C_$Source + ":" * (psSrcText(hoParseErrorObject))) to sSource
12201>>>>>            Move (sProblem + sLinePosition + sReason + sSource) to sDescr
12202>>>>>            Error DFERR_XML_INTERNAL_ERROR sDescr
12203>>>>>>
12203>>>>>            Send Destroy of hoParseErrorObject
12204>>>>>        End
12204>>>>>>
12204>>>>>        Else ;            Error DFERR_XML_INTERNAL_ERROR C_$NotCreatedParseObject
12206>>>>>    End_Procedure
12207>>>>>    
12207>>>>>    // bind an xml interface node to the passed XML object. If the
12207>>>>>    // object type is of the wrong type, we will destroy it and recreate it
12207>>>>>    // which is why hoNode is passed byRef.
12207>>>>>    // to use this you'd have to use the lower level private messages to get the
12207>>>>>    // xml interface handles and then bind them to an object. Just like in COM you could
12207>>>>>    // bind these to the same object, which might save some parsing time. This is made private
12207>>>>>    // because the time savings would probably be small and would not justify the extra
12207>>>>>    // complexity.
12207>>>>>    // It is a programming error to pass this a zero handle.
12207>>>>>    Procedure BindXMLInfc Handle hInfc Handle ByRef hoNode
12209>>>>>        Integer iType iClassId iType2
12209>>>>>        Get piNodeType of hoNode to iType2 // type of the DF XML object
12210>>>>>        
12210>>>>>        // Get the node type of the infc handle w/o creating a DF object
12210>>>>>        Move (invokexml(DF_IXMLDOMNODE, GET_piNodeType, hinfc, 0, 0, 0, 0)) to iType
12211>>>>>        Move (invokexml(DF_IXMLDOMNODE, GET_ChangeNodeType, hinfc, iType, 1, 0, 0)) to hInfc
12212>>>>>        If (hinfc=0) Begin
12214>>>>>            // this should not happen and we would need to know about this.
12214>>>>>            Error DFERR_XML_INTERNAL_ERROR (C_$XmlFailedNoDocObject + String(iType))
12215>>>>>>
12215>>>>>            Procedure_Return 0
12216>>>>>        End
12216>>>>>>
12216>>>>>        // if the type is the same we can reuse the current object and binding it to the interface pointer
12216>>>>>        If (iType=iType2) Begin
12218>>>>>            // resuse Self and return
12218>>>>>            Set XMLInterface of hoNode to hInfc
12219>>>>>        End
12219>>>>>>
12219>>>>>        // if diffrent type, destroy the existing object and recreate it
12219>>>>>        Else Begin
12220>>>>>            Send Destroy of hoNode
12221>>>>>            Get NodeClassId iType to iClassId
12222>>>>>            Get CreateXMLObject iClassId hInfc to hoNode
12223>>>>>        End
12223>>>>>>
12223>>>>>    End_Procedure
12224>>>>>    
12224>>>>>    Function ValidateDocument Returns Handle
12226>>>>>        Handle hParseErrorIntf hoParseError
12226>>>>>        Forward Get ValidateDocument to hParseErrorIntf
12228>>>>>        If hParseErrorIntf Begin
12230>>>>>            Get CreateXMLObject U_cXMLDOMParseError hParseErrorIntf to hoParseError
12231>>>>>        End
12231>>>>>>
12231>>>>>        Function_Return hoParseError
12232>>>>>    End_Function
12233>>>>>    
12233>>>>>    Function AddExternalSchemaDocument String sSchema Handle hoSchema Returns Boolean
12235>>>>>        Handle hInfc
12235>>>>>        Boolean bOk
12235>>>>>        Get XmlInterface of hoSchema to hInfc
12236>>>>>        Forward Get AddExternalSchemaDocument sSchema hInfc to bOk
12238>>>>>        Function_Return (not(bOk))
12239>>>>>    End_Function
12240>>>>>    
12240>>>>>    Function AddExternalSchemaFile String sSchema String sFile Returns Boolean
12242>>>>>        Boolean bOk
12242>>>>>        Forward Get AddExternalSchemaFile sSchema sFile to bOk
12244>>>>>        Function_Return (not(bOk))
12245>>>>>    End_Function
12246>>>>>    
12246>>>>>    Procedure Set psSelectionNamespaces String sNamespaces
12248>>>>>        Set psDomSecondLevelProperty "SelectionNamespaces" to sNamespaces
12249>>>>>    End_Procedure
12250>>>>>    
12250>>>>>    Function psSelectionNamespaces Returns String
12252>>>>>        String  sNamespaces
12252>>>>>        Get psDomSecondLevelProperty "SelectionNamespaces" to sNamespaces
12253>>>>>        Function_Return sNamespaces
12254>>>>>    End_Function
12255>>>>>    
12255>>>>>    Procedure Set pbMultipleErrorMessages Boolean bMultipleErrors
12257>>>>>        Set pbDomSecondLevelProperty "MultipleErrorMessages" to bMultipleErrors
12258>>>>>    End_Procedure
12259>>>>>    
12259>>>>>    Function pbMultipleErrorMessages Returns Boolean
12261>>>>>        Boolean bMultipleErrors
12261>>>>>        Get pbDomSecondLevelProperty "MultipleErrorMessages" to bMultipleErrors
12262>>>>>        Function_Return bMultipleErrors
12263>>>>>    End_Function
12264>>>>>    
12264>>>>>    Procedure ErrorCreatingXMLObject
12266>>>>>        Error DFERR_XML_INTERNAL_ERROR "Could not create XML COM object. MSXML6 may not be properly installed and registered."
12267>>>>>>
12267>>>>>    End_Procedure
12268>>>>>    
12268>>>>>    // returns the last parse error. If 0, you know everything parsed. This can be
12268>>>>>    // used along wit pbReadyState to load XML documents in async mode.
12268>>>>>    Function LastParseError Returns Integer
12270>>>>>        Integer iErr
12270>>>>>        Handle hoParseErrorReport
12270>>>>>        Get phXMLErrorObject to hoParseErrorReport
12271>>>>>        Get piErrorCode of hoParseErrorReport to iErr
12272>>>>>        Send Destroy of hoParseErrorReport
12273>>>>>        Function_Return iErr
12274>>>>>    End_Function
12275>>>>>    
12275>>>>>    
12275>>>>>End_Class
12276>>>Use WinKern.pkg
12276>>>Use cThriftlyService.pkg
Including file: cThriftlyService.pkg    (C:\Users\marce\OneDrive\Documentos\Thriftly Developer\Dataflex\Library_x64\AppSrc\cThriftlyService.pkg)
12276>>>>>Use UI
12276>>>>>
12276>>>>>Object oSessionManager is a cObject
12278>>>>>End_Object
12279>>>>>
12279>>>>>Class cThriftlyService is a cComEvoServiceRuntime
12280>>>>>    
12280>>>>>    Procedure Construct_Object
12282>>>>>        // The cBaseWebService class is not used to run Thriftly, it's used to help
12282>>>>>        // analyze the exposed functions.
12282>>>>>        Property Handle phoBaseWebService (Create(Self, U_cBaseWebService))
12283>>>>>        Property Handle phoSessionManager
12284>>>>>        Property String psServiceName ""
12285>>>>>        Property String psCustomErrorStructName ""
12286>>>>>        Property Handle  Main_DD 0
12287>>>>>        Property Boolean pbDefaultSecured True
12288>>>>>        Forward Send Construct_Object
12290>>>>>        
12290>>>>>        Set phoSessionManager to oSessionManager
12291>>>>>    End_Procedure
12292>>>>>    
12292>>>>>    Procedure Custom_Error_Report Handle hoRuntime ErrorData errinfo
12294>>>>>        Send ComSetErrorInfoWithData of hoRuntime errinfo.Description errinfo
12295>>>>>    End_Procedure
12296>>>>>    
12296>>>>>    Procedure End_Construct_Object
12298>>>>>        Forward Send End_Construct_Object
12300>>>>>        If (psServiceName(Self) = "") Begin
12302>>>>>            // If the first character is a lowercase "o" and the next letter is uppercase, then this is probably camel case hungarian notation
12302>>>>>            // so fix it up.
12302>>>>>            If (Left(Object_Label(Self), 1) = "o" and ("ABCDEFGHIJKLMNOPQRSTUVWXYZ" contains Mid(Object_Label(Self), 1, 2))) ;                Set psServiceName to (Remove(Object_Label(Self), 1, 1))
12305>>>>>            Else Set psServiceName to (Object_Label(Self)) 
12307>>>>>        End
12307>>>>>>
12307>>>>>        Send RegisterService of (Parent(Self)) Self
12308>>>>>    End_Procedure
12309>>>>>
12309>>>>>    Procedure RegisterInterface Integer iMsg String sMsgName String sParams String sComment Integer llFlags
12311>>>>>        // Evolution is case insensitive.
12311>>>>>        Move (Lowercase(sParams)) to sParams
12312>>>>>        Send RegisterInterface of (phoBaseWebService(Self)) iMsg (String(llFlags) + sMsgName) sParams sComment
12313>>>>>    End_Procedure
12314>>>>>    
12314>>>>>    Procedure Set CustomErrorObject String struct_name
12316>>>>>        Integer cnt
12316>>>>>        ServiceErrorType[] sets
12316>>>>>        ServiceErrorType[] sets
12317>>>>>        
12317>>>>>        Set psCustomErrorStructName to struct_name
12318>>>>>        Get pServicesCustomErrorTypes of (Parent(Self)) to sets
12319>>>>>        Move (SizeOfArray(sets)) to cnt
12320>>>>>        Move (psServiceName(Self)) to sets[cnt].serviceName
12321>>>>>        Move (struct_name) to sets[cnt].customErrorStructName
12322>>>>>        Set pServicesCustomErrorTypes of (Parent(Self)) to sets
12323>>>>>        
12323>>>>>        Send RegisterInterface of (phoBaseWebService(Self)) 0 "THRIFTLY_ERROR" (struct_name + " param") "" 
12324>>>>>    End_Procedure
12325>>>>>
12325>>>>>    Function CompareVariantStrings Variant val1 Variant val2 Returns Integer
12327>>>>>        If  (String(val1) = String (val2)) Function_Return (EQ)
12330>>>>>    End_Function
12331>>>>>    
12331>>>>>    Procedure ProcessInterfaces Handle hoEvoInterface Handle hoServiceBuilder Handle hoStructBuilder Handle hoTypeBuilder
12333>>>>>        Integer iMsgCount iMsgLoop iParamCount iParamLoop iType iArrayIndex iDim iMsgId iFlags
12333>>>>>        String sMsgName sParamName sReturnType sParamTypeName
12333>>>>>        String sErrorMessage
12333>>>>>        Handle hoWS
12333>>>>>        Handle hoDocObj
12333>>>>>        Variant[][] vStructs
12334>>>>>        Variant vPrototype
12334>>>>>        Variant vType
12334>>>>>        
12334>>>>>        Get phoBaseWebService to hoWS
12335>>>>>        Move (oThriftlyDocumentation(Self)) to hoDocObj
12336>>>>>        
12336>>>>>        Get ProcessTypes of (Parent(Self)) hoWS hoEvoInterface hoStructBuilder hoTypeBuilder to vStructs
12337>>>>>        
12337>>>>>        Get InterfaceMessageCount of hoWS to iMsgCount
12338>>>>>        
12338>>>>>        For iMsgLoop from 0 to (iMsgCount-1)
12344>>>>>>
12344>>>>>            Get InterfaceMessageParamCount of hoWS iMsgLoop to iParamCount
12345>>>>>            Get InterfaceMessageName of hoWS iMsgLoop to sMsgName
12346>>>>>            If (trim(uppercase(sMsgName)) = "THRIFTLY_ERROR") Break Begin
12349>>>>>
12349>>>>>            Get FindMessageID of hoWS sMsgName to iMsgId
12350>>>>>
12350>>>>>            Move (Integer(Left(sMsgName, 1))) to iFlags
12351>>>>>            Move (Mid(sMsgName, Length(sMsgName)-1, 2)) to sMsgName
12352>>>>>
12352>>>>>            Set pvComObject of hoStructBuilder to (ComNewStruct(hoEvoInterface))
12353>>>>>            
12353>>>>>// I'm using FindMessageID a few lines earlier instead of InterfaceMessageID because starting with DF20
12353>>>>>// this call causes a crash for some unknown reason. - OLI
12353>>>>>//            Get InterfaceMessageId of hoWS iMsgLoop to iMsgId
12353>>>>>            Send ComAddPrivateField of hoStructBuilder 1 "MessageId" "" (ComCreateInt32(hoTypeBuilder)) iMsgId
12354>>>>>            Send ComAddPrivateField of hoStructBuilder 2 "MessageName" "" (ComCreateString(hoTypeBuilder)) sMsgName
12355>>>>>            
12355>>>>>            // Because of the private fields, we need to add 2 to iParamLoop where it is used to add a field...
12355>>>>>            For iParamLoop from 1 to iParamCount
12361>>>>>>
12361>>>>>                Get InterfaceMessageParamType of hoWS iMsgLoop (iParamLoop-1) to iType
12362>>>>>                Get InterfaceMessageParamName of hoWS iMsgLoop (iParamLoop-1) to sParamName
12363>>>>>                Get InterfaceMessageParamTypeName of hoWS iMsgLoop (iParamLoop-1) to sParamTypeName
12364>>>>>                Get InterfaceMessageParamDimCount of hoWS iMsgLoop (iParamLoop-1) to iDim
12365>>>>>                
12365>>>>>                Case Begin
12365>>>>>                    Case (iType = xsBoolean or iType = xsBit)
12367>>>>>                        If (iDim = 0) Get ComCreateBool of hoTypeBuilder to vType
12370>>>>>                        Else Move (ComCreateList(hoTypeBuilder, ComCreateBool(hoTypeBuilder))) to vType
12372>>>>>                        Case Break
12373>>>>>                    Case (iType = xsUchar)
12376>>>>>                        If (iDim = 0) Get ComCreateByte of hoTypeBuilder to vType
12379>>>>>                        Else Move (ComCreateBinary(hoTypeBuilder)) to vType
12381>>>>>                        Case Break
12382>>>>>                    Case (iType = xsShort)
12385>>>>>                        If (iDim = 0) Get ComCreateInt16 of hoTypeBuilder to vType
12388>>>>>                        Else Move (ComCreateList(hoTypeBuilder, ComCreateInt16(hoTypeBuilder))) to vType
12390>>>>>                        Case Break
12391>>>>>                    Case (iType = xsInteger  or iType = 26)  // Thriftly.x64 TEMPORARY code
12394>>>>>                        If (iDim = 0) Get ComCreateInt32 of hoTypeBuilder to vType
12397>>>>>                        Else Move (ComCreateList(hoTypeBuilder, ComCreateInt32(hoTypeBuilder))) to vType
12399>>>>>                        Case Break
12400>>>>>                    Case (iType = xsBigint)
12403>>>>>                        If (iDim = 0) Get ComCreateInt64 of hoTypeBuilder to vType
12406>>>>>                        Else Move (ComCreateList(hoTypeBuilder, ComCreateInt64(hoTypeBuilder))) to vType
12408>>>>>                        Case Break
12409>>>>>                    Case (iType = xsNumber or iType = xsDecimal)
12412>>>>>                        If (iDim = 0) Get ComCreateDecimal of hoTypeBuilder to vType
12415>>>>>                        Else Begin
12416>>>>>                            Error 301 ("The data type of the parameter " * sParamName * "(" + sParamTypeName + "[ ])" * "in" * sMsgName * "is unsupported in Thriftly. Please consider using a REAL[ ] type instead. Program will now abort.")
12417>>>>>>
12417>>>>>                            Abort
12418>>>>>>
12418>>>>>                        End
12418>>>>>>
12418>>>>>                        Case Break
12419>>>>>                    Case (iType = xsReal or iType = xsFloat)
12422>>>>>                        If (iDim = 0) Get ComCreateDouble of hoTypeBuilder to vType
12425>>>>>                        Else Move (ComCreateList(hoTypeBuilder, ComCreateDouble(hoTypeBuilder))) to vType
12427>>>>>                        Case Break
12428>>>>>                    Case (iType = xsDate)
12431>>>>>                        If (iDim = 0) Get ComCreateDate of hoTypeBuilder to vType
12434>>>>>                        Else Move (ComCreateList(hoTypeBuilder, ComCreateDate(hoTypeBuilder))) to vType
12436>>>>>                        Case Break
12437>>>>>                    Case (iType = xsDatetime)
12440>>>>>                        If (iDim = 0) Get ComCreateDateTime of hoTypeBuilder to vType
12443>>>>>                        Else Move (ComCreateList(hoTypeBuilder, ComCreateDateTime(hoTypeBuilder))) to vType
12445>>>>>                        Case Break
12446>>>>>                    Case (iType = xsString)
12449>>>>>                        If (iDim = 0) Get ComCreateString of hoTypeBuilder to vType
12452>>>>>                        Else Move (ComCreateList(hoTypeBuilder, ComCreateString(hoTypeBuilder))) to vType
12454>>>>>                        Case Break
12455>>>>>                    Case (iType = xsStruct)
12458>>>>>                        Move (SearchArray(sParamTypeName, vStructs[0], Self, GET_CompareVariantStrings)) to iArrayIndex
12459>>>>>                        If (iDim = 0) Move vStructs[1][iArrayIndex] to vType
12462>>>>>                        Else Move (ComCreateList(hoTypeBuilder, vStructs[1][iArrayIndex])) to vType
12464>>>>>                        Case Break
12465>>>>>                    Case Else
12465>>>>>                        Error 300 ("The data type of the parameter " * sParamName * "(" + sParamTypeName + ")" * "in" * sMsgName * "is unsupported in Thriftly. Please choose a different data type. Program will now abort.")
12466>>>>>>
12466>>>>>                        Abort
12467>>>>>>
12467>>>>>                Case End
12467>>>>>                Send ComAddField of hoStructBuilder (iParamLoop+2) sParamName (ParameterDescription(hoDocObj, psServiceName(Self), sMsgName, sParamName)) vType True
12468>>>>>            Loop
12469>>>>>>
12469>>>>>
12469>>>>>            // Now that we've processed all the parameters, it's time to create the function/procedure definition and deal with the return type.
12469>>>>>
12469>>>>>            Move (Remove(sMsgName, 1, 4)) to sMsgName  // this removes the get_ or msg_
12470>>>>>            Get InterfaceMessageParamTypeName of hoWS iMsgLoop iParamCount to sReturnType
12471>>>>>            Get InterfaceMessageParamType of hoWS iMsgLoop iParamCount to iType
12472>>>>>            Get InterfaceMessageParamName of hoWS iMsgLoop iParamCount to sParamName
12473>>>>>            Get InterfaceMessageParamDimCount of hoWS iMsgLoop iParamCount to iDim
12474>>>>>            Get ComCreatePrototype of hoStructBuilder to vPrototype
12475>>>>>            If (iType = -1) Begin
12477>>>>>                // This means we have a procedure, not a function, so no return type
12477>>>>>                Send ComAddProcedure to hoServiceBuilder (iMsgLoop+1) sMsgName (MethodDescription(hoDocObj, psServiceName(Self), sMsgName)) vPrototype iFlags
12478>>>>>            End
12478>>>>>>
12478>>>>>            Else Begin
12479>>>>>                Case Begin
12479>>>>>                    Case (iType = xsBoolean or iType = xsBit)
12481>>>>>                        If (iDim = 0) Get ComCreateBool of hoTypeBuilder to vType
12484>>>>>                        Else Move (ComCreateList(hoTypeBuilder, ComCreateBool(hoTypeBuilder))) to vType
12486>>>>>                        Case Break
12487>>>>>                    Case (iType = xsUchar)
12490>>>>>                        If (iDim = 0) Get ComCreateByte of hoTypeBuilder to vType
12493>>>>>                        Else Move (ComCreateBinary(hoTypeBuilder)) to vType
12495>>>>>                        Case Break
12496>>>>>                    Case (iType = xsShort)
12499>>>>>                        If (iDim = 0) Get ComCreateInt16 of hoTypeBuilder to vType
12502>>>>>                        Else Move (ComCreateList(hoTypeBuilder, ComCreateInt16(hoTypeBuilder))) to vType
12504>>>>>                        Case Break
12505>>>>>                    Case (iType = xsInteger or iType = 26)  // Thriftly.x64 TEMPORARY code
12508>>>>>                        If (iDim = 0) Get ComCreateInt32 of hoTypeBuilder to vType
12511>>>>>                        Else Move (ComCreateList(hoTypeBuilder, ComCreateInt32(hoTypeBuilder))) to vType
12513>>>>>                        Case Break
12514>>>>>                    Case (iType = xsBigint)
12517>>>>>                        If (iDim = 0) Get ComCreateInt64 of hoTypeBuilder to vType
12520>>>>>                        Else Move (ComCreateList(hoTypeBuilder, ComCreateInt64(hoTypeBuilder))) to vType
12522>>>>>                        Case Break
12523>>>>>                    Case (iType = xsNumber or iType = xsDecimal)
12526>>>>>                        If (iDim = 0) Get ComCreateDecimal of hoTypeBuilder to vType
12529>>>>>                        Else Begin
12530>>>>>                            Error 301 ("The return type of the function" * sMsgName * "(" + sReturnType + "[ ])" * "is unsupported in Thriftly. Please consider using a REAL[ ] type instead. Program will now abort.")
12531>>>>>>
12531>>>>>                            Abort
12532>>>>>>
12532>>>>>                        End
12532>>>>>>
12532>>>>>                        Case Break
12533>>>>>                    Case (iType = xsReal or iType = xsFloat)
12536>>>>>                        If (iDim = 0) Get ComCreateDouble of hoTypeBuilder to vType
12539>>>>>                        Else Move (ComCreateList(hoTypeBuilder, ComCreateDouble(hoTypeBuilder))) to vType
12541>>>>>                        Case Break
12542>>>>>                    Case (iType = xsDate)
12545>>>>>                        If (iDim = 0) Get ComCreateDate of hoTypeBuilder to vType
12548>>>>>                        Else Move (ComCreateList(hoTypeBuilder, ComCreateDate(hoTypeBuilder))) to vType
12550>>>>>                        Case Break
12551>>>>>                    Case (iType = xsDatetime)
12554>>>>>                        If (iDim = 0) Get ComCreateDateTime of hoTypeBuilder to vType
12557>>>>>                        Else Move (ComCreateList(hoTypeBuilder, ComCreateDateTime(hoTypeBuilder))) to vType
12559>>>>>                        Case Break
12560>>>>>                    Case (iType = xsString)
12563>>>>>                        If (iDim = 0) Get ComCreateString of hoTypeBuilder to vType
12566>>>>>                        Else Move (ComCreateList(hoTypeBuilder, ComCreateString(hoTypeBuilder))) to vType
12568>>>>>                        Case Break
12569>>>>>                    Case (iType = xsStruct)
12572>>>>>                        Move (SearchArray(sReturnType, vStructs[0], Self, GET_CompareVariantStrings)) to iArrayIndex
12573>>>>>                        If (iDim = 0) Move vStructs[1][iArrayIndex] to vType
12576>>>>>                        Else Move (ComCreateList(hoTypeBuilder, vStructs[1][iArrayIndex])) to vType
12578>>>>>                        Case Break
12579>>>>>                    Case Else
12579>>>>>                        Error 300 ("The return type of the function " * sMsgName * "(" + sReturnType + ")" * "is unsupported in Thriftly. Please choose a different data type. Program will now abort.")
12580>>>>>>
12580>>>>>                        Abort
12581>>>>>>
12581>>>>>                Case End
12581>>>>>    
12581>>>>>                Send ComAddFunction to hoServiceBuilder (iMsgLoop+1) sMsgName (MethodDescription(hoDocObj, psServiceName(Self), sMsgName)) vType (ReturnDescription(hoDocObj, psServiceName(Self), sMsgName)) vPrototype iFlags
12582>>>>>            End
12582>>>>>>
12582>>>>>        Loop
12583>>>>>>
12583>>>>>    End_Procedure
12584>>>>>
12584>>>>>    Procedure ServiceException String error_message ErrorData exception
12586>>>>>        String[] callstack
12587>>>>>        String sCallstack call loc
12587>>>>>        Variant vRuntime
12587>>>>>        Handle hoRuntime
12587>>>>>        
12587>>>>>        Get ComRuntime to vRuntime
12588>>>>>        Get Create U_cComIEvoRuntime to hoRuntime
12589>>>>>        Set pvComObject of hoRuntime to vRuntime
12590>>>>>
12590>>>>>        // We don't EVER want a callstack in these types of errors, so empty out the array
12590>>>>>        Move (ResizeArray(exception.CallStack, 0)) to exception.CallStack
12591>>>>>
12591>>>>>        CallStackDump sCallStack
12592>>>>>        Get StringToArray of Error_object_ID sCallStack C_CRLF to callstack
12593>>>>>        
12593>>>>>        // The Second item ([1]) in the array will be the function that threw the error
12593>>>>>        // since this function was called from there. The first 4 characters are always
12593>>>>>        // "GET_" or "MSG_", so we remove those. And then we want the name of the
12593>>>>>        // function or procedure, so cut that part out. We also want the "address" at
12593>>>>>        // the end which is the line of code that threw the exception.
12593>>>>>        Move (Remove(callstack[1], 1, 4)) to call
12594>>>>>        Move (Left(call, Pos(" ", call)-1)) to exception.CallStack[0]
12595>>>>>        Move (Right(call, length(call) - RightPos(" ", call))) to loc
12596>>>>>        Move (Integer(loc)) to exception.LineNumber
12597>>>>>        
12597>>>>>        // For Service Exceptions we always consider them "handled", so make sure it is marked that way
12597>>>>>        Move False to exception.Unhandled
12598>>>>>        
12598>>>>>        Send ComSetErrorInfoWithData of hoRuntime error_message exception
12599>>>>>
12599>>>>>        Set pvComObject of hoRuntime to (NullComObject())
12600>>>>>        Send Destroy_Object of hoRuntime
12601>>>>>    End_Procedure
12602>>>>>    
12602>>>>>    Procedure EventDispatcher Integer iMsgId String sMsgName Variant vParam1 Variant vParam2 Variant vParam3 Variant vParam4 ;                              Variant vParam5 Variant vParam6 Variant vParam7 Variant vParam8 Variant vParam9 Variant vParam10 ;                              Variant vParam11 Variant vParam12 Variant vParam13 Variant vParam14
12604>>>>>        String get_or_msg
12604>>>>>        Integer iType
12604>>>>>        Variant vElement
12604>>>>>        
12604>>>>>        // This very unusual line of code is to fix a bug where DataFlex loses the DATE4_STATE setting when in a reentrant
12604>>>>>        // windows message. The setting is restored after the com event finishes. This is based on customer report and 
12604>>>>>        // this thread:
12604>>>>>        //
12604>>>>>        // http://support.dataaccess.com/Forums/showthread.php?34372-This-is-how-users-can-enter-dates-with-2-digit-years
12604>>>>>        //
12604>>>>>        // Thank you Jorgen Munster for your sleuthing. - OLI
12604>>>>>        //
12604>>>>>        Set_Date_Attribute Date4_State to True
WARNING: 4533 Obsolete command: Set_Date_Attribute. Use Set_Attribute DF_DATE_FORMAT ON LINE: 293 (12604) OF FILE: C:\Users\marce\OneDrive\Documentos\Thriftly Developer\Dataflex\Library_x64\AppSrc\cThriftlyService.pkg
12605>>>>>        
12605>>>>>        Move Self to EVO_CURRENT_SERVICE
12606>>>>>        
12606>>>>>        If (num_arguments = 2) Begin
12608>>>>>            // this can only be a procedure with 2 argument, nothing returned, nothing sent
12608>>>>>            Send iMsgId  
12609>>>>>            Procedure_Return
12610>>>>>        End
12610>>>>>>
12610>>>>>        Move (Left(sMsgName, 3)) to get_or_msg
12611>>>>>        
12611>>>>>        If (num_arguments = 3) Begin
12613>>>>>            If (get_or_msg = "get") Get iMsgId to vParam1
12616>>>>>            Else Send iMsgId vParam1
12618>>>>>            
12618>>>>>            Procedure_Return
12619>>>>>        End
12619>>>>>>
12619>>>>>        If (num_arguments = 4) Begin
12621>>>>>            If (get_or_msg = "get") Get iMsgId vParam1 to vParam2
12624>>>>>            Else Send iMsgId vParam1 vParam2
12626>>>>>            
12626>>>>>            Procedure_Return 
12627>>>>>        End
12627>>>>>>
12627>>>>>        If (num_arguments = 5) Begin
12629>>>>>            If (get_or_msg = "get") Get iMsgId vParam1 vParam2 to vParam3
12632>>>>>            Else Send iMsgId vParam1 vParam2 vParam3
12634>>>>>
12634>>>>>            Procedure_Return 
12635>>>>>        End
12635>>>>>>
12635>>>>>        If (num_arguments = 6) Begin
12637>>>>>            If (get_or_msg = "get") Get iMsgId vParam1 vParam2 vParam3 to vParam4
12640>>>>>            Else Send iMsgId vParam1 vParam2 vParam3 vParam4
12642>>>>>            
12642>>>>>            Procedure_Return 
12643>>>>>        End
12643>>>>>>
12643>>>>>        If (num_arguments = 7) Begin
12645>>>>>            If (get_or_msg = "get") Get iMsgId vParam1 vParam2 vParam3 vParam4 to vParam5
12648>>>>>            Else Send iMsgId vParam1 vParam2 vParam3 vParam4 vParam5
12650>>>>>            
12650>>>>>            Procedure_Return 
12651>>>>>        End
12651>>>>>>
12651>>>>>        If (num_arguments = 8) Begin
12653>>>>>            If (get_or_msg = "get") Get iMsgId vParam1 vParam2 vParam3 vParam4 vParam5 to vParam6
12656>>>>>            Else Send iMsgId vParam1 vParam2 vParam3 vParam4 vParam5 vParam6
12658>>>>>            
12658>>>>>            Procedure_Return 
12659>>>>>        End
12659>>>>>>
12659>>>>>        If (num_arguments = 9) Begin
12661>>>>>            If (get_or_msg = "get") Get iMsgId vParam1 vParam2 vParam3 vParam4 vParam5 vParam6 to vParam7
12664>>>>>            Else Send iMsgId vParam1 vParam2 vParam3 vParam4 vParam5 vParam6 vParam7
12666>>>>>            
12666>>>>>            Procedure_Return 
12667>>>>>        End
12667>>>>>>
12667>>>>>        If (num_arguments = 10) Begin
12669>>>>>            If (get_or_msg = "get") Get iMsgId vParam1 vParam2 vParam3 vParam4 vParam5 vParam6 vParam7 to vParam8
12672>>>>>            Else Send iMsgId vParam1 vParam2 vParam3 vParam4 vParam5 vParam6 vParam7 vParam8
12674>>>>>            
12674>>>>>            Procedure_Return 
12675>>>>>        End
12675>>>>>>
12675>>>>>        If (num_arguments = 11) Begin
12677>>>>>            If (get_or_msg = "get") Get iMsgId vParam1 vParam2 vParam3 vParam4 vParam5 vParam6 vParam7 vParam8 to vParam9
12680>>>>>            Else Send iMsgId vParam1 vParam2 vParam3 vParam4 vParam5 vParam6 vParam7 vParam8 vParam9
12682>>>>>            
12682>>>>>            Procedure_Return 
12683>>>>>        End
12683>>>>>>
12683>>>>>        If (num_arguments = 12) Begin
12685>>>>>            If (get_or_msg = "get") Get iMsgId vParam1 vParam2 vParam3 vParam4 vParam5 vParam6 vParam7 vParam8 vParam9 to vParam10
12688>>>>>            Else Send iMsgId vParam1 vParam2 vParam3 vParam4 vParam5 vParam6 vParam7 vParam8 vParam9 vParam10
12690>>>>>            
12690>>>>>            Procedure_Return 
12691>>>>>        End
12691>>>>>>
12691>>>>>        If (num_arguments = 13) Begin
12693>>>>>            If (get_or_msg = "get") Get iMsgId vParam1 vParam2 vParam3 vParam4 vParam5 vParam6 vParam7 vParam8 vParam9 vParam10 to vParam11
12696>>>>>            Else Send iMsgId vParam1 vParam2 vParam3 vParam4 vParam5 vParam6 vParam7 vParam8 vParam9 vParam10 vParam11
12698>>>>>            
12698>>>>>            Procedure_Return 
12699>>>>>        End
12699>>>>>>
12699>>>>>        If (num_arguments = 14) Begin
12701>>>>>            If (get_or_msg = "get") Get iMsgId vParam1 vParam2 vParam3 vParam4 vParam5 vParam6 vParam7 vParam8 vParam9 vParam10 vParam11 to vParam12
12704>>>>>            Else Send iMsgId vParam1 vParam2 vParam3 vParam4 vParam5 vParam6 vParam7 vParam8 vParam9 vParam10 vParam11 vParam12
12706>>>>>            
12706>>>>>            Procedure_Return 
12707>>>>>        End
12707>>>>>>
12707>>>>>        If (num_arguments = 15) Begin
12709>>>>>            If (get_or_msg = "get") Get iMsgId vParam1 vParam2 vParam3 vParam4 vParam5 vParam6 vParam7 vParam8 vParam9 vParam10 vParam11 vParam12 to vParam13
12712>>>>>            Else Send iMsgId vParam1 vParam2 vParam3 vParam4 vParam5 vParam6 vParam7 vParam8 vParam9 vParam10 vParam11 vParam12 vParam13
12714>>>>>            
12714>>>>>            Procedure_Return 
12715>>>>>        End
12715>>>>>>
12715>>>>>        If (num_arguments = 16) Begin
12717>>>>>            If (get_or_msg = "get") Get iMsgId vParam1 vParam2 vParam3 vParam4 vParam5 vParam6 vParam7 vParam8 vParam9 vParam10 vParam11 vParam12 vParam13 to vParam14
12720>>>>>            Else Send iMsgId vParam1 vParam2 vParam3 vParam4 vParam5 vParam6 vParam7 vParam8 vParam9 vParam10 vParam11 vParam12 vParam13 vParam14
12722>>>>>            
12722>>>>>            Procedure_Return 
12723>>>>>        End
12723>>>>>>
12723>>>>>    End_Procedure
12724>>>>>    
12724>>>>>    Procedure RegisterDynamicEvents
12726>>>>>        Handle hoWS
12726>>>>>        Integer iMsgCount iMsgLoop
12726>>>>>        String sMsgName
12726>>>>>        
12726>>>>>        Get phoBaseWebService to hoWS
12727>>>>>        Get InterfaceMessageCount of hoWS to iMsgCount
12728>>>>>        
12728>>>>>        For iMsgLoop from 0 to (iMsgCount-1)
12734>>>>>>
12734>>>>>            Send RegisterComEvent (iMsgLoop+1) msg_EventDispatcher
12735>>>>>        Loop
12736>>>>>>
12736>>>>>    End_Procedure
12737>>>>>
12737>>>>>    Function JWTPayload Returns Variant
12739>>>>>        Variant vPayload
12739>>>>>        Get JWTPayload of (Parent(Self)) to vPayload
12740>>>>>        Function_Return vPayload
12741>>>>>    End_Function
12742>>>>>    
12742>>>>>    Function JWSPayload Returns String
12744>>>>>        String sPayload
12744>>>>>        Get JWSPayload of (Parent(Self)) to sPayload
12745>>>>>        Function_Return sPayload
12746>>>>>    End_Function
12747>>>>>
12747>>>>>    Procedure Heartbeat 
12749>>>>>        Send Heartbeat of (Parent(Self)) 
12750>>>>>    End_Procedure
12751>>>>>
12751>>>>>End_Class
12752>>>
12752>>>Struct tMSG
12752>>>    Handle hWnd
12752>>>    Integer Message
12752>>>    DWord wParam
12752>>>    DWord lParam
12752>>>    DWord Time
12752>>>    Integer XCoord
12752>>>    Integer YCoord
12752>>>End_Struct
12752>>>
12752>>>//Struct tMSG
12752>>>//    Handle hWnd
12752>>>//    Integer Message
12752>>>//    DWord wParam
12752>>>//    DWord lParam
12752>>>//    DWord Time
12752>>>//    Integer XCoord
12752>>>//    Integer YCoord
12752>>>//End_Struct
12752>>>
12752>>>External_Function PeekMessage "PeekMessageA" User32.dll ;    Pointer lpMsgStruct;    Handle hWnd ;    UInteger MsgFilterMin ;    UInteger MsgFilterMax ;    UInteger RemoveMsg ;    Returns Integer
12753>>>
12753>>>                                                       
12753>>>    External_Function GetMessage "GetMessageA" User32.dll ;        Pointer lpMsgStruct;        Handle hWnd ;        UInteger MsgFilterMin ;        UInteger MsgFilterMax ;        Returns Integer
12754>>>
12754>>>External_Function TranslateMessage "TranslateMessage" User32.dll Pointer lpMsg Returns Integer
12755>>>
12755>>>External_Function DispatchMessage "DispatchMessageA" User32.dll Pointer lpMsg Returns Integer
12756>>>
12756>>>//External_Function DllCanUnloadNow "DllCanUnloadNow" C:\Evolution\Evolution.Interface\Release\Evolution.Interface.dll Returns Integer
12756>>>
12756>>>Class cThriftlyServer is a Array //cObject
12757>>>    
12757>>>    Procedure Construct_Object
12759>>>        Property Handle phoGenericAutomation (Create(Self, U_DfComAutomationObject))
12760>>>        
12760>>>        Property Handle phOldErrorObject
12761>>>        
12761>>>        Property Handle phoServer
12762>>>        
12762>>>        Property Handle[] phoServices
12763>>>        
12763>>>        Property Variant[][] pvStructs
12764>>>        
12764>>>        Property Handle phoErrorSys (Create(Self, U_cThriftlyErrorSystem))
12765>>>        
12765>>>        Property ServiceErrorType[] pServicesCustomErrorTypes
12766>>>        
12766>>>        Forward Send Construct_Object
12768>>>    End_Procedure
12769>>>    
12769>>>    Procedure RegisterService Handle hoService
12771>>>        Handle[] services
12772>>>        
12772>>>        Get phoServices to services
12773>>>        Move hoService to services[SizeOfArray(services)]
12774>>>        Set phoServices to services
12775>>>    End_Procedure
12776>>>
12776>>>    Function CompareVariantStrings Variant val1 Variant val2 Returns Integer
12778>>>        If (String(val1) = String (val2)) Function_Return (EQ)
12781>>>        Function_Return (0)
12782>>>    End_Function
12783>>>
12783>>>    Function ProcessType Handle hoBaseStructs Handle hoStructNode Variant[][] ByRef vStructs Handle hoEvoInterface Handle hoStructBuilder Handle hoTypeBuilder Returns Variant
12785>>>        String sStructName sElementName sElementType sElementArrayCount sElementTypeRef
12785>>>        String sErrorMessage
12785>>>        Integer iNodeListLength iNode iArrayIndex iStructNode
12785>>>        Handle hoNode hoChildStruct
12785>>>        Variant vStruct vThisStructBuilder vType
12785>>>        Variant[] temp
12786>>>        Handle hoDocObj
12786>>>        Move (oThriftlyDocumentation(Self)) to hoDocObj
12787>>>
12787>>>        Get AttributeValue of hoStructNode "name" to sStructName
12788>>>        
12788>>>        // Let's see if this Struct is already defined, if it is, just return it
12788>>>        Send Ignore_Error of Error_Object_Id 4509
12789>>>        Move False to err
12790>>>        Move vStructs[0] to temp
12791>>>        If (not(Err)) Begin
12793>>>            Send Trap_Error of Error_Object_Id 4509
12794>>>            Move (SearchArray(sStructName, vStructs[0], Self, GET_CompareVariantStrings)) to iArrayIndex
12795>>>            If (iArrayIndex > -1) Function_Return vStructs[1][iArrayIndex]
12798>>>        End
12798>>>>
12798>>>        
12798>>>        Send Trap_Error of Error_Object_Id 4509
12799>>>        
12799>>>        Set pvComObject of hoStructBuilder to (ComNewStruct(hoEvoInterface))
12800>>>        
12800>>>        Get ElementNodes of hoStructNode "*" to hoStructNode
12801>>>        Get NodeListLength of hoStructNode to iNodeListLength
12802>>>        
12802>>>        For iNode from 0 to (iNodeListLength-1)
12808>>>>
12808>>>            Get CollectionNode of hoStructNode iNode to hoNode
12809>>>            Get AttributeValue of hoNode "name" to sElementName
12810>>>            Get AttributeValue of hoNode "type" to sElementType
12811>>>            Get AttributeValue of hoNode "arrayDimCount" to sElementArrayCount
12812>>>            Get AttributeValue of hoNode "typeRef" to sElementTypeRef
12813>>>            
12813>>>            // If this class of data type is an array, then go through the supported types to map to Evolution.
12813>>>            // If the type isn't here AND it doesn't appear to be a struct, then throw a runtime message and quit.
12813>>>
12813>>>            Case Begin
12813>>>                Case (sElementType = "boolean")
12815>>>                    Move (ComCreateBool(hoTypeBuilder)) to vType
12816>>>                    If (sElementArrayCount <> "") Move (ComCreateList(hoTypeBuilder, vType)) to vType
12819>>>                    Case Break
12820>>>                Case (sElementType = "uchar" or sElementType = "char")
12823>>>                    If (sElementArrayCount <> "" and sElementType = "char") Begin
12825>>>                        Error 301 ("The data type of the element" * sElementName * "(" + sElementType + "[ ])" * "in" * sStructName * "is unsupported in Thriftly. Please consider using a REAL[ ] type instead. Program will now abort.")
12826>>>>
12826>>>                        Abort
12827>>>>
12827>>>                    End
12827>>>>
12827>>>                    If (sElementArrayCount <> "") Move (ComCreateBinary(hoTypeBuilder)) to vType
12830>>>                    Else Move (ComCreateByte(hoTypeBuilder)) to vType
12832>>>                    Case Break
12833>>>                Case (sElementType = "short")
12836>>>                    Move (ComCreateInt16(hoTypeBuilder)) to vType
12837>>>                    If (sElementArrayCount <> "") Move (ComCreateList(hoTypeBuilder, vType)) to vType
12840>>>                    Case Break
12841>>>                Case (sElementType = "integer")
12844>>>                    Move (ComCreateInt32(hoTypeBuilder)) to vType
12845>>>                    If (sElementArrayCount <> "") Move (ComCreateList(hoTypeBuilder, vType)) to vType
12848>>>                    Case Break
12849>>>                Case (sElementType = "bigint")
12852>>>                    Move (ComCreateInt64(hoTypeBuilder)) to vType
12853>>>                    If (sElementArrayCount <> "") Move (ComCreateList(hoTypeBuilder, vType)) to vType
12856>>>                    Case Break
12857>>>                Case (sElementType = "number" or sElementType = "decimal")
12860>>>                    If (sElementArrayCount <> "") Begin
12862>>>                        Error 301 ("The data type of the element" * sElementName * "(" + sElementType + "[ ])" * "in" * sStructName * "is unsupported in Thriftly. Please consider using a REAL[ ] type instead. Program will now abort.")
12863>>>>
12863>>>                        Abort
12864>>>>
12864>>>                    End
12864>>>>
12864>>>                    Else Move (ComCreateDecimal(hoTypeBuilder)) to vType
12866>>>                    Case Break
12867>>>                Case (sElementType = "real" or sElementType = "float")
12870>>>                    Move (ComCreateDouble(hoTypeBuilder)) to vType
12871>>>                    If (sElementArrayCount <> "") Move (ComCreateList(hoTypeBuilder, vType)) to vType
12874>>>                    Case Break
12875>>>                Case (sElementType = "date")
12878>>>                    Move (ComCreateDate(hoTypeBuilder)) to vType
12879>>>                    If (sElementArrayCount <> "") Move (ComCreateList(hoTypeBuilder, vType)) to vType
12882>>>                    Case Break
12883>>>                Case (sElementType = "datetime")
12886>>>                    Move (ComCreateDateTime(hoTypeBuilder)) to vType
12887>>>                    If (sElementArrayCount <> "") Move (ComCreateList(hoTypeBuilder, vType)) to vType
12890>>>                    Case Break
12891>>>                Case (sElementType = "string")
12894>>>                    Move (ComCreateString(hoTypeBuilder)) to vType
12895>>>                    If (sElementArrayCount <> "") Move (ComCreateList(hoTypeBuilder, vType)) to vType
12898>>>                    Case Break
12899>>>                Case (sElementTypeRef = "")
12902>>>                    Error 300 ("The data type of the element" * sElementName * "(" + sElementType + "[ ])" * "in" * sStructName * "is unsupported in Thriftly. Please choose a different data type. Program will now abort.")
12903>>>>
12903>>>                    Abort
12904>>>>
12904>>>                    Case Break
12905>>>                Case Else // this means it's probably a struct
12905>>>                    Move sElementTypeRef to sElementType
12906>>>                    // Let's see if this Struct is already defined, if it is, search it
12906>>>                    Send Ignore_Error of Error_Object_Id 4509
12907>>>                    Move False to err
12908>>>                    Move vStructs[0] to temp
12909>>>                    If (not(Err)) Begin
12911>>>                        Send Trap_Error of Error_Object_Id 4509
12912>>>                        Move (SearchArray(sElementType, vStructs[0], Self, GET_CompareVariantStrings)) to iArrayIndex
12913>>>                    End
12913>>>>
12913>>>                    Else Move -1 to iArrayIndex
12915>>>                    If (iArrayIndex > -1) Begin
12917>>>                        Move vStructs[1][iArrayIndex] to vType
12918>>>                        If (sElementArrayCount <> "") Move (ComCreateList(hoTypeBuilder, vType)) to vType
12921>>>                    End
12921>>>>
12921>>>                    Else Begin
12922>>>                        // Save the Struct Variant we're working on
12922>>>                        Get pvComObject of hoStructBuilder to vThisStructBuilder
12923>>>                        Get FindNode of hoBaseStructs (SFormat("//ns:struct[@name='%1']", sElementType)) to hoChildStruct
12924>>>                        Get ProcessType hoBaseStructs hoChildStruct (&vStructs) hoEvoInterface hoStructBuilder hoTypeBuilder to vStruct
12925>>>                        Set pvComObject of hoStructBuilder to vThisStructBuilder
12926>>>                        Move vStruct to vType
12927>>>                        If (sElementArrayCount <> "") Move (ComCreateList(hoTypeBuilder, vType)) to vType
12930>>>                    End
12930>>>>
12930>>>            Case End
12930>>>
12930>>>            Send ComAddField of hoStructBuilder (iNode + 1) sElementName (StructElementDescription(hoDocObj, sStructName, sElementName)) vType False
12931>>>        Loop
12932>>>>
12932>>>        
12932>>>        Move sStructName to vStructs[0][(SizeOfArray(vStructs[0]))]
12933>>>        Move (ComCreateStruct(hoStructBuilder, sStructName, StructDescription(hoDocObj, sStructName))) to vStruct
12934>>>        Move vStruct to vStructs[1][(SizeOfArray(vStructs[1]))]
12935>>>        
12935>>>        Function_Return vStruct
12936>>>    End_Function
12937>>>
12937>>>    Function ProcessTypes Handle hoWS Handle hoEvoInterface Handle hoStructBuilder Handle hoTypeBuilder Returns Variant[][]
12939>>>        String sTypesXML sElementName sElementType sElementArrayCount sStructName 
12939>>>        Handle hoXML hoRoot hoBaseStructs hoStructNode hoNode
12939>>>        Integer iNodeListLength iNode iStructNodeListLength iStructNode iArrayIndex sets_size cnt
12939>>>        Boolean bRetval
12939>>>        Variant[][] vStructs
12940>>>        Variant vStruct
12940>>>        
12940>>>        ServiceErrorType[] sets
12940>>>        ServiceErrorType[] sets
12941>>>        Get pServicesCustomErrorTypes to sets
12942>>>        Move (SizeOfArray(sets)-1) to sets_size
12943>>>        
12943>>>        Get pvStructs to vStructs
12944>>>        Get InterfaceTypeDefinitions of hoWS "ns" "http://tempuri.org" to sTypesXML
12945>>>        
12945>>>        Get Create U_cXMLDOMDocument to hoXML
12946>>>        Get LoadXML of hoXML sTypesXML to bRetval
12947>>>        If (bRetval) Begin
12949>>>                Set psSelectionNamespaces of hoXML to "xmlns:ns='http://tempuri.org'"
12950>>>            Get DocumentElement of hoXML to hoRoot
12951>>>            Get ElementNodes of hoRoot "ns:struct" to hoBaseStructs
12952>>>            Get NodeListLength of hoBaseStructs to iStructNodeListLength
12953>>>            
12953>>>            While (iStructNode < iStructNodeListLength and iStructNodeListLength > 0)
12957>>>                Get CollectionNode of hoBaseStructs iStructNode to hoStructNode
12958>>>                Get AttributeValue of hoStructNode "name" to sStructName
12959>>>
12959>>>                Get ProcessType hoBaseStructs hoStructNode (&vStructs) hoEvoInterface hoStructBuilder hoTypeBuilder to vStruct
12960>>>                
12960>>>                For cnt from 0 to sets_size
12966>>>>
12966>>>                    If (uppercase(sets[cnt].customErrorStructName) = uppercase(sStructName)) Move vStruct to sets[cnt].errorStruct
12969>>>                Loop
12970>>>>
12970>>>
12970>>>                Increment iStructNode    
12971>>>            Loop
12972>>>>
12972>>>        End
12972>>>>
12972>>>        Set pServicesCustomErrorTypes to sets
12973>>>        Set pvStructs to vStructs
12974>>>        
12974>>>        Function_Return vStructs
12975>>>    End_Function
12976>>>    
12976>>>    Function CreateErrorStructure Handle hoStructBuilder Handle hoTypeBuilder Handle hoEvoInterface Returns Variant
12978>>>        Variant vStruct
12978>>>        Set pvComObject of hoStructBuilder to (ComNewStruct(hoEvoInterface))
12979>>>        
12979>>>        Send ComAddField of hoStructBuilder 1 "Unhandled"   "" (ComCreateBool(hoTypeBuilder)) True
12980>>>        Send ComAddField of hoStructBuilder 2 "ErrorNumber" "" (ComCreateInt32(hoTypeBuilder)) True
12981>>>        Send ComAddField of hoStructBuilder 3 "LineNumber"  "" (ComCreateInt32(hoTypeBuilder)) True
12982>>>        Send ComAddField of hoStructBuilder 4 "IsCritical"  "" (ComCreateBool(hoTypeBuilder)) True
12983>>>        Send ComAddField of hoStructBuilder 5 "Value"       "" (ComCreateString(hoTypeBuilder)) True
12984>>>        Send ComAddField of hoStructBuilder 6 "Description" "" (ComCreateString(hoTypeBuilder)) False
12985>>>        Send ComAddField of hoStructBuilder 7 "Caption"     "" (ComCreateString(hoTypeBuilder)) False
12986>>>        Send ComAddField of hoStructBuilder 8 "CallStack"   "" (ComCreateList(hoTypeBuilder, ComCreateString(hoTypeBuilder))) False
12987>>>        
12987>>>        Function_Return (ComCreateStruct(hoStructBuilder, "ErrorData", ""))
12988>>>    End_Function
12989>>>    
12989>>>    // Event
12989>>>    Procedure OnPreSimpleServerStart Handle hoSettings
12991>>>    End_Procedure
12992>>>    
12992>>>    Procedure StartServer Boolean bSimpleServer
12994>>>        Handle hoEvoInterface hoServiceBuilder hoStructBuilder hoTypeBuilder
12994>>>        Handle hoPrototype hoStruct hoServer hoService hoServiceRuntime hoEvoService 
12994>>>        Handle[] services
12995>>>        Variant vServicesCollection vErrorStruct
12995>>>        Handle hoServicesCollection
12995>>>        Handle hoTimer
12995>>>        Handle hoSettings
12995>>>        Variant vSettings
12995>>>        Variant[][] vStructs
12996>>>        String sCurrDir
12996>>>        Integer iter
12996>>>        ServiceErrorType[] sets
12996>>>        ServiceErrorType[] sets
12997>>>        Integer sets_size
12997>>>        Integer cnt
12997>>>        Variant vAppliedErrorStruct
12997>>>        
12997>>>        // So the ErrorSystem class has this nasty bug/feature where it overwrites Error_Object_Id
12997>>>        // during construct_object...so anytime another error object is instantiated it replaces
12997>>>        // the prior error object. Because this is taking place in a procedure that MUST be forwarded
12997>>>        // we can't fix the behaviour in our subclass. Most developers probably don't care about it,
12997>>>        // but in our case we DON'T want our error class to kick in until Evolution has been
12997>>>        // start successfully. We want startup errors to use the standard error handler. So, after
12997>>>        // creating our error object and putting it in the property above, we reset the error
12997>>>        // object back to the standard one.
12997>>>        Move Error_Info_Object to Error_Object_Id        
12998>>>        
12998>>>        Get Create U_cComEvoInterface to hoEvoInterface
12999>>>        Send CreateComObject of hoEvoInterface
13000>>>
13000>>>        Get Create U_cComIEvoServiceBuilder to hoServiceBuilder
13001>>>        Get Create U_cComIEvoStructBuilder to hoStructBuilder
13002>>>        Get Create U_cComIEvoTypeBuilder to hoTypeBuilder
13003>>>        Set pvComObject of hoTypeBuilder to (ComNewType(hoEvoInterface))
13004>>>        
13004>>>        // We add a timer so that the GetMessage loop down below doesn't hang indefinitely and 
13004>>>        // we get a chance to check for things that should cause the app to quit.
13004>>>//#IF (!@ > 179)
13004>>>        Get Create U_cTimer to hoTimer
13005>>>        Set piTimeout of hoTimer to 2
13006>>>        Set pbEnabled of hoTimer to True
13007>>>//#ENDIF
13007>>>
13007>>>        // Because the error structure isn't "used" by any call, the code used to analyze a structure won't
13007>>>        // work here since DF doesn't know about this structure via the BaseWebService class. So instead
13007>>>        // we have to describe the structure defined at the top of this file.
13007>>>        Get CreateErrorStructure hoStructBuilder hoTypeBuilder hoEvoInterface to vErrorStruct
13008>>>        
13008>>>        // We now add this to our list of structs because custom error structs will most likely
13008>>>        // embed an ErrorData struct (although not technically required). By adding it here, when
13008>>>        // ProcessType is called and recursively analyzes other structs, if those structs include
13008>>>        // ErrorData, they won't try to add another copy of it causing an error.
13008>>>        Move "ErrorData" to vStructs[0][(SizeOfArray(vStructs[0]))]
13009>>>        Move vErrorStruct to vStructs[1][(SizeOfArray(vStructs[1]))]
13010>>>        Set pvStructs to vStructs
13011>>>            
13011>>>        Get phoServices to services
13012>>>        For iter from 0 to (SizeOfArray(services)-1)
13018>>>>
13018>>>            Move services[iter] to hoEvoService
13019>>>            
13019>>>            Send CreateComObject of hoEvoService
13020>>>            
13020>>>            Set pvComObject of hoServiceBuilder to (ComNewService(hoEvoInterface))
13021>>>            Send ProcessInterfaces of services[iter] hoEvoInterface hoServiceBuilder hoStructBuilder hoTypeBuilder
13022>>>            Get Create U_cComIEvoService to hoService
13023>>>            
13023>>>            // If we have a custom error structure, make sure to use it
13023>>>            Get pServicesCustomErrorTypes to sets
13024>>>            Move (SizeOfArray(sets)-1) to sets_size
13025>>>            Move vErrorStruct to vAppliedErrorStruct
13026>>>            For cnt from 0 to sets_size
13032>>>>
13032>>>                If (sets[cnt].serviceName = psServiceName(hoEvoService)) Move sets[cnt].errorStruct to vAppliedErrorStruct
13035>>>            Loop
13036>>>>
13036>>>            
13036>>>            Set pvComObject of hoService to (ComCreateServiceWithCustomExceptionData(hoServiceBuilder, psServiceName(hoEvoService), "", vAppliedErrorStruct))
13037>>>
13037>>>            Send RegisterDynamicEvents of hoEvoService          
13038>>>
13038>>>            Set ComService of hoEvoService to (pvComObject(hoService))
13039>>>            If (iter = 0) Begin
13041>>>                Get ComWrap of hoEvoService to vServicesCollection
13042>>>                Get Create U_cComIEvoServiceRuntimeCollection to hoServicesCollection
13043>>>                Set pvComObject of hoServicesCollection to vServicesCollection
13044>>>            End
13044>>>>
13044>>>            Else Begin
13045>>>                Send ComAdd of hoServicesCollection (pvComObject(hoEvoService))
13046>>>            End
13046>>>>
13046>>>            
13046>>>            Send ReleaseComObject of hoServiceBuilder
13047>>>        Loop
13048>>>>
13048>>>        
13048>>>        Send ReleaseComObject of hoTypeBuilder
13049>>>        Send ReleaseComObject of hoStructBuilder
13050>>>        Send ReleaseComObject of hoEvoInterface
13051>>>        
13051>>>        If (IsDebuggerPresent()) Begin
13053>>>            If (num_arguments = 1 AND bSimpleServer) Begin
13055>>>                Get Create U_cComEvoSimpleServer to hoServer
13056>>>                Send CreateComObject of hoServer
13057>>>                Get ComSettings of hoServer to vSettings
13058>>>                Get Create U_cComIEvoSimpleServerSettings to hoSettings
13059>>>                Set pvComObject of hoSettings to vSettings
13060>>>                
13060>>>                Set ComIncomingJwtConfigurations of hoSettings to "none"
13061>>>                Set ComOutgoingJwtConfiguration of hoSettings to "none"
13062>>>                Set ComTcpPort of hoSettings to 8080
13063>>>                Set ComServerProtocol of hoSettings to OLEEVO_JSON_RPC
13064>>>                Set ComServerTransport of hoSettings to OLEEVO_TRANSPORT_HTTP
13065>>>                Set ComLocalizeDatetime of hoSettings to True
13066>>>                Set ComStringEncoding of hoSettings to OLEEVO_ENCODING_ANSI
13067>>>                
13067>>>                Send OnPreSimpleServerStart hoSettings
13068>>>                Send ComStart of hoServer (pvComObject(hoServicesCollection)) OLEEVO_RECORDS_AND_ARRAYS
13069>>>            End
13069>>>>
13069>>>            Else Begin
13070>>>                Get Create U_cComEvoConsoleConnection to hoServer
13071>>>                Send CreateComObject of hoServer
13072>>>                Send ComConnect of hoServer (pvComObject(hoServicesCollection)) OLEEVO_RECORDS_AND_ARRAYS
13073>>>            End
13073>>>>
13073>>>        End
13073>>>>
13073>>>        Else Begin
13074>>>            Send Ignore_Error of Error_Object_Id 4399
13075>>>            Get Create U_cComEvoDispatchConnection to hoServer
13076>>>            Send CreateComObject of hoServer
13077>>>            
13077>>>            Send ComConnect of hoServer (pvComObject(hoServicesCollection)) OLEEVO_RECORDS_AND_ARRAYS
13078>>>            If ((Err) and LastErr = 4399) Begin
13080>>>                Get Create U_cComEvoConsoleConnection to hoServer
13081>>>                Send CreateComObject of hoServer
13082>>>                Send ComConnect of hoServer (pvComObject(hoServicesCollection)) OLEEVO_RECORDS_AND_ARRAYS
13083>>>            End
13083>>>>
13083>>>            Send Trap_Error of Error_Object_Id 4399
13084>>>        End
13084>>>>
13084>>>        
13084>>>        Set phoServer to hoServer
13085>>>        Set phOldErrorObject to Error_Object_Id
13086>>>        Move (phoErrorSys(Self)) to Error_Object_Id
13087>>>
13087>>>        // We have to run our own message loop so that DF stays running. Pretty standard stuff here...GetMessage 
13087>>>        // will pause waiting for something to come in and then do the standard Translate->Dispatch cycle and go 
13087>>>        // back to sleep.
13087>>>        tMSG msg
13087>>>        tMSG msg
13087>>>        Move 0 to msg.hwnd
13088>>>        Integer retval
13088>>>        Integer ticks elapsed_ticks
13088>>>        Move 0 to ticks
13089>>>        
13089>>>        While (True)
13093>>>            Move (GetMessage(AddressOf(msg), 0, 0, 0)) to retval
13094>>>            If (retval > 0) Begin
13096>>>                Move ((GetTickCount()) - ticks) to elapsed_ticks
13097>>>                If ((elapsed_ticks > 1500) or elapsed_ticks < 0) Begin
13099>>>                    Move (GetTickCount()) to ticks
13100>>>                    If (not(ComIsConnected(hoServer))) Begin
13102>>>                        Abort
13103>>>>
13103>>>                    End
13103>>>>
13103>>>                End
13103>>>>
13103>>>                Move (TranslateMessage(AddressOf(msg))) to windowindex
13104>>>                Move (DispatchMessage(AddressOf(msg))) to windowindex
13105>>>            End
13105>>>>
13105>>>            Else Abort
13107>>>        Loop
13108>>>>
13108>>>        
13108>>>        Abort
13109>>>>
13109>>>    End_Procedure
13110>>>    
13110>>>    Function JWTPayload Returns Variant
13112>>>        Variant vRuntime vPayload
13112>>>        Handle hoRuntime hoEvoService
13112>>>        Handle[] services
13113>>>        Integer iter
13113>>>        String stokenJWS
13113>>>                
13113>>>        // Search the Service which has the active JWT
13113>>>        Get phoServices to services
13114>>>        For iter from 0 to (SizeOfArray(services)-1)
13120>>>>
13120>>>            Move services[iter] to hoEvoService
13121>>>
13121>>>            Get ComRuntime of hoEvoService to vRuntime
13122>>>            Get Create U_cComIEvoRuntime to hoRuntime
13123>>>            Set pvComObject of hoRuntime to vRuntime
13124>>>            
13124>>>            // Look first for JWS
13124>>>            Move "" to stokenJWS
13125>>>            Get ComJWS of hoRuntime to stokenJWS
13126>>>            If (stokenJWS <> "") Begin
13128>>>                // Retrieve JWT and return
13128>>>                Get ComJWT of hoRuntime to vPayload
13129>>>                Move (SizeOfArray(services)) to iter
13130>>>            End
13130>>>>
13130>>>
13130>>>            Set pvComObject of hoRuntime to (NullComObject())
13131>>>            Send Destroy_Object of hoRuntime
13132>>>        Loop                                                       
13133>>>>
13133>>>                        
13133>>>        Function_Return vPayload
13134>>>    End_Function
13135>>>                        
13135>>>    Function JWSPayload Returns Variant
13137>>>        Variant vRuntime
13137>>>        Handle hoRuntime hoEvoService
13137>>>        Handle[] services
13138>>>        Integer iter
13138>>>        String sPayload
13138>>>                
13138>>>        // Search the Service which has the active JWT                
13138>>>        Get phoServices to services
13139>>>        For iter from 0 to (SizeOfArray(services)-1)
13145>>>>
13145>>>            Move services[iter] to hoEvoService
13146>>>
13146>>>            Get ComRuntime of hoEvoService to vRuntime
13147>>>            Get Create U_cComIEvoRuntime to hoRuntime
13148>>>            Set pvComObject of hoRuntime to vRuntime
13149>>>            
13149>>>            // Retrieve JWS and return            
13149>>>            Move "" to sPayload
13150>>>            Get ComJWS of hoRuntime to sPayload
13151>>>            If (sPayload <> "") Begin
13153>>>                Move (SizeOfArray(services)) to iter
13154>>>            End
13154>>>>
13154>>>
13154>>>            Set pvComObject of hoRuntime to (NullComObject())
13155>>>            Send Destroy_Object of hoRuntime
13156>>>        Loop                                                       
13157>>>>
13157>>>                        
13157>>>        Function_Return sPayload
13158>>>    End_Function
13159>>>       
13159>>>    Procedure Heartbeat
13161>>>        Variant vRuntime
13161>>>        Handle hoRuntime hoEvoService
13161>>>        Handle[] services
13162>>>        
13162>>>        Get phoServices to services
13163>>>        Move services[0] to hoEvoService
13164>>>        Get ComRuntime of hoEvoService to vRuntime
13165>>>        Get Create U_cComIEvoRuntime to hoRuntime
13166>>>        Set pvComObject of hoRuntime to vRuntime            
13167>>>        
13167>>>        Send ComHeartBeat of hoRuntime
13168>>>
13168>>>        Set pvComObject of hoRuntime to (NullComObject())
13169>>>        Send Destroy_Object of hoRuntime        
13170>>>    End_Procedure
13171>>>    
13171>>>    Procedure Set pbErrorsIncludeStackTrace Boolean bValue
13173>>>        Handle hoErrorSys
13173>>>        
13173>>>        Get phoErrorSys to hoErrorSys
13174>>>        Set pbErrorsIncludeStackTrace of hoErrorSys to bValue
13175>>>    End_Procedure
13176>>>    
13176>>>    Function pbErrorsIncludeStackTrace Returns Boolean
13178>>>        Handle hoErrorSys
13178>>>        
13178>>>        Get phoErrorSys to hoErrorSys
13179>>>        Function_Return (pbErrorsIncludeStackTrace(hoErrorSys))
13180>>>    End_Function
13181>>>End_Class
13182>
13182>Object oApplication is a cApplication
13184>    Set pbPreserveEnvironment to False
13185>End_Object
13186>
13186>Object oThriftly is a cThriftlyServer
13188>    Use PrimitivesService.pkg
Including file: PrimitivesService.pkg    (C:\Users\marce\OneDrive\Documentos\Thriftly Developer\Dataflex\Library_x64\AppSrc\PrimitivesService.pkg)
13188>>>Use cThriftlyService.pkg
13188>>>
13188>>>Struct token
13188>>>    DateTime expires_at
13188>>>    Integer level
13188>>>End_Struct
13188>>>
13188>>>Object oTestPrimitives is a cThriftlyService
13190>>>    Set psServiceName to "Primitives"
13191>>>    
13191>>>    Function LoginUser String user_name String password Returns token
#REM SEND REGISTERINTERFACE |CI5363 "get_LoginUser" "String user_name String password Returns token" ""
13195>>>        token toke
13195>>>        token toke
13195>>>        TimeSpan expir
13195>>>        If (lowercase(user_name) = "thriftly" and lowercase(password) = "thriftly") Begin
13197>>>            Move (DateSetMinute(expir, 30)) to expir
13198>>>            Move (CurrentDateTime() + expir) to toke.expires_at
13199>>>            Move 3 to toke.level
13200>>>            Function_Return toke
13201>>>        End
13201>>>>
13201>>>        Else Error 300 'You are not authorized! Try "thriftly" for the username and password.'
13203>>>    End_Function
13204>>>    
13204>>>    Function AuthMethod Integer iMethodID String sMethodName token toke Returns token
#REM SEND REGISTERINTERFACE |CI5364 "get_AuthMethod" "Integer iMethodID String sMethodName token toke Returns token" ""
13208>>>        TimeSpan expir
13208>>>        If (CurrentDateTime() < toke.expires_at) Begin
13210>>>            Move (DateSetMinute(expir, 30)) to expir
13211>>>            Move (CurrentDateTime() + expir) to toke.expires_at
13212>>>            Function_Return toke
13213>>>        End
13213>>>>
13213>>>        Else Error 300 "Your login has expired, please login again."
13215>>>    End_Function
13216>>>    
/PRIMITIVES.ADDSTRINGS
Image 1, PRIMITIVES.ADDSTRINGS
 // @param first_str This is a simple string parameter.
 // Note that any embedded \n's contained in the strings are left as-is.
 // 
 // @param second_str
 //     This parameter will be appended to the first parameter
 //     - A = Everything is Alright
 //     - C = Come back in the future
 // 
 // @returns    
 //     The return value will be the concatenation of both strings (first_str + second_str). Note
 //     that the maximum size of strings that can be appended is 64K total (result must be less than
 //     or equal to 64K).
 // 
 // @error 300 - Hopefully you don't get this error
 // 
 // @detail
 // This very simply function appends the second parameter to the first parameter and returns the result.
 //  
/*
13216>>>    Function AddStrings String first_str String second_str Returns String
#REM SEND REGISTERINTERFACE |CI5365 "get_AddStrings" "String first_str String second_str Returns String" ""
13220>>>        token toke
13220>>>        token toke
13220>>>        Get JWTPayload to toke
13221>>>        
13221>>>        If (toke.level >= 4) Begin
13223>>>            Function_Return (first_str + second_str)
13224>>>        End
13224>>>>
13224>>>        Else Error 300 (SFormat("Sorry, this function requires level %1 access, you only have level %2 access", 4, toke.level))
13226>>>    End_Function
13227>>>
13227>>>    Function XOR Boolean first_bool Boolean second_bool Returns Boolean
#REM SEND REGISTERINTERFACE |CI5366 "get_XOR" "Boolean first_bool Boolean second_bool Returns Boolean" ""
13231>>>        Function_Return ((first_bool and not(second_bool)) or (not(first_bool) and second_bool))             
13232>>>    End_Function
13233>>>
13233>>>    Function AddChars UChar first_char UChar second_char Returns UChar
#REM SEND REGISTERINTERFACE |CI5367 "get_AddChars" "UChar first_char UChar second_char Returns UChar" ""
13237>>>        Function_Return (first_char + second_char)
13238>>>    End_Function
13239>>>    
13239>>>    Function AddShorts Short first_short Short second_short Returns Short
#REM SEND REGISTERINTERFACE |CI5368 "get_AddShorts" "Short first_short Short second_short Returns Short" ""
13243>>>        Function_Return (first_short + second_short)
13244>>>    End_Function
13245>>>
13245>>>    Function AddIntegers Integer first_int Integer second_int Returns Integer
#REM SEND REGISTERINTERFACE |CI5369 "get_AddIntegers" "Integer first_int Integer second_int Returns Integer" ""
13249>>>        Function_Return (first_int + second_int)
13250>>>    End_Function
13251>>>
13251>>>    Function AddBigInts BigInt first_bigint BigInt second_bigint Returns BigInt
#REM SEND REGISTERINTERFACE |CI5370 "get_AddBigInts" "BigInt first_bigint BigInt second_bigint Returns BigInt" ""
13255>>>        Function_Return (first_bigint + second_bigint)
13256>>>    End_Function
13257>>>
13257>>>    Function AddNumbers Number first_number Number second_number Returns Number
#REM SEND REGISTERINTERFACE |CI5371 "get_AddNumbers" "Number first_number Number second_number Returns Number" ""
13261>>>        Function_Return (first_number + second_number)
13262>>>    End_Function
13263>>>    
13263>>>    Function AddDaysToDate Date start_date Integer num_days Returns Date
#REM SEND REGISTERINTERFACE |CI5372 "get_AddDaysToDate" "Date start_date Integer num_days Returns Date" ""
13267>>>        Function_Return (start_date + num_days)
13268>>>    End_Function
13269>>>    
13269>>>    Function AddMilliSecondsToDateTime DateTime start_datetime BigInt milliseconds Returns DateTime
#REM SEND REGISTERINTERFACE |CI5373 "get_AddMilliSecondsToDateTime" "DateTime start_datetime BigInt milliseconds Returns DateTime" ""
13273>>>        Function_Return (start_datetime + (cast(milliseconds, number)/1000.0))
13274>>>    End_Function
13275>>>End_Object
13276>    Use ArraysService.pkg
Including file: ArraysService.pkg    (C:\Users\marce\OneDrive\Documentos\Thriftly Developer\Dataflex\Library_x64\AppSrc\ArraysService.pkg)
13276>>>Use cThriftlyService.pkg
13276>>>Use set.pkg
Including file: set.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\set.pkg)
13276>>>>>Use VDFBase.pkg
13276>>>>>
13276>>>>>Class Set is an ARRAY
13277>>>>>    
13277>>>>>    Function Find_Element String ElemStr Returns Integer
13279>>>>>        Integer ndx retVal ArrMax
13279>>>>>        String ArrVal
13279>>>>>        Get item_count to ArrMax
13280>>>>>        Move -1 to retVal
13281>>>>>        Move 0 to ndx
13282>>>>>        While (ndx < ArrMax and retVal = -1)
13286>>>>>            Get array_value  ndx to ArrVal
13287>>>>>            If (ArrVal = ElemStr) ;                Move ndx to retVal
13290>>>>>            Move (ndx + 1) to ndx
13291>>>>>        loop
13292>>>>>>
13292>>>>>        Function_Return retVal
13293>>>>>    End_Function
13294>>>>>    
13294>>>>>    Procedure Add_Element String Elem_Str Returns Integer
13296>>>>>        Integer Ret_Val
13296>>>>>        
13296>>>>>        Get Find_Element Elem_Str to Ret_Val
13297>>>>>        
13297>>>>>        If (Ret_Val < 0) ;            Get Item_Count to Ret_Val
13300>>>>>        
13300>>>>>        Set Array_Value  Ret_Val to Elem_Str
13301>>>>>        
13301>>>>>        Procedure_Return Ret_Val
13302>>>>>    End_Procedure
13303>>>>>    
13303>>>>>    Procedure Remove_Element String sElement
13305>>>>>        Integer iIndex
13305>>>>>        Get Find_Element sElement to iIndex
13306>>>>>        If (iIndex > -1) ;            Send delete_item iIndex
13309>>>>>    End_Procedure
13310>>>>>    
13310>>>>>    
13310>>>>>End_Class
13311>>>>>
13311>>>>>//
13311>>>>>// global function to create set instances at random
13311>>>>>//
13311>>>>>Function make_set for cDesktop Returns Integer
13313>>>>>    Integer retval
13313>>>>>    Object SetTemplate is a Set
13315>>>>>        Move Self to retval
13316>>>>>    End_Object
13317>>>>>    Function_Return retval
13318>>>>>End_Function
13319>>>>>
13319>>>>>
13319>>>>>
13319>>>
13319>>>// ===========================================================================
13319>>>//
13319>>>// The ROUND_NUMBER global function has been designed to return the rounded
13319>>>// value of a given 'numeric' argument at a specified rounding precision.
13319>>>//
13319>>>// The function requires two arguments, as follows:-
13319>>>//
13319>>>// (a) The numeric value to be rounded, where the range of valid values is
13319>>>//     +/- 99,999,999,999,999.99999999.
13319>>>//
13319>>>// (b) The rounding precision required.  This must be an integer value in the
13319>>>//     range -13 to +8.  If a value outside this range is used, the nearest
13319>>>//     threshold value is substituted.
13319>>>//
13319>>>//     Values in the range +1 to +7 perform rounding on the decimal part of
13319>>>//     the number.  A value of +8 will perform no rounding at all.  A zero
13319>>>//     value will round to the nearest whole number.  Values -1 to -13 will
13319>>>//     round progressively to the left of the decimal point (a frequent
13319>>>//     requirement in financial reporting).
13319>>>//
13319>>>// If the result of the rounding produces a value outside the valid numeric
13319>>>// range (+/- 99,999,999,999,999.99999999) then a zero value is returned.
13319>>>//
13319>>>// Assumptions:-  The only assumptions made have been that the range of
13319>>>// numeric values and the limit of eight decimal places are unlikely to change
13319>>>// in the forseeable future.
13319>>>//
13319>>>// Examples:-
13319>>>//
13319>>>//  1st Argument      2nd Argument   Return Value
13319>>>//  ------------      ------------   ------------
13319>>>//  123456.87654321         8         123456.87654321
13319>>>//  123456.87654321         2         123456.88
13319>>>// -123456.87654321         2        -123456.88
13319>>>//  123456.98765432         0         123457
13319>>>// -123456.98765432        -1        -123460
13319>>>//  123456.98765432        -2         123500
13319>>>//  123456.98765432        -3         123000
13319>>>//  987654                 -4         990000
13319>>>//  987654                 -5        1000000
13319>>>//  987654                 -6        1000000
13319>>>//  987654                 -7              0
13319>>>//
13319>>>// ===========================================================================
13319>>>
13319>>>
13319>>> Function Round_Number Global Number nVal Integer iRnd Returns Number
13321>>>   // If the rounding precision falls in the range -5 to +8, then return:-
13321>>>   If (iRnd >= -5) Function_Return ;   (Number(Abs(nVal) / nVal) * 0.5 / (Number(10 ^ (iRnd min 8))) + nVal ;     / (Number(10 ^ (8 - (iRnd min 8)))) * (Number(10 ^ (8 - (iRnd min 8)))))
13324>>>   // Else, where the rounding precision is in the range -6 to -13, return:-
13324>>>   Function_Return ;     (Number(Abs(nVal) / nVal) * 0.5 * (Number(10 ^ (Abs(iRnd) min 13))) ;       + nVal / (Number(10 ^ 13)) / (Number(10 ^ ((Abs(iRnd) - 5) min 8))) ;         * (Number(10 ^ 13)) * (Number(10 ^ ((Abs(iRnd) - 5) min 8))))
13325>>> End_Function
13326>>> 
13326>>>Object oTestArrays is a cThriftlyService
13328>>>    Set psServiceName to "Arrays"
13329>>>
13329>>>    Function SubtractFirstFromSecond String[] first_str_array String[] second_str_array Returns String[]
#REM SEND REGISTERINTERFACE |CI5378 "get_SubtractFirstFromSecond" "String[] first_str_array String[] second_str_array Returns String[]" ""
13333>>>        Integer cnt i
13333>>>        Move (SizeOfArray(first_str_array)) to cnt
13334>>>        
13334>>>        For i from 0 to (cnt-1)
13340>>>>
13340>>>            Move (RemoveFromArray(second_str_array, SearchArray(first_str_array[i], second_str_array))) to second_str_array
13341>>>        Loop
13342>>>>
13342>>>        Function_Return second_str_array
13343>>>    End_Function
13344>>>
13344>>>    Function BitFlipper Boolean[] bits Returns Boolean[]
#REM SEND REGISTERINTERFACE |CI5379 "get_BitFlipper" "Boolean[] bits Returns Boolean[]" ""
13348>>>        Integer cnt i
13348>>>        Move (SizeOfArray(bits)) to cnt
13349>>>        
13349>>>        For i from 0 to (cnt-1)
13355>>>>
13355>>>            Move (not(bits[i])) to bits[i]
13356>>>        Loop
13357>>>>
13357>>>        Function_Return bits
13358>>>    End_Function
13359>>>
13359>>>    Function NegateShortArray Short[] shorts Returns Short[]
#REM SEND REGISTERINTERFACE |CI5380 "get_NegateShortArray" "Short[] shorts Returns Short[]" ""
13363>>>        Integer cnt i
13363>>>        Move (SizeOfArray(shorts)) to cnt
13364>>>        
13364>>>        For i from 0 to (cnt-1)
13370>>>>
13370>>>            Move (-1 * shorts[i]) to shorts[i]
13371>>>        Loop
13372>>>>
13372>>>        Function_Return shorts
13373>>>    End_Function
13374>>>
13374>>>    Function AddIntegerArrays Integer[] first_int_array Integer[] second_int_array Returns Integer[]
#REM SEND REGISTERINTERFACE |CI5381 "get_AddIntegerArrays" "Integer[] first_int_array Integer[] second_int_array Returns Integer[]" ""
13378>>>        Integer cnt i
13378>>>        Move (ResizeArray(first_int_array, (SizeOfArray(first_int_array) max SizeOfArray(second_int_array)))) to first_int_array
13379>>>        Move (ResizeArray(second_int_array, (SizeOfArray(first_int_array) max SizeOfArray(second_int_array)))) to second_int_array
13380>>>        Move (SizeOfArray(first_int_array)) to cnt
13381>>>        
13381>>>        For i from 0 to (cnt-1)
13387>>>>
13387>>>            Move (first_int_array[i] + second_int_array[i]) to first_int_array[i]
13388>>>        Loop
13389>>>>
13389>>>        Function_Return first_int_array
13390>>>    End_Function
13391>>>
13391>>>    Function SetOfIntegers Integer[] first_int_array Integer[] second_int_array Returns Integer[]
#REM SEND REGISTERINTERFACE |CI5382 "get_SetOfIntegers" "Integer[] first_int_array Integer[] second_int_array Returns Integer[]" ""
13395>>>        Handle hoSet
13395>>>        Integer cnt i
13395>>>
13395>>>        Get Create U_Set to hoSet
13396>>>
13396>>>        Move (SizeOfArray(first_int_array)) to cnt
13397>>>        For i from 0 to (cnt-1)
13403>>>>
13403>>>            Send add_element of hoSet first_int_array[i]
13404>>>        Loop
13405>>>>
13405>>>        
13405>>>        Move (SizeOfArray(second_int_array)) to cnt
13406>>>        For i from 0 to (cnt-1)
13412>>>>
13412>>>            Send add_element of hoSet second_int_array[i]
13413>>>        Loop
13414>>>>
13414>>>        
13414>>>        Integer[] retval
13415>>>        Get Item_Count of hoSet to cnt
13416>>>        For i from 0 to (cnt-1)
13422>>>>
13422>>>            Get Value of hoSet i to retval[i]
13423>>>        Loop
13424>>>>
13424>>>        Function_Return retval
13425>>>    End_Function
13426>>>
13426>>>    Function AddBigIntArrays BigInt[] first_bigint_array BigInt[] second_bigint_array Returns BigInt[]
#REM SEND REGISTERINTERFACE |CI5383 "get_AddBigIntArrays" "BigInt[] first_bigint_array BigInt[] second_bigint_array Returns BigInt[]" ""
13430>>>        Integer cnt i
13430>>>        Move (ResizeArray(first_bigint_array, (SizeOfArray(first_bigint_array) max SizeOfArray(second_bigint_array)))) to first_bigint_array
13431>>>        Move (ResizeArray(second_bigint_array, (SizeOfArray(first_bigint_array) max SizeOfArray(second_bigint_array)))) to second_bigint_array
13432>>>        Move (SizeOfArray(first_bigint_array)) to cnt
13433>>>        
13433>>>        For i from 0 to (cnt-1)
13439>>>>
13439>>>            Move (first_bigint_array[i] + second_bigint_array[i]) to first_bigint_array[i]
13440>>>        Loop
13441>>>>
13441>>>        Function_Return first_bigint_array
13442>>>    End_Function
13443>>>
13443>>>    Function RoundReals Real[] numbers Integer[] decimal_places Returns Real[]
#REM SEND REGISTERINTERFACE |CI5384 "get_RoundReals" "Real[] numbers Integer[] decimal_places Returns Real[]" ""
13447>>>        Integer cnt i
13447>>>        Number nVal
13447>>>        Move (ResizeArray(decimal_places, SizeOfArray(numbers))) to decimal_places
13448>>>        Move (SizeOfArray(numbers)) to cnt
13449>>>        
13449>>>        For i from 0 to (cnt-1)
13455>>>>
13455>>>            If (decimal_places[i] < -13) Move -13 to decimal_places[i]
13458>>>            If (decimal_places[i] > 8) Move 8 to decimal_places[i]
13461>>>            
13461>>>            // For some reason Dataflex dies when I pass a value to round_number using the array
13461>>>            // so instead we move the value to a local var and it all works.
13461>>>            Move numbers[i] to nVal
13462>>>            Move (Round_Number(nVal, decimal_places[i])) to numbers[i]
13463>>>        Loop
13464>>>>
13464>>>        
13464>>>        Function_Return numbers
13465>>>    End_Function
13466>>>    
13466>>>    Function AddDaysToDates Date[] dates Integer[] num_days Returns Date[]
#REM SEND REGISTERINTERFACE |CI5385 "get_AddDaysToDates" "Date[] dates Integer[] num_days Returns Date[]" ""
13470>>>        Integer cnt i
13470>>>        Move (ResizeArray(num_days, SizeOfArray(dates))) to num_days
13471>>>        Move (SizeOfArray(dates)) to cnt
13472>>>        
13472>>>        For i from 0 to (cnt-1)
13478>>>>
13478>>>            Move (dates[i] + num_days[i]) to dates[i]
13479>>>        Loop
13480>>>>
13480>>>        
13480>>>        Function_Return dates
13481>>>    End_Function
13482>>>    
13482>>>    Function FindDateOfClosestDayOfWeek DateTime[] datetimes Integer[] day_of_week Returns DateTime[]
#REM SEND REGISTERINTERFACE |CI5386 "get_FindDateOfClosestDayOfWeek" "DateTime[] datetimes Integer[] day_of_week Returns DateTime[]" ""
13486>>>        Integer cnt i dow diff
13486>>>        Move (ResizeArray(day_of_week, SizeOfArray(datetimes))) to day_of_week
13487>>>        Move (SizeOfArray(datetimes)) to cnt
13488>>>
13488>>>        For i from 0 to (cnt-1)
13494>>>>
13494>>>            Move (DateGetDayOfWeek(datetimes[i])) to dow
13495>>>            Move (Abs(day_of_week[i])) to day_of_week[i]
13496>>>            Move (6 min day_of_week[i]) to day_of_week[i]
13497>>>            Move (day_of_week[i] - dow) to diff
13498>>>            If (diff < 0) Move (diff + 7) to diff
13501>>>            Move (datetimes[i]+diff) to datetimes[i]
13502>>>        Loop
13503>>>>
13503>>>        
13503>>>        Function_Return datetimes
13504>>>    End_Function
13505>>>    
13505>>>    Function ThriftlyLogo Returns UChar[]
#REM SEND REGISTERINTERFACE |CI5387 "get_ThriftlyLogo" "Returns UChar[]" ""
13509>>>        UChar[] file
13510>>>        
13510>>>        Direct_Input ("BINARY:" + GetApplicationPath(ghoApplication) + "\thriftly-logo-500.png")
13511>>>            Read_Block file -1
13512>>>        Close_Input
13513>>>        
13513>>>        Function_Return file    
13514>>>    End_Function
13515>>>End_Object
13516>>>    
13516>    Use StructsService.pkg
Including file: StructsService.pkg    (C:\Users\marce\OneDrive\Documentos\Thriftly Developer\Dataflex\Library_x64\AppSrc\StructsService.pkg)
13516>>>Use cThriftlyService.pkg
13516>>>
13516>>>Struct tAllPrimitives
13516>>>    Boolean bool_val
13516>>>    Char char_val
13516>>>    Short short_val
13516>>>    Integer int_val
13516>>>    BigInt bigint_val
13516>>>    Number num_val
13516>>>    Date date_val
13516>>>    DateTime datetime_val
13516>>>    String string_val
13516>>>End_Struct
13516>>>
13516>>>Struct tPrimitiveArrays
13516>>>    Boolean[] bool_val
13516>>>    Short[] short_val
13516>>>    Integer[] int_val
13516>>>    BigInt[] bigint_val
13516>>>    Real[] num_val
13516>>>    Date[] date_val
13516>>>    DateTime[] datetime_val
13516>>>    String[] string_val
13516>>>End_Struct
13516>>>
13516>>>Struct tStructOfStructs
13516>>>    tAllPrimitives primitive
13516>>>    tAllPrimitives primitive
13516>>>    tPrimitiveArrays primitive_arrays
13516>>>    tPrimitiveArrays primitive_arrays
13516>>>End_Struct
13516>>>
13516>>>Object oTestStructs is a cThriftlyService
13518>>>    Set psServiceName to "Structs"
13519>>>
13519>>>    Function GetPrimitiveStruct Returns tAllPrimitives
#REM SEND REGISTERINTERFACE |CI5388 "get_GetPrimitiveStruct" "Returns tAllPrimitives" ""
13523>>>        tAllPrimitives prims
13523>>>        tAllPrimitives prims
13523>>>        DateTime dtNow
13523>>>        Move (CurrentDateTime()) to dtNow
13524>>>        Move (Random(1)) to prims.bool_val
13525>>>        Move (DateGetSecond(dtNow)) to prims.char_val
13526>>>        Move (DateGetDayOfYear(dtNow)) to prims.short_val
13527>>>        Move ((DateGetDayOfYear(dtNow) * 24 * 60 * 60) + (DateGetHour(dtNow) * 60 * 60) + (DateGetMinute(dtNow) * 60) + DateGetSecond(dtNow)) to prims.int_val
13528>>>        Move ((prims.int_val * 1000) + DateGetMillisecond(dtNow)) to prims.bigint_val
13529>>>        Move (Number(prims.int_val) + (Number(DateGetMillisecond(dtNow))/1000.0)) to prims.num_val
13530>>>        Move dtNow to prims.date_val
13531>>>        Move dtNow to prims.datetime_val
13532>>>        Move dtNow to prims.string_val
13533>>>        
13533>>>        Function_Return prims
13534>>>    End_Function
13535>>>    
13535>>>    Function TestPrimitiveStruct tAllPrimitives primitive_struct Returns tAllPrimitives
#REM SEND REGISTERINTERFACE |CI5389 "get_TestPrimitiveStruct" "tAllPrimitives primitive_struct Returns tAllPrimitives" ""
13539>>>        DateTime dtNow
13539>>>        Move (CurrentDateTime()) to dtNow
13540>>>        Move (not(primitive_struct.bool_val)) to primitive_struct.bool_val
13541>>>        Move (128 min (primitive_struct.char_val + Random(64))) to primitive_struct.char_val
13542>>>        Move (32767 min (primitive_struct.short_val + Random(8192))) to primitive_struct.short_val
13543>>>        Move (2147483647 min (primitive_struct.int_val + Random(536870912))) to primitive_struct.int_val
13544>>>        Move (primitive_struct.bigint_val * Random(256)) to primitive_struct.bigint_val
13545>>>        Move (primitive_struct.date_val + Random(30)) to primitive_struct.date_val
13546>>>        Move (dtNow + Random(365)) to primitive_struct.datetime_val
13547>>>        Move (String(dtNow + Random(365)) + " - " + primitive_struct.string_val) to primitive_struct.string_val
13548>>>        
13548>>>        Function_Return primitive_struct
13549>>>    End_Function
13550>>>    
13550>>>    Procedure MovePrimToArrElement tAllPrimitives prim tPrimitiveArrays ByRef primarr Integer i
13553>>>        Move (not(prim.bool_val)) to primarr.bool_val[i]
13554>>>        Move (prim.short_val+i) to primarr.short_val[i]
13555>>>        Move (prim.int_val+i) to primarr.int_val[i]
13556>>>        Move (prim.bigint_val+i) to primarr.bigint_val[i]
13557>>>        Move (prim.num_val+Number(i)) to primarr.num_val[i]
13558>>>        Move (prim.date_val+i) to primarr.date_val[i]
13559>>>        Move (prim.datetime_val) to primarr.datetime_val[i]
13560>>>        Move (prim.string_val + " i = " + String(i)) to primarr.string_val[i]
13561>>>    End_Function
13562>>>
13562>>>    Function GetPrimitiveArraysStruct Returns tPrimitiveArrays
#REM SEND REGISTERINTERFACE |CI5391 "get_GetPrimitiveArraysStruct" "Returns tPrimitiveArrays" ""
13566>>>        tPrimitiveArrays primarr
13566>>>        tPrimitiveArrays primarr
13566>>>        tAllPrimitives prim
13566>>>        tAllPrimitives prim
13566>>>        Integer i
13566>>>        
13566>>>        For i from 0 to 9
13572>>>>
13572>>>            Get GetPrimitiveStruct to prim
13573>>>            Send MovePrimToArrElement prim (&primarr) i
13574>>>        Loop
13575>>>>
13575>>>        Function_Return primarr
13576>>>    End_Function
13577>>>
13577>>>    Function GetStructOfStructs Returns tStructOfStructs
#REM SEND REGISTERINTERFACE |CI5392 "get_GetStructOfStructs" "Returns tStructOfStructs" ""
13581>>>        tStructOfStructs strofstr
13581>>>        tStructOfStructs strofstr
13581>>>        
13581>>>        Get GetPrimitiveStruct to strofstr.primitive
13582>>>        Get GetPrimitiveArraysStruct to strofstr.primitive_arrays
13583>>>        Function_Return strofstr
13584>>>    End_Function
13585>>>    
13585>>>    Function GetArrayOfStructs tAllPrimitives[] primitives Returns tAllPrimitives[]
#REM SEND REGISTERINTERFACE |CI5393 "get_GetArrayOfStructs" "tAllPrimitives[] primitives Returns tAllPrimitives[]" ""
13589>>>        tAllPrimitives[] prims
13589>>>        tAllPrimitives[] prims
13590>>>        Integer i
13590>>>        
13590>>>        For i from 0 to 9
13596>>>>
13596>>>            Get GetPrimitiveStruct to prims[i]
13597>>>        Loop
13598>>>>
13598>>>        
13598>>>        Function_Return prims
13599>>>    End_Function
13600>>>    
13600>>>    Function AddStrings String first_str String second_str Returns String
#REM SEND REGISTERINTERFACE |CI5365 "get_AddStrings" "String first_str String second_str Returns String" ""
13604>>>        token toke
13604>>>        token toke
13604>>>        Get JWTPayload to toke
13605>>>        
13605>>>        If (toke.level >= 3) Begin
13607>>>            Function_Return (first_str + second_str)
13608>>>        End
13608>>>>
13608>>>        Else Error 300 (SFormat("Sorry, this function requires level %1 access, you only have level %2 access", 3, toke.level))
13610>>>    End_Function    
13611>>>    
13611>>>    Function JWS Returns String
#REM SEND REGISTERINTERFACE |CI5394 "get_JWS" "Returns String" ""
13615>>>        token toke
13615>>>        token toke
13615>>>        String stoke
13615>>>        Get JWTPayload to toke
13616>>>        
13616>>>        If (toke.level >= 4) Begin
13618>>>            Get JWSPayload to stoke
13619>>>            Function_Return (stoke)
13620>>>        End
13620>>>>
13620>>>        Else Error 300 (SFormat("Sorry, this function requires level %1 access, you only have level %2 access", 4, toke.level))
13622>>>    End_Function   
13623>>>    
13623>>>    Function AuthMethod Integer iMethodID String sMethodName token toke Returns token
#REM SEND REGISTERINTERFACE |CI5364 "get_AuthMethod" "Integer iMethodID String sMethodName token toke Returns token" ""
13627>>>        TimeSpan expir
13627>>>        If (CurrentDateTime() < toke.expires_at) Begin
13629>>>            Move (DateSetMinute(expir, 30)) to expir
13630>>>            Move (CurrentDateTime() + expir) to toke.expires_at
13631>>>            Function_Return toke
13632>>>        End
13632>>>>
13632>>>        Else Error 300 "Your login has expired, please login again."
13634>>>    End_Function    
13635>>>    
13635>>>End_Object
13636>>>
13636>>>
13636>    Use ErrorsService.pkg
Including file: ErrorsService.pkg    (C:\Users\marce\OneDrive\Documentos\Thriftly Developer\Dataflex\Library_x64\AppSrc\ErrorsService.pkg)
13636>>>Use cThriftlyService.pkg
13636>>>
13636>>>Object oTestErrors is a cThriftlyService
13638>>>    Set psServiceName to "Errors"
13639>>>
13639>>>    Function ThrowInvalidExpression Returns String
#REM SEND REGISTERINTERFACE |CI5395 "get_ThrowInvalidExpression" "Returns String" ""
13643>>>        Move "This is a test" to WindowIndex
13644>>>        Function_Return ""
13645>>>    End_Function
13646>>>
13646>>>    Function ErrorCommand Returns String
#REM SEND REGISTERINTERFACE |CI5396 "get_ErrorCommand" "Returns String" ""
13650>>>        Error 411 "This is an error command."
13651>>>>
13651>>>        Function_Return ""
13652>>>    End_Function
13653>>>
13653>>>    Function ThrowServiceException Returns String
#REM SEND REGISTERINTERFACE |CI5397 "get_ThrowServiceException" "Returns String" ""
13657>>>        ErrorData exception
13657>>>        ErrorData exception
13657>>>
13657>>>        Move "This is an Error Description. The Value should be 'blah' and error number is 10000. Callstack will contain just the name of this function and line number is the line the exception was thrown on." to exception.Description
13658>>>        Move "Blah" to exception.Value
13659>>>        Move 10000 to exception.ErrorNumber
13660>>>        Move "The caption element is something Dataflex sometimes uses" to exception.Caption
13661>>>        Send ServiceException "This is the error message" exception                
13662>>>        Function_Return ""
13663>>>    End_Function
13664>>>End_Object
13665>>>
13665>>>
13665>    
13665>    // This event is only called when using the "Simple Server". This mode is activated by passing
13665>    // True as an additional parameter on the StartServer call. Most developers will never use this,
13665>    // but just in case, these are the settings you can adjust. The Developer Helper let's you do
13665>    // all of this graphically which is much easier.
13665>    Procedure OnPreSimpleServerStart Handle hoSettings
13668>//        Set ComIncomingJwtConfigurations of hoSettings to "none"
13668>//        Set ComOutgoingJwtConfiguration of hoSettings to "none"
13668>//        Set ComTcpPort of hoSettings to 8080
13668>//        Set ComServerProtocol of hoSettings to OLEEVO_JSON_RPC
13668>//        Set ComServerTransport of hoSettings to OLEEVO_TRANSPORT_HTTP
13668>//        Set ComLocalizeDatetime of hoSettings to True
13668>//        Set ComStringEncoding of hoSettings to OLEEVO_ENCODING_ANSI
13668>    End_Procedure
13669>End_Object
13670>
13670>Send StartServer of oThriftly
13671>
Summary
Memory Available: 2147483646
Total Warnings : 1
Total Errors   : 0
Total Symbols  : 12115
Total Resources: 0
Total Commands : 13670
Total Windows  : 4
Total Pages    : 1
Static Data    : 134339
Message area   : 79889
Total Blocks   : 6594
